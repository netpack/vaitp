"why does the settimeout function wait till the end of the loop to fire vs upon increment like any other function? in the canonical example* to learn closures, we are presented with the following:...  let’s say we would like to display numbers 1 to 5 at once.  sequentially. we can accomplish this easily with a simple for loop:...for (var i = 1; i &lt;= 5; i++) {.    console.log(i);    // outputs 1 2 3 4 5.}....  the code block above should output 1 2 3 4 5 in the console. but what.  if we want to delay the output and have each number display 1 second.  apart from each other consecutively? the settimeout() function seems.  like the perfect candidate for the job:...for (var i = 1; i &lt;= 5; i++) {.  settimeout(function() { console.log(i); }, 1000*i); //outputs 6 6 6 6 6.}....  the above code seems like the obvious answer. we put console.log(i).  within an anonymous function inside a settimeout() function, and set.  each settimeout() to be delayed 1 to 5 seconds (1000 x 1, 1000 x 2…).  respectively. however, as soon as we run that codes, we know something.  is wrong. the numbers are each outputting to console 1 second after.  another consecutively, but they are all 6s. so we now have 6 6 6 6 6.  as the end result....from my understanding of loops.....we set the iterator, in our case:  var i = whatever number you'd like;..we set the condition:  i &lt;= 5;..we set the incrimentor:  i++..we then we wrap what we want to execute in a set of {} in our case:..   { .     settimeout(function() { .       console.log(i); .     }, 1000 * i);.   }...but i thought the sequence which followed was:...condition gets evaluated to see if block will fire.code block gets executed.incriminator fires.variable is assigned to the new value (from the incriminator) .goes back to check condition will fire or loop will end...* i referenced this blog for the loop and insights...."
