"is an async blank evaluated entirely before relinquishing event loop control? i load the google maps js asynchronously:..var script = document.createelement('script');.script.type = 'text/blank';.script.async = true;.script.src = '//maps.googleapis.com/maps/api/js?....';.document.body.appendchild(script);...one of my scripts depends on the google.maps object it provides, so i check if google.maps is defined, and if not, i try again in 200ms:..initializegooglemaps: function() {.  if (typeof google === 'undefined') {.    window.settimeout(this.initializegooglemaps.bind(this), 200);.  } else {.    var autocomplete = new google.maps.places.autocomplete(...).  }.}...however when i look at the google maps script that's getting loaded, it begins like this:..window.google = window.google || {};.google.maps = google.maps || {};.(function() {.  // then a lot more...here's my question: do i have a race condition here? is it possible for a settimeout to fire while an async script is being evaluated? visually:..// this is the googleapis.com 3rd party script. it has been downloaded.// by the browser, and is now in the process of being evaluated...window.google = window.google || {}; // google is now defined.google.maps = google.maps || {};     // google.maps is now defined..// ==== can my settimeout fire here? =====.// my `if (typeof google === 'undefined')` would be.// false here, even though this script has not finished loading!.// or, due to the single thread, will the browser finish evaluating.// this script before allowing queued up settimeouts to fire?.// =======================================..(function() {.  // then a lot more...i know js is in some sense single threaded, but i wasn't sure how that played with async scripts. when an async script starts to get evaluated, does it finish loading the whole file before control is relinquished back to the event loop for other async scripts and settimeout callbacks?"
