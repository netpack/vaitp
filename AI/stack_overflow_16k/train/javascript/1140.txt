"are getters and setters the only way to avoid prototype mutations? i have a blank object, and i want to extend it. the problem is that it's variables mutate from one scope to another...first, i create a mammal prototype, and he has a name, this name can be printed with the whoami function..var mammal = ( function () {..    var whoami = function () {.        console.log(""i am "" + this.name);.    };..    return {.        name : ""mammal"",.        whoami : whoami.    };..})();...then, i create a dog, who has a name too. it's name can be printed, directly from whoami, or from the state function...var dog = ( function (mammal) {.    mammal.name = ""dog"";..    mammal.state = function () {.    mammal.whoami();.    console.log(""i am happy"");.    };..    return mammal;..})(object.create(mammal));...but when i want to create an instance of dog, and set his name from the outside, there seem to be two name variable: one in dog, and another in the new created variable shipo...var shipo = object.create(dog);.shipo.name = ""shipo"".shipo.state(); // it's name is dog.shipo.whoami(); // it's name is shipo.// mutation? :(...i can solve this, by implementing a getter and a setter function for the name variable, on the mammal definition... but i hate using getters and setters, my code would be shorter if variables could be publicly setted and getted without this ugly functions.....are getters and setters the only way to prevent this kind of mutations?"
