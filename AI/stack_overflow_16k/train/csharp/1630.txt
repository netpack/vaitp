"how can i reduce coupling in this code at work i'm doing this application that takes values from an external file (excel sheet, text file, ...) and translates those values into complex instructions that are fed into another system...the below code is a bit simplified (no instructions and very simple logic) but the idea remains the same. i have around 60 different translators that run different kinds of business logic behind. some take only one argument to run. others take multiple arguments...i have an abstract translator class. the user of the class will use 2 public methods: translate to run the translation logic and cantranslate allows to see if the translator is ready to start...the developer using this abstract class needs to implement the dotranslate method which will contain the actual business logic. by default cantranslate always return true but if validation is required it can be overridden...here's the abstract translator base class:..// contains some base logic which is the same for all translators.public abstract class basetranslator.{.    // public translate method.    public void translate().    {.        if (cantranslate()).            dotranslate();.    }..    // checks if we are ready to translate.    // true by default.    public virtual bool cantranslate().    {.        return true;.    }..    // this method is used to implement business logic.    public abstract void dotranslate();.}...and here's an implementation of a concrete translator class:..// translates beer names.public class reversetranslator : basetranslator.{.    // use of properties to allow strongly typed arguments.    // which can be seen by the developer at design time.    public string beername { get; set; }..    // validation.    public override bool cantranslate().    {.        if (beername.equals(""budweiser"") || beername.equals(""stella"")).            return true;.        else.            return false;.    }..    // implementation of the business logic.    public override void dotranslate().    {.        char[] letters = beername.tochararray();.        array.reverse(letters);.        console.writeline(new string(letters));.    }.}...and here's what it looks like when in use:..class program.{.    public static void main(string[] args).    {.        var translator = new reversetranslator();..        translator.beername = ""stella"";.        translator.translate();..        translator.beername = ""i'm not a beer"";.        // this line will not translate since it's not a valid beer name..        translator.translate();..        console.readline();.    }.}...pro's:...separates specific business logic in small maintainable units.translators are easy to reuse in other parts of the application.translators can easily be unit tested.properties allow a user of a translator to see which arguments are required...my problem:...different controller classes are using many translators. i have too much coupling....i thought of using the factory pattern for translator creation but then i can't use properties as argument hints at design time...so i'm basically looking for a solution in which during design time you can easily see which arguments are required. and at the same time i would hope to reduce coupling by not having each controller having 30 new xtranslator statements...ps: i'm limited to use .net 3.5 for this code."
