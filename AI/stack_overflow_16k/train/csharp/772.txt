"strongly related classes and type safe abstractions i am designing a system that works with multiple data sources. these data sources have identifiers that can have certain checks done on them when they are created. it permits getting historical and real time data. my current abstraction involves three base classes. ..the datasource class is responsible for connections to services and maintaining esoteric things for that data source including how to open and close connections and thread safety concerns on a case by case basis. ..the datacontext class is responsible for which values to get, be they realtime or historic and on what date etc, there may be other contexts where you could desire mixed historic dates (parameterized) among other things which is why i want to use polymorphism to accomplish this. ..the identifier class is responsible for parsing strings and validation against regular expressions to make sure that the string identifier that gets passed in is at least valid to some degree. it is also used for the type safety, because an identifier for one data source is not allowed to be passed into another data source...see example code below;..public class datasource.{.    // base class for all data sources.    // maintains connections opening and closing plus .    // thread safety concerns.}.public class foodatasource : datasource { }..public class bardatasource : datasource { }..public abstract class identifier.{.    public string value { get; internal set; }..    public identifier(string value).    {.        value = value; .    }.}..public class fooidentifier : identifier.{.    public fooidentifier(string value) : base(value).    {.        // checks go here on the string that comes in .        // specific to the foo data source.    }.}..public class baridentifier : identifier.{.    public baridentifier(string value) : base(value).    {.        // checks on the string values that come in for the bar .        // source .    }.}...public abstract class datacontext&lt;tidentifier&gt; where tidentifier : identifier.{.    public abstract double getvalue(tidentifier id); .}..public abstract class foodatacontext : datacontext&lt;fooidentifier&gt; { }..public abstract class bardatacontext : datacontext&lt;baridentifier&gt; { }..public class foorealtimedatacontext : foodatacontext.{.    public override double getvalue(fooidentifier id).    {.        // real implementation here .        return -1; .    }.}..public class barrealtimedatacontext : bardatacontext.{.    public override double getvalue(baridentifier id).    {.        // real implementation here.        return -10; .    }.}...[testfixture].public static class testme.{.    [test].    public static void mytest().    {.        // create the data context (to get data from) .        var ctx = new foorealtimedatacontext();..        ctx.getvalue(new fooidentifier(""onetuhoenthuo"")); // compiles (good).        // ctx.getvalue(new baridentifier(""noetuhneoth"")); // does not compile (also good).    }.}...the question (finally) is how do i create a class that actually follows oop principals to fill in the following class shell? ..public class universalrealtimedatasource : datasource&lt;identifier&gt; {.    public double getvalue(identifier id) {.        // there would have to be code in here that says ""if(id is fooidentifier) ... else ... .        // which is (imo) an anti-pattern so, how to avoid this? .    }.}...edit: i have been trying to keep the compile time type safety guarantees as much as possible. this would be fairly straightforward with some if(!(id is fooidentifier)) throw exception type of code but i want to make it impossible for this to occur at compile time."
