"blank terminate process with ctrl-c i have to use ffmpeg in our system, but our system doesnt support multitasking. i can start external programs with batchfile or exe. i use ffmpeg to record during testrun afterwords my system start my exceutable and then ffmpeg shall be terminated. i used process.kill(), but recognized, that the file seems not correct closed, because videofile ends with pause, instead of stop. i found the solution http://stanislavs.org/stopping-command-line-applications-programatically-with-ctrl-c-events-from-net/ . i used solution 4 in my code, but seems not to work. ..my program is a toggle switch for ffmpeg start and stop, means.1. execute my program ffmpeg starts.2. execute my program ffmpeg shall stop ..if i debug, then the method is executed, but ffmpeg is still open in taskmanager. if i use p.kill(), then process will hard terminated...process p = process.getprocessbyid(int32.parse(appsettings.getappsetting(""procid"")));.                if (p.processname == ""ffmpeg"").                {.                    //p.kill(); //works .                    stopprogrambyattachingtoitsconsoleandissuingctrlcevent(p); // doesnt work.                    console.writeline(""recording stopped"");...edit:.seems that i did not attached to console, but proc.id is correct...if (attachconsole((uint)proc.id))...is not true, but proc.id seems correct...full code:..using system;.using system.collections.generic;.using system.linq;.using system.text;.using system.threading.tasks;.using system.diagnostics;.using system.threading;.using bizark.core;.using bizark.core.cmdline;.using system.runtime.interopservices;.using system.collections;...namespace recorder.{.    class program.    {.        #region pinvoke..        [dllimport(""kernel32.dll"", setlasterror = true)].        static extern bool attachconsole(uint dwprocessid);..        [dllimport(""kernel32.dll"", setlasterror = true, exactspelling = true)].        static extern bool freeconsole();..        [dllimport(""kernel32.dll"")].        static extern bool setconsolectrlhandler(consolectrldelegate handlerroutine, bool add);.        // delegate type to be used as the handler routine for scch.        delegate boolean consolectrldelegate(ctrltypes ctrltype);..        // enumerated type for the control messages sent to the handler routine.        enum ctrltypes : uint.        {.            ctrl_c_event = 0,.            ctrl_break_event,.            ctrl_close_event,.            ctrl_logoff_event = 5,.            ctrl_shutdown_event.        }..        [dllimport(""kernel32.dll"")].        [return: marshalas(unmanagedtype.bool)].        private static extern bool generateconsolectrlevent(ctrltypes dwctrlevent, uint dwprocessgroupid);..        private enum showcommands.        {.            sw_hide = 0,.            sw_shownormal = 1,.            sw_normal = 1,.            sw_showminimized = 2,.            sw_showmaximized = 3,.            sw_maximize = 3,.            sw_shownoactivate = 4,.            sw_show = 5,.            sw_minimize = 6,.            sw_showminnoactive = 7,.            sw_showna = 8,.            sw_restore = 9,.            sw_showdefault = 10,.            sw_forceminimize = 11,.            sw_max = 11.        }.        [dllimport(""shell32.dll"")].        static extern intptr shellexecute(intptr hwnd, string lpoperation, string lpfile, string lpparameters, string lpdirectory, showcommands nshowcmd);..        [structlayout(layoutkind.sequential, charset = charset.unicode)].        struct startupinfo.        {.            public int32 cb;.            public string lpreserved;.            public string lpdesktop;.            public string lptitle;.            public int32 dwx;.            public int32 dwy;.            public int32 dwxsize;.            public int32 dwysize;.            public int32 dwxcountchars;.            public int32 dwycountchars;.            public int32 dwfillattribute;.            public int32 dwflags;.            public int16 wshowwindow;.            public int16 cbreserved2;.            public intptr lpreserved2;.            public intptr hstdinput;.            public intptr hstdoutput;.            public intptr hstderror;.        }..        [structlayout(layoutkind.sequential)].        internal struct process_information.        {.            public intptr hprocess;.            public intptr hthread;.            public int dwprocessid;.            public int dwthreadid;.        }..        [structlayout(layoutkind.sequential)].        public struct security_attributes.        {.            public int nlength;.            public intptr lpsecuritydescriptor;.            public int binherithandle;.        }..        [dllimport(""kernel32.dll"")].        static extern bool createprocess(string lpapplicationname,.           string lpcommandline, ref security_attributes lpprocessattributes,.           ref security_attributes lpthreadattributes, bool binherithandles,.           uint dwcreationflags, intptr lpenvironment, string lpcurrentdirectory,.           [in] ref startupinfo lpstartupinfo,.           out process_information lpprocessinformation);..        private const int wm_vscroll = 277;.        private const int sb_bottom = 7;..        [dllimport(""kernel32.dll"", setlasterror = true)].        [return: marshalas(unmanagedtype.bool)].        public static extern bool createpipe(out intptr hreadpipe, out intptr hwritepipe, ref security_attributes lppipeattributes, uint nsize);..        [dllimport(""user32.dll"")].        private static extern bool showwindowasync(intptr hwnd, int ncmdshow);..        [dllimport(""user32.dll"")].        [return: marshalas(unmanagedtype.bool)].        private static extern bool showwindow(intptr hwnd, showcommands ncmdshow);..        [dllimport(""user32.dll"", setlasterror = true)].        private static extern uint getwindowthreadprocessid(intptr hwnd, out uint lpdwprocessid);..        [dllimport(""user32.dll"", setlasterror = true, charset = charset.auto)].        public static extern int getclassname(intptr hwnd, stringbuilder lpclassname, int nmaxcount);..        [dllimport(""user32.dll"", charset = charset.auto, setlasterror = true)].        public static extern int getwindowtext(intptr hwnd, stringbuilder lpstring, int nmaxcount);..        public delegate bool enumedwindow(intptr handlewindow, arraylist handles);..        [dllimport(""user32.dll"", charset = charset.auto, setlasterror = true)].        [return: marshalas(unmanagedtype.bool)].        public static extern bool enumwindows(enumedwindow lpenumfunc, arraylist lparam);..        [dllimport(""user32.dll"", charset = charset.auto, entrypoint = ""sendmessage"")].        private static extern intptr sendmessage(intptr hwnd, uint msg, intptr wparam, intptr lparam);..        [return: marshalas(unmanagedtype.bool)].        [dllimport(""user32.dll"", setlasterror = true)].        static extern bool postmessage(intptr hwnd, uint msg, intptr wparam, intptr lparam);..        private const int vk_control = 0x11;.        private const int wm_keydown = 0x100;.        private const int wm_char = 0x102;.        private const int wm_keyup = 0x101;.        private const int vk_cancel = 0x03;.        private const int vk_c = 0x0043;.        #endregion pinvoke.        static process proc = null;.        static processstartinfo psi = null;.        static appsettings appsettings = new appsettings();...        static void main(string[] args).        {.            consoleapplication.runprogram&lt;arguments&gt;(runmain);.        }..        static void runmain(arguments args).        {.            bool state = bool.parse(appsettings.getappsetting(""state""));.            state = !state;.            appsettings.setappsetting(""state"", state.tostring());.            if (state).            {.                run(args.ofilename);.                appsettings.setappsetting(""procid"", proc.id.tostring());.                appsettings.setappsetting(""procname"", proc.processname);.                console.writeline(""recording started"");.            }else{.                process p = process.getprocessbyid(int32.parse(appsettings.getappsetting(""procid"")));.                if (p.processname == ""ffmpeg"").                {.                    //p.kill(); //works .                    stopprogrambyattachingtoitsconsoleandissuingctrlcevent(p); // doesnt work.                    console.writeline(""recording stopped"");..                }.            }.        }..        public static void stopprogrambyattachingtoitsconsoleandissuingctrlcevent(process proc).        {.            //this does not require the console window to be visible..            if (attachconsole((uint)proc.id)).            {.                //disable ctrl-c handling for our program.                setconsolectrlhandler(null, true);.                generateconsolectrlevent(ctrltypes.ctrl_c_event, 0);..                //must wait here. if we don't and re-enable ctrl-c handling below too fast, we might terminate ourselves..                proc.waitforexit();..                freeconsole();..                //re-enable ctrl-c handling or any subsequently started programs will inherit the disabled state..                setconsolectrlhandler(null, false);.            }.        }..        static void run(string outputfilename).        {..            try.            {.                psi = new processstartinfo(appsettings.getappsetting(""ffmpegpath""));.                psi.arguments = ""-r 25 -i "" + appsettings.getappsetting(""cameraurl"") + "" -y -c:v copy -vcodec libx264 -pix_fmt yuv420p -f h264 -b:v 128k -bufsize 128k -r 25 "" + outputfilename;.                psi.workingdirectory = appsettings.getappsetting(""workingpath"");.                psi.createnowindow = false;.                psi.redirectstandardinput = false;.                psi.redirectstandardoutput = false;.                psi.redirectstandarderror = false;.                psi.windowstyle = processwindowstyle.normal;.                psi.useshellexecute = false;.                proc = process.start(psi);.            }.            catch(exception).            {..            }.        }..    }.}"
