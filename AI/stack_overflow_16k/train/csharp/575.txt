"what is the best way to use parallel.for in a recursive algorithm? i am building software to evaluate many possible solutions and am trying to introduce parallel processing to speed up the calculations.  my first attempt was to build a datatable with each row being a solution to evaluate but building the datatable takes quite some time and i am running into memory issues when the number of possible solutions goes into the millions. ..the problem which warrants these solutions is structured as follows: .there is a range dates for x number of events which must be done in order. the solutions to evaluate could look as follows with each solution being a row, the events being the columns and the day number being the values...given 3 days (0 to 2) and three events:.0 0 0.0 0 1.0 0 2.0 1 1.0 1 2.0 2 2.1 1 1.1 1 2.1 2 2.2 2 2  ..my new plan was to use recursion and evaluate the solutions as i go rather than build a solution set to then evaluate.....for(int day = 0; day &lt; maxdays; day++).{.  list&lt;int&gt; mydays = new list&lt;int&gt;();.  mydays.add(day);.  evalevent(0,day,mydays);.}..private void evalevent(int eventnum, .int day, list&lt;int&gt; mydays).{.   parallel.for(day,maxdays, day2 =&gt;  .// events must be on same day or after previous events.   {.     list&lt;int&gt; mydays2 = new list&lt;int&gt;();.     for(int a = 0; a &lt;mydays.count;a++).     {.        mydays2.add(mydays[a]);.     }.     mydays2.add(day2);.     if(eventnum&lt; eventcount - 1) // proceed to next event.     {.      evalevent(eventnum+1, day2,mydays2);.     }.     else.     {.       evalsolution(mydays2);.     }.   });.}.....my question is if this is actually an efficient use of parallel processing or will too many threads be spawned and slow it down? should the parallel loop only be done on the last or maybe last few values of eventnum or is there a better way to approach the problem?..requested old code pretty much is as follows:..private int daterange;.private int events;.private void scheduleit().{.  daterange = 10;.  events = 6;.  createsolutions();.  int best = getbest();.}.private datatable options();.private bool createsolutions().{.   options= new datatable();.   options.columns.add();..for (int day1=0;day1&lt;=daterange ;day1++).{.    options.rows.add(day1);.}..for (int event =1; event&lt;events; event++).{.    options.columns.add();..    foreach(datarow dr in options.rows).    {dr[options.columns.count-1] = dr[options.columns.count-2] ;}.    int rows = options.rows.count;.    for (int day1=1;day1&lt;=daterange ;day1++).    {..        for(int i = 0; i &lt;rows; i++).        {.            if(day1 &gt; convert.toint32(options.rows[i][options.columns.count-2])).            {.                try{.                options.rows.add();.                for (int col=0;col&lt;options.columns.count-1;col++).                    {..                        options.rows[options.rows.count-1][col] =options.rows[i][col];..                    }.                options.rows[options.rows.count-1][options.columns.count-1] = day1;..                }.                catch(exception ex).                {.                 return false;.                }.            }.        }.    }.}.return true;..}.private intgetbest().{.    int bestopt = 0;.    double bestscore =999999999;...    parallel.for(  0,  options.rows.count,opt =&gt; .    {..        double score = 0;..        for(int i = 0; i &lt;options.columns.count;i++).        {score += options.rows[opt][i]}// just a stand in calc for a score.        if (score &lt; bestscore).        {bestscore = score;.            bestopt = opt;.        }..    });. return bestopt;...     }"
