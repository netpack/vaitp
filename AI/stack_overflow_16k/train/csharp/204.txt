"blank dictionary large performance hit when key is struct i am writing a class that allows for two different indexes with the goal of o(1) lookup for each. both indexes are currently using dictionary as the underlying structure...internal class raycollection.{..  private readonly dictionary&lt;ulong, ray&gt; idlookup_;.  private readonly dictionary&lt;projectionkey, ray&gt; projectionlookup_;..  public raycollection().  {.    idlookup_ = new dictionary&lt;ulong, ray&gt;();.    projectionlookup_ = new dictionary&lt;projectionkey, ray&gt;();.  }..  public void add(ray ray).  {.    idlookup_.add(ray.id, ray);.    projectionlookup_.add(new projectionkey(ray.from, ray.to), ray);.  }..  public ray this[ulong id].  {.    get =&gt; idlookup_[id];.  }..  public ray this[ulong from, ulong to].  {.    get =&gt; projectionlookup_[new projectionkey(from, to) ];.  }..  internal struct projectionkey.  {.    ulong from;.    ulong to;..    public projectionkey(ulong from, ulong to).    {.      from = from;.      to = to;.    }.  }..}...this works as it should, but the performance hit from using a struct is enormous! indexing with projectionkey is almost 130x slower...           method |       mean |      error |     stddev |.----------------- |-----------:|-----------:|-----------:|.         getviaid |   5.823 ns |  0.1801 ns |  0.1769 ns |. getviaprojection | 646.951 ns | 12.4307 ns | 12.2086 ns |...a fair amount of this overhead is probably caused by having to create a new instance of projectionkey every time the index operator is called, and i presume more overhead is caused by dictionary having to hash the struct to perform the lookup. in either case, i would like to decrease this overhead as much as possible...so then, my questions are:...for this[ulong from, ulong to], is there a way i can implicitly treat from and to as a struct without having to allocate it? it seems silly to instantiate a new struct when the variables are adjacent to each other on the stack..is there a better way to approach this, considering a fair amount of overhead is likely being caused by dictionary hashing the struct...and one last thing: before any ""premature optimization"" or ""is this actually affecting your performance"" posts, yes, i do realize this. i use opportunities like these to better understand blank and .net from a low level perspective and believe extreme optimization cases like these provide good knowledge."
