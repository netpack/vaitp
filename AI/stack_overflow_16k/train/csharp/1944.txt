"why use ilist or list? i know there has been a lot of posts on this but it still confuses me why should you pass in an interface like ilist and return an interface like ilist back instead of the concrete list...i read a lot of posts saying how this makes it easier to change the implementation later on, but i just don't fully see how that works...say if i have this method..  public class someclass.    {.        public bool ischecked { get; set; }.    }.. public void logallchecked(ilist&lt;someclass&gt; someclasses).    {.        foreach (var s in someclasses).        {.            if (s.ischecked).            {.                // log .            }.        }.    }...i am not sure how using ilist will help me out in the future...how about if i am already in the method? should i still be using ilist?..public void logallchecked(ilist&lt;someclass&gt; someclasses).    {.        //why not list&lt;string&gt; mystrings = new list&lt;string&gt;().        ilist&lt;string&gt; mystrings = new list&lt;string&gt;();..        foreach (var s in someclasses).        {.            if (s.ischecked).            {.                mystrings.add(s.ischecked.tostring());.            }.        }.    }...what do i get for using ilist now?..public ilist&lt;int&gt; onlysomeints(ilist&lt;int&gt; myints).    {.        ilist&lt;int&gt; store = new list&lt;int&gt;();.        foreach (var i in myints).        {.            if (i % 2 == 0).            {.                store.add(i);.            }.        }..        return store;.    }...how about now? is there some new implementation of a list of int's that i will need to change out?..basically, i need to see some actual code examples of how using ilist would have solved some problem over just taking list into everything...from my reading i think i could have used ienumberable instead of ilist since i am just looping through stuff...edit.so i have been playing around with some of my methods on how to do this. i am still not sure about the return type(if i should make it more concrete or an interface)... public class cardfrmvm.    {.        public ilist&lt;travelfeaturesvm&gt; travelfeaturesvm { get; set; }.        public ilist&lt;warrantyfeaturesvm&gt; warrantyfeaturesvm { get; set; }..        public cardfrmvm().        {.            warrantyfeaturesvm = new list&lt;warrantyfeaturesvm&gt;();.            travelfeaturesvm = new list&lt;travelfeaturesvm&gt;();.        }.}.. public class warrantyfeaturesvm : availablefeaturevm.    {.    }.. public class travelfeaturesvm : availablefeaturevm.    {.    }.. public class availablefeaturevm.    {.        public guid featureid { get; set; }.        public bool hasfeature { get; set; }.        public string name { get; set; }.    }...        private ilist&lt;availablefeature&gt; fillavailablefeatures(ienumerable&lt;availablefeaturevm&gt; avaliablefeaturesvm).        {.            list&lt;availablefeature&gt; availablefeatures = new list&lt;availablefeature&gt;();.            foreach (var f in avaliablefeaturesvm).            {.                if (f.hasfeature).                {.                                                    // nhibernate call to load&lt;&gt;().                    availablefeature availablefeature = featureservice.loadavaliablefeaturebyid(f.featureid);.                    availablefeatures.add(availablefeature);.                }.            }..            return availablefeatures;.        }...now i am returning ilist for the simple fact that i will then add this to my domain model what has a property like this:..public virtual ilist&lt;availablefeature&gt; availablefeatures { get; set; }...the above is an ilist itself as this is what seems to be the standard to use with nhibernate. otherwise i might have returned ienumberable back but not sure. still, i can't figure out what the user would 100% need(that's where returning a concrete has an advantage over)...edit 2..i was also thinking what happens if i want to do pass by reference in my method?..private void fillavailablefeatures(ienumerable&lt;availablefeaturevm&gt; avaliablefeaturesvm, ilist&lt;availablefeature&gt; tofill).            {..                foreach (var f in avaliablefeaturesvm).                {.                    if (f.hasfeature).                    {.                                                        // nhibernate call to load&lt;&gt;().                        availablefeature availablefeature = featureservice.loadavaliablefeaturebyid(f.featureid);.                        tofill.add(availablefeature);.                    }.                }.            }...would i run into problems with this? since could they not pass in an array(that has a fixed size)? would it be better maybe for a concrete list?"
