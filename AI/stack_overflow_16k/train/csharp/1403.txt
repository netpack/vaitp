"httpclient sendasync deadlock i have a wrapper that creates a function .public async task getcachetoken created .for a few internal services/application to call..and i'm experiencing this exception (please see the following) by calling performextract() in another service...performextract is literally calling getcachetoken via api call..i can't help to send an async call inside the sync method (legacy environment), so every time when i call var results = client.sendasync(requestdata).result' in a loop it will cause deadlocks,.if i understand it correctly, sendasync inside for loop, it will wait for a task to be finished before starting another one, so it should not have an exception of the following (connection disposed?)..to fix it, i have to override send async configureawait(false) and it resolved my problem...my question is how adding configureawait(false) solve the problem?..to avoid this issue, you can use a method called configureawait with a false parameter. when you do, this tells the task that it can resume itself on any thread that is available instead of waiting for the thread that originally created it. this will speed up responses and avoid many deadlocks...and how running it async cause a deadlock? ..thanks so much for all your patient reading thru the post... protected override extractresultstatus performextract().        {.            //engagerestclient client = new engagerestclient(_apiendpoint);.            //client.authenticator = new ntlmauthenticator();.            servicepointmanager.securityprotocol = securityprotocoltype.tls | securityprotocoltype.tls11 | securityprotocoltype.tls12;.            try.            {.                var numerrors = 0;..                var dt = getinfos();.                var filename = string.format(filenamebase, datetime.now);.                if (dt.rows.count &gt; 0).                {.                    dt.columns.add(""failurereason"");.                    foreach (datarow row in dt.rows).                    {.                        var referenceid = row[""u3l_referenceid""].tostring();.                        var requestdata = new httprequestmessage.                        {.                            method = httpmethod.get,.                            requesturi = new uri(_apiendpoint + $""?referenceid={referenceid}""),.                        };..                        requestdata.headers.authorization = new authenticationheadervalue(""bearer"", _token);.                        var results = client.sendasync(requestdata).result;.                        var resultresponse = results.content.readasstringasync().result;.........    protected override async task&lt;httpresponsemessage&gt; sendasync(.        httprequestmessage request,.        cancellationtoken cancellationtoken).    {.        httpresponsemessage response = null;.        for (int i = 0; i &lt; maxretries; i++).        {.            response = await base.sendasync(request, cancellationtoken).configureawait(false);.            if (response.statuscode != httpstatuscode.internalservererror ||.                response.statuscode != httpstatuscode.notimplemented ||.                response.statuscode != httpstatuscode.gatewaytimeout ||.                response.statuscode != httpstatuscode.serviceunavailable).            {.                return response;.            }..            response.dispose();.        }..        return response;.    }....public async task&lt;string&gt; getcachetoken().        {.            objectcache cache = memorycache.default;.            string refreshtoken = cache.get(""refreshtoken"", null) == null ? gettoken() : cache.get(""refreshtoken"", null).tostring();..            if (!cache.contains(""apitoken"")).            {.                var httpcontent = new stringcontent("""", encoding.utf8, ""application/x-www-form-urlencoded"");.                var dict = new dictionary&lt;string, string&gt;();.                dict.add(""grant_type"", ""refresh_token"");.                dict.add(""refresh_token"", refreshtoken);.                var requestdata = new httprequestmessage.                {.                    method = httpmethod.post,.                    requesturi = new uri(""https://oauth2.sky.blackbaud.com/token""),.                    content = new formurlencodedcontent(dict).                };..                requestdata.headers.authorization = new authenticationheadervalue(""basic"", settings.basicauth);.                var results = await _client.sendasync(requestdata);.                var resultresponse = results.content.readasstringasync().result;..                try.                {.                    results.ensuresuccessstatuscode();.                    var result = _js.deserialize&lt;tokenmodel&gt;(resultresponse);.                    //token expires in one hour from blackbaud.                    var expiration = datetimeoffset.utcnow.addminutes(55);.                    cache.add(""apitoken"", result.access_token, expiration);.                    cache.add(""refreshtoken"", result.refresh_token, expiration);.                    updatetoken(result.access_token, result.refresh_token);.                }.                catch (exception e).                {.                    var exceptionmessage = $""resultmessage : {resultresponse} exception: {e}. message: {e.message}. stacktrace {e.stacktrace}"";.                    log.exception(e,exceptionmessage);.                    throw;.                }.            }..            return cache.get(""apitoken"", null).tostring();.        }....  {data: [], hresult: -2146233088, helplink: null, innerexception: null,.  message: ""response status code does not indicate success: 400 (bad.  request)."", source: ""system.net.http"", stacktrace: ""   at.  system.net.http.httpresponsemessage.ensuresuccessstatuscode()rn   at.  raisersedge.infrastructure.cache.d__2.movenext()rn---.  end of stack trace from previous location where exception was thrown.  ---rn   at system.runtime.exceptionservices.exceptiondispatchinfo.throw()rn.  at.  system.runtime.compilerservices.taskawaiter.handlenonsuccessanddebuggernotification(task.  task)rn   at.  raisersedge.controllers.basecontroller.d__6.movenext()rn---.  end of stack trace from previous location where exception was thrown.  ---rn   at system.runtime.exceptionservices.exceptiondispatchinfo.throw()rn.  at.  system.runtime.compilerservices.taskawaiter.handlenonsuccessanddebuggernotification(task.  task)rn   at.  system.threading.tasks.taskhelpersextensions.d__3`1.movenext()rn---.  end of stack trace from previous location where exception was thrown.  ---rn   at system.runtime.exceptionservices.exceptiondispatchinfo.throw()rn.  at.  system.runtime.compilerservices.taskawaiter.handlenonsuccessanddebuggernotification(task.  task)rn   at.  system.web.http.controllers.apicontrolleractioninvoker.d__0.movenext()rn---.  end of stack trace from previous location where exception was thrown.  ---rn   at system.runtime.exceptionservices.exceptiondispatchinfo.throw()rn.  at.  system.runtime.compilerservices.taskawaiter.handlenonsuccessanddebuggernotification(task.  task)rn   at.  system.web.http.controllers.actionfilterresult.d__2.movenext()rn---.  end of stack trace from previous location where exception was thrown.  ---rn   at system.runtime.exceptionservices.exceptiondispatchinfo.throw()rn.  at.  system.runtime.compilerservices.taskawaiter.handlenonsuccessanddebuggernotification(task.  task)rn   at.  system.web.http.dispatcher.httpcontrollerdispatcher.d__1.movenext()"",.  targetsite: ""system.net.http.httpresponsemessage.  ensuresuccessstatuscode()"", _typetag: ""httprequestexception""}"
