"equals/gethashcode contract violation for struct with decimal field i was reading through the following questions and their answers ---...why is valuetype.gethashcode() implemented like it is?.how does native implementation of valuetype.gethashcode work?...--- which basically indicate a naturally correct and usually efficient implementation of gethashcode for system.valuetype is not easy. an answer at one of the linked posts briefly indicates that gethashcode has a bug with respect to decimal fields of structs, e.g.:..struct test { public decimal value; }..static void main() {.    var d1 = 1.0m;.    var d2 = 1.00m; // numerically equal but has different bits.    var t1 = new test() { value = d1 };.    var t2 = new test() { value = d2 };.    console.writeline(equals(d1, d2)); // true.    console.writeline(d1.gethashcode() == d2.gethashcode()); // true.    console.writeline(equals(t1, t2)); // true.    console.writeline(t1.gethashcode() == t2.gethashcode()); // false!.}...for this decimal-containing struct, valuetype.gethashcode violates the equals/gethashcode relationship. to be clear, that's the following (a summary from msdn):...  two objects that are equal return hash codes that are equal....now, note the documentation of valuetype.equals (framework 4.5):...  if none of the fields of the current instance and obj are reference.  types, the equals method performs a byte-by-byte comparison of the two.  objects in memory....so this is evidently not true, which was also observed here...my (revised) question: is this a bug in equals or a bug in gethashcode? from what other posts are saying, it seems like the bug is in gethashcode, but msdn's possible documentation defect makes it very unclear."
