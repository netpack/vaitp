"ip address class getaddressbytes method putting octets in odd indices of the byte array i'm trying to create a program that stores ip addresses inside a hash table utilizing the ip address class that is built into blank. i start by using a textbox for the user to input the ip address into. my code then takes the text from the textbox, places it into a string variable, and then uses the ipaddress.parse method to verify/store it in the ip address data type...// variables.ipaddress address;.string userentry;..// grab the ip, verify it, and convert it to the ip address data type.userentry = textbox1.text;.address = ipaddress.parse(userentry);...i then have function that takes the ip address (by way of the ip address data type) and converts it into an array of bytes using the getaddressbytes method. following this, i use a for loop to cycle through the byte array and multiply the value of each index by 256 to the power of the place of place of the octet being looked at in descending order (i.e. the first octet looked at is multiplied by 256^3, the second by 256^2 etc...). i do this so that i can have a unique number for each ip address (converting the ip address to its integer form) that i will be able to feed into my hashing algorithm...        private uint32 convertip(ipaddress address) {.        byte[] bytes = address.getaddressbytes();.        int counter = 3;.        uint answer = 0;..        for (int i = 0; i &lt; bytes.length; i++) {..            messagebox.show(bytes[i].tostring());..            answer = answer + convert.touint32(bytes[i] * math.pow(256, counter));..            counter--;..        }..        return answer;.    }...i originally thought that this would work out quite well until i found out that i can enter partial ip addresses such as 255, 255.255, and 255.255.255. when using a break point to watch the different octets get added to the byte array, the octets seem to be added to the byte array in an odd order. when you just enter 255 the octet gets added to the 3rd spot in the array (fourth in reality, but labeled 3 because the array starts at zero), however, when you enter 255.255 the octets get placed in the 3rd spot and the 0 spot of the byte array and not in the 3rd and 2nd spots of the array as i would think. a picture of this is included below.....does anyone have any idea why the octets are being placed in the the byte array in such an odd order? is it something i'm doing wrong?"
