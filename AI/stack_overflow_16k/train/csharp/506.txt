"how to assign to referenced object i have two lists of object.. [serializable]. private class memoryset. {.    public dictionary&lt;string, object&gt; _map;.    public list&lt;object&gt; _results;.    public list&lt;object&gt; _storage;. }. memoryset memory = new memoryset();...i can have keys assigned for an object, for example..    _map.add(""somekey"", _results[_results.count - 1]);...i have a method..private object mapper(string key).{.    if (memory._map.containskey(key)).    {.        return memory._map[key];.    }.    else if (key.tolower() == ""result"").    {.        return memory._results[memory._results.count - 1];.    }.    else if (key.tolower() == ""storage"").    {.        return memory._storage[memory._storage.count - 1];.    }.    else if (key.tolower().contains(""result"")).    {.        int n = convert.toint32(key.tolower().split(new string[] { ""result"" }, stringsplitoptions.none)[1]);.        return memory._results[n];.    }.    else if (key.tolower().contains(""storage"")).    {.        int n = convert.toint32(key.tolower().split(new string[] { ""storage"" }, stringsplitoptions.none)[1]);.        return memory._storage[n];.    }.    else return null;.}...now i must assign to an object from _storage or _results like that:..object obj = key != """" ? mapper(key) : memory._storage[memory._storage.count - 1];.if(obj is string) obj as string = ""test"";...this will change obj to reference some new string in memory. but i want to change the object that obj references to instead...in other words obj will become ""test"", but the underlying object won't be changed...i understand why that happends, though i didn't imagine it that way when writing the whole engine, and now i have big trouble with that one. in c++ we have pointers, but in blank i don't want to use gchandles or unmanaged code for that trivial stuff, would be extremely ugly...so, how to assign to the object that object points to, instead assigning to the object itself?"
