"reversing galois multiplication of two byte arrays in blank i need help in finding the reverse of galois multiplication gf (2^128) in blank. the code below is being used in my aes-gcm functions. i found this code through the web though...i tried to search the web for galois division but i have no luck in finding it. ..pardon me for my knowledge in this field and my english. ..this function derives the value of 2^x...public byte bit(byte x).{.    return (byte)(1 &lt;&lt; x);.}...this function converts byte array of 4 elements to unsigned int...public uint wpa_get_be32(byte[] a).{.    return (uint)((a[0] &lt;&lt; 24 )|( a[1] &lt;&lt;16 )|( a[2] &lt;&lt; 8 )| a[3]);.}...this function converts unsigned int into byte array of 4 elements...public void wpa_put_be32(out byte[] a, uint val).{.    a = new byte[4];.    a[0] = (byte)((val &gt;&gt; 24) &amp; 0xff);.    a[1] = (byte)((val &gt;&gt; 16) &amp; 0xff);.    a[2] = (byte)((val &gt;&gt; 8) &amp; 0xff);.    a[3] = (byte)(val &amp; 0xff);.}..public void shift_right_block(ref byte[] v).{.    uint val;..    byte[] temp = new byte[4];..    temp = v.skip(12).take(4).toarray();.    val = wpa_get_be32(temp);.    val &gt;&gt;= 1;.    if ((v[11] &amp; 0x01) &gt; 0) val |= 0x80000000;.    wpa_put_be32(out temp, val);.    array.copy(temp, 0, v, 12, 4);..    temp = v.skip(8).take(4).toarray();.    val = wpa_get_be32(temp);.    val &gt;&gt;= 1;.    if ((v[7] &amp; 0x01) &gt; 0) val |= 0x80000000;.    wpa_put_be32(out temp, val);.    array.copy(temp, 0, v, 8, 4);..    temp = v.skip(4).take(4).toarray();.    val = wpa_get_be32(temp);.    val &gt;&gt;= 1;.    if ((v[3] &amp; 0x01) &gt; 0) val |= 0x80000000;.    wpa_put_be32(out temp, val);.    array.copy(temp, 0, v, 4, 4);..    temp = v.skip(0).take(4).toarray();.    val = wpa_get_be32(temp);.    val &gt;&gt;= 1;.    wpa_put_be32(out temp, val);.    array.copy(temp, 0, v, 0, 4);.}...this function does a exclusive-or function on two byte arrays...public void c_xor_16(ref byte[] dest, byte[] src).{.    int ndx = 0;.    for (ndx = 0; ndx &lt; 16; ndx++) dest[ndx] ^= src[ndx];.}...this is the main function and byte array z is the output of the gf multiplication...public void c_gf_mult(byte[] x, byte[] y, ref byte[] z).{.    int i, j;.    byte[] v = new byte[16];..    z = new byte[16];.    array.clear(z, 0, 16);.    array.copy(y, v, 16);..    for (i = 0; i &lt; 16; i++).    {.        for (j = 0; j &lt; 8; j++).        {.             if ((byte)(x[i] &amp; bit((byte)(7 - j))) &gt; 0).            {.                c_xor_16(ref z, v);.            }..            if ((byte)(v[15] &amp; 0x01) &gt; 0).            {.                shift_right_block(ref v);.                v[0] ^= 0xe1;.            }.            else.            {.                shift_right_block(ref v);.            }.        }.    }.    return;.}"
