"executorservice and runnable i have a list containing data to compute for each pixel (e.g. list size = 1024x768). now i want to iterate multithreaded through the list and save the computation for each pixel in a hashmap. but whatever i do, i can't manage to make it right. i tried several ways, my last was this one:..        concurrentmap&lt;t, color&gt; map = new concurrenthashmap&lt;t, color&gt;();..        executorservice pool = executors.newfixedthreadpool(4);..        iterator&lt;t&gt; it = camera.iterator();.        while (it.hasnext()) {.            runnable run = () -&gt; {.                int i = 0;.                while (it.hasnext() &amp;&amp; i &lt; 1000) {.                    i++;.                    t cameraray = it.next();.                    if (object.collide(cameraray.getray()) == null).                        map.put(cameraray, bg_color);.                    else.                        map.put(cameraray, this.shader.shade(cameraray.getray(), object.collide(cameraray.getray())).getcolor());.                }.            };.            pool.execute(run);.        }.        pool.shutdown();.        try {.            if (pool.awaittermination(long.max_value, timeunit.nanoseconds)) {.                system.out.println(""mapsize: "" + map.size());.                // draw image:.                map.foreach((ray, color) -&gt; {image.setcolor(ray, color);});.            }.        } catch (interruptedexception e) {.            e.printstacktrace();.        }...note thet the iterators hasnext() method is synchronized..the problem is sometimes a heap problem or simply that the size of the hashmap is less than the list size...i guess that i didn't understand something correct concering runnables or the executorservice...i appreciate any help here...edit:.i added a system.out.println(i) just before the i++ statement. despite of checking for i &lt; 1000 at some point suddenly there appears the following:..507.169.86624.625.626.exception in thread ""pool-2-thread-2"" blank.lang.outofmemoryerror: blank heap space.exception in thread ""pool-2-thread-3"" blank.lang.reflect.invocationtargetexception.    at sun.reflect.nativemethodaccessorimpl.invoke0(native method).    at sun.reflect.nativemethodaccessorimpl.invoke(unknown source).    at sun.reflect.delegatingmethodaccessorimpl.invoke(unknown source).    at blank.lang.reflect.method.invoke(unknown source).    at com.sun.blankfx.application.launcherimpl.launchapplicationwithargs(unknown source).    at com.sun.blankfx.application.launcherimpl.launchapplication(unknown source).    at sun.reflect.nativemethodaccessorimpl.invoke0(native method).    at sun.reflect.nativemethodaccessorimpl.invoke(unknown source).    at sun.reflect.delegatingmethodaccessorimpl.invoke(unknown source).    at blank.lang.reflect.method.invoke(unknown source).    at sun.launcher.launcherhelper$fxhelper.main(unknown source).caused by: blank.lang.outofmemoryerror: blank heap space.    at blank.util.concurrent.threadpoolexecutor.addworker(unknown source).    at blank.util.concurrent.threadpoolexecutor.execute(unknown source).    at raytracer.impl.parallelrenderer.render(parallelrenderer.blank:78).    at raytracer.imageviewer.main(imageviewer.blank:118).    ... 11 more.exception in thread ""pool-2-thread-4"" blank.lang.outofmemoryerror: blank heap space.blank.lang.outofmemoryerror: blank heap space.    at raytracer.impl.triangleimpl.collide(triangleimpl.blank:87).    at raytracer.impl.simplescene.collide(simplescene.blank:27).    at raytracer.impl.parallelrenderer.lambda$0(parallelrenderer.blank:71).    at raytracer.impl.parallelrenderer$$lambda$48/24559708.run(unknown source).    at blank.util.concurrent.threadpoolexecutor.runworker(unknown source).    at blank.util.concurrent.threadpoolexecutor$worker.run(unknown source).    at blank.lang.thread.run(unknown source)...edit 2:.according to the answer of warkst, i tried the following..iterator&lt;t&gt; it = camera.iterator();.list&lt;t&gt; buffer = new arraylist&lt;t&gt;(1000);.while (it.hasnext()) {.    buffer.add(it.next());.    if (buffer.size() &gt;= 1000 || !it.hasnext()) {.        runnable run = () -&gt; {.            for (t cameraray : buffer) {.                if (object.collide(cameraray.getray()) == null) // no collision.                    map.put(cameraray, bg_color);.                else.                    map.put(cameraray, this.shader.shade(cameraray.getray(), object.collide(cameraray.getray())).getcolor());.            }.        };.        pool.execute(run);.        buffer.clear();.    }.}...but the very strange is, that the runnable block is never entered now, why?"
