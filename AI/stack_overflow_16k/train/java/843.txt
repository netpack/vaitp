"hashmap iteration behavior in case of mutable objects as keys i created an employee class and overridden the hashcode and equals methods. now i use this class as key in hashmap creation. until the keys are not modified everything works fine, but as soon as i start playing with keys and try to view the hashmap contents, its output confuses me. when i iterate the hashmap, it retains the key which was already overridden by myself in earlier steps. so e1, e2 and e3 are 3 key objects. i modify e1 to point to new fresh object(name=hrithik, id=123) and thus map.get method returns null which is fine. now i assign e2(name=sachin,id=456) to e1 and thus e1's old content should be lost(name=sachin,id=123). now problem starts here. when i iterate the hashmap, i see the e1 key contents still pointing to old reference(name=sachin,id=123) instead of (name=sachin,id=456). what is the reason behind it?..employee class..package hashmapconfusion;..public class employee {..    public string getname() {.        return name;.    }..    public void setname(string name) {.        this.name = name;.    }..    public int getempid() {.        return empid;.    }..    public void setempid(int empid) {.        this.empid = empid;.    }..    private string name;.    private int empid;..    employee(string name, int empid){.        this.name = name;.        this.empid = empid;.    }..    @override.    public int hashcode() {.        return 31*(name.length())*(name.charat(0));.    }..    @override.    public boolean equals(object o) {.        if(!(o instanceof employee)) {.            return false;.        }else {.            employee an = (employee) o;.            if(this.name.equals(an.name) &amp;&amp; this.empid==an.empid) {.                return true;.            }.        }.        return false;.    }.}...test class for hashmap..package hashmapconfusion;..import blank.util.hashmap;.import blank.util.map;.import blank.util.map.entry;..public class addemployeehashmap {..    public static void main(string[] args) {..        map&lt;employee, string&gt; map = new hashmap&lt;employee, string&gt;();.        employee e1 = new employee(""sachin"",123);.        employee e2 = new employee(""sachin"",456);.        employee e3 = new employee(""sachin"",456);.        map.put(e1, ""lo"");.        map.put(e2, ""lo another"");.        map.put(e3, ""lo another another"");.        /*map.put(e2, ""value"");.        map.put(e3, ""value3"");*/.        /*e3 = new employee(""sachin"",456);*/.        system.out.println(map.get(e1));.        e1= new employee(""hrithik"",123);.        system.out.println(map.get(e1));.        e1=e2;.        system.out.println(""value 1""+map.get(e1));.        system.out.println(""value 2""+map.get(e2));.        for(map.entry&lt;employee, string&gt; obj:map.entryset()) {.            system.out.println(""after one key change"");.            system.out.println(obj.getkey()+""=""+obj.getvalue());.        }.        for(employee obj:map.keyset()) {.            system.out.println(""key values"");.            system.out.println(obj.getname()+""=""+obj.getempid());.        }.        e2.setempid(300);.        system.out.println(""size after change both keys-""+map.size());.        for(entry&lt;employee, string&gt; obj:map.entryset()) {.            system.out.println();.            system.out.println(obj.getkey()+""=""+obj.getvalue());.        }.        system.out.println(map.size());.        /*map.foreach((key, val)-&gt;{.            employee e4 = new employee(""sachin"",456);.            system.out.println(val+""-"");.            if(key.equals(e4)).                system.out.println(""found val-""+val);.        });*/..    }..}...and the output..lo.null.value 1lo another another.value 2lo another another.after one key change.//why does it print lo when key has already been changed from e1 to e2.hashmapconfusion.employee@538e=lo.after one key change.hashmapconfusion.employee@538e=lo another another.key values.//why it is spitting the old key values which are way back overrridden.sachin=123.key values.sachin=456.size after change both keys-2.hashmapconfusion.employee@538e=lo.hashmapconfusion.employee@538e=lo another another.2"
