"swaping 2-d array rows? i'm new to programming and one of my assignments is to transform an image in blank. this part specifically says ""calling mirror reverses the image top to bottom. to reverse top to bottom, exchange the first row for the last row, the second row for the second to last row, and so on until the entire image is reversed."" ..this is what i currently have, but whenever i call mirror it simply transforms the image into a bunch of indistinguishable lines. i'm lost on how to approach this!....public void mirror(){..  int [][] imagedata = data;.  int i;.        int j;.        .        for (i=0; i &lt; height; i++).        {.         for(j=0; j &lt; width; j++).            { .         int temp = imagedata[i][i-0];.              imagedata[i][i-0] = imagedata[i-0][i];.              imagedata[i-0][i] = temp;.              imagedata[i][j] = temp;.        .         }.        }.        }.....the other parts that i'm not supposed to modify are and were given are....import blank.io.file;.import blank.io.fileoutputstream;.import blank.io.ioexception;.import blank.io.printstream;.import blank.util.scanner;..public class picturelibrary {.    .    // maximum intensity.    public static final int maxval = 255;..    // image data.    private int[][] image;..    // get image height.    public int getheight() {.        return image.length;.    }..    // get image width.    public int getwidth() {.        return image[0].length;.    }..    // get image data.    public int[][] getdata() {.        return image;.    }.    .    // set image data.    public void setdata(int[][] data) {.        image = data;.    }..    // read pgm file.    public void readpgm(string path) throws exception {..        int width;.        int height;.        int maxval;.        try {.            scanner in = new scanner(new file(path));.            string magic = in.next();.            if (!magic.equals(""p2"")) {.                in.close();.                throw new exception(""error: cannot read .pgm file "" + path);.            }.            width  = in.nextint();.            height = in.nextint();.            maxval = in.nextint();.            image = new int[height][width];.            for (int y = 0; y &lt; height; y++).                for (int x = 0; x &lt; width; x++).                    image[y][x] = in.nextint();.            in.close();.        } catch (ioexception e) {.            throw new exception(""error: cannot read .pgm file "" + path);.        }..        // scale values to the range 0-maxval.        if (maxval != maxval).            for (int j = 0; j &lt; height; j++).                for (int i = 0; i &lt; width; i++).                    image[j][i] = (image[j][i] * maxval) / maxval;..        return;.    }..    // write pgm file.    public void writepgm(string path) throws exception {.        .        int height = getheight();.        int width  = getwidth();.        try {.            printstream output = new printstream(new fileoutputstream(path));.            output.println(""p2"");.            output.println(width + "" "" + height);.            output.println(maxval);.            for (int row = 0; row &lt; height; row++).                for (int col = 0; col &lt; width; col++).                    output.println(image[row][col]); // one pixel per line!.            output.close();.        } catch (ioexception e) {.            throw new exception(""error: cannot write .pgm file "" + path);.        }.    }.}.......import blank.awt.*;.import blank.awt.event.*;.import blank.awt.image.*;.import blank.io.*;.import blankx.swing.*;..public class imageprogram extends jframe implements actionlistener.{.    private static final long serialversionuid = 1l; // get rid of warning..    // program flags.    private boolean   misinitialized; // gui initialized?.    private boolean   misdirty;       // image modified?..    // menu items.    private jmenuitem mopenfile;.    private jmenuitem msavefile;.    private jmenuitem mexitcommand;.    .    private jmenuitem mdecode;.    private jmenuitem mswap;.    private jmenuitem mmirror; .    private jmenuitem mexchange;.    private jlabel    mlabel;.    .    // transforms object from student.    private imageinterface mstudent;..    // array and static code are used to convert a gray scale to rgb.    private static int[] pgm2rgb;.    static {.        pgm2rgb = new int[256];..        for (int i = 0; i &lt; 256; i++) {.            pgm2rgb[i] = (255 &lt;&lt; 24) | (i &lt;&lt; 16) | (i &lt;&lt; 8) | i;.        }.    }..    // constructor. note that very little initialization is done here..    // since a derived class may override some of the initialization methods.    // these methods should not be called from a constructor because routines.    // in the derived class could be executed before the constructor of the super.    // class completes. in general, all code in the super class constructor.    // should be executed before any code in the derived class is executed..    public imageprogram () {.        super();.        setsize(new dimension(400, 300));.    }..    // satisfy the actionlistener interface. most of the work is delegated to.    // the method doaction(). this allows a derived class to override doaction.    // (instead of actionperformed()) and take advantage of the error handling.    // done here. if a derived class overrides actionperformed() in may need.    // to duplicate the error handling..    public void actionperformed (actionevent actionevent) {.        try {.            doaction(actionevent);.        }.        catch (throwable t) {.            t.printstacktrace();.        }.    }..    // this can throw exceptions, because they are caught by performaction().    // if you derive your own class from this class, and add new menus.    // or menu items, you would override this method to handle your new.    // menu items and delegate the work back to this method if the ""action"".    // is not one of those you defined in your derived class. there are many.    // ways to dispatch from an event to the underlying code. this illustrates.    // one simple way of doing that..    protected void doaction (actionevent actionevent) throws exception {..        object src = actionevent.getsource();.        if      (src == mopenfile)      openfile();.        else if (src == msavefile)      savefile();.        else if (src == mexitcommand)   exitgui();.        else if (src == mdecode)     decode();.        else if (src == mswap)    swap();.        else if (src == mmirror)     mirror();.        else if (src == mexchange)  exchange();.        .    }..    // override setvisible() to initialize everything the first time the.    // component becomes visible.    public void setvisible (boolean visible) {.        if (visible) {.            if (! misinitialized) {.                startgui();.                misinitialized = true;.            }.        }.        super.setvisible(visible);.    }..    // build the gui..    protected void startgui() {.        setjmenubar(makemenubar());..        addwindowlistener(new windowadapter() {.            public void windowclosing (windowevent we) {.                mexitcommand.doclick(); // press the exit menu item.            }.        });..        getcontentpane().add(makemainpanel());.    }..    // exit the gui.    private void exitgui() {.        if (misdirty) {.            if (!getyesno(""data has not been saved."", ""continue?"")).                return;.        }.        system.exit(0);.    }...    // creates the main panel of the gui.    protected jpanel makemainpanel() {.        jpanel panel = new jpanel(new borderlayout());.        mlabel = new jlabel();.        panel.add(mlabel, borderlayout.center);..        return panel;.    }..    // created the menu bar for the gui. delegates most of the work to.    // methods which create the individual menus. the ""adds"" should remind you.    // of your work with arraylists. a jmenubar is conceptually just a list of.    // menus. you will find methods on a jmenubar to manipulate the elements.    // of the list..    protected jmenubar makemenubar() {.        jmenubar mb = new jmenubar();.        mb.add(makefilemenu());.        mb.add(makeactionmenu());.        return mb;.    }..    // create the file menu. again, the ""adds"" (see makemeniitem)should remind you.    // of list manipulation. a jmenu is conceptually a list of jmenuitems..    // interestingly, a jmenu is a jmenuitem. why do you think that is??.    protected jmenu makefilemenu() {.        jmenu menu  = makemenu(""file"", 'f');.        mopenfile     = makemenuitem(menu, ""open..."", 'o');.        msavefile     = makemenuitem(menu, ""save..."", 's');.        mexitcommand  = makemenuitem(menu, ""exit"", 'x');.        return menu;.    }..    // create the action menu..    protected jmenu makeactionmenu() {.        jmenu menu  = makemenu(""action"", 'a');.        mdecode     = makemenuitem(menu, ""decode""     , 'd');.        mswap  = makemenuitem(menu, ""swap""       , 's');.        mmirror     = makemenuitem(menu, ""mirror""     , 'm');.        mexchange   = makemenuitem(menu, ""exchange""   , 'e');.        return menu;.    }..    // convenience method for making jmenu.    protected jmenu makemenu (string name, char mnemonic) {.        jmenu menu = new jmenu(name);.        menu.setmnemonic(mnemonic);.        return menu;.    }..    // convenience method for making jmenuitem.    protected jmenuitem makemenuitem (string name, char mnemonic) {.        jmenuitem mi = new jmenuitem(name, (int) mnemonic);.        mi.addactionlistener(this);.        return mi;.    }..    // convenience method for putting jmenuitem in a menu.    protected jmenuitem makemenuitem (jmenu menu, string name, char mnemonic) {.        jmenuitem mi = makemenuitem(name, mnemonic);.        menu.add(mi);.        return mi;.    }..    // convenience method to get yes/no from user.    protected boolean getyesno (string title, string message) {.        int answer = joptionpane.showinternalconfirmdialog(getcontentpane(),.                message,.                title,.                joptionpane.yes_no_option,.                joptionpane.warning_message);..        return (answer == joptionpane.yes_option);.    }..    // open image file.    private void openfile() throws exception {..        // data saved?.        if (misdirty) {.            if (!getyesno(""open file"", ""data has not been saved. continue?"")).                return;.        }..        string filename = selectfile(""select file to open"", true);..        if (filename != null) {.            mstudent = new transforms();.            mstudent.readimage(filename);.            resetimage();.            misdirty = false;.        }.    }..    // save image file.    private void savefile() throws exception {.        string filename = selectfile(""select file name to save"", false);..        if (filename != null) {.            mstudent.writeimage(filename);.            misdirty = false;.        }.    }..    // other student methods.    private void decode() {.        if (mstudent != null) {.            mstudent.decode();.            resetimage();.        }.    }..    private void swap() {.        if (mstudent != null) {.            mstudent.swap();.            resetimage();.        }.    }..    private void mirror() {.        if (mstudent != null) {.            mstudent.mirror();.            resetimage();.        }.    }.    .    private void exchange() {.        if (mstudent != null) {.            mstudent.exchange();.            resetimage();.        }.    }..    // file selector.    private string selectfile (string title, boolean open) {.        string filename = null;..        jfilechooser jfc = new jfilechooser();.        jfc.setcurrentdirectory(new file("".""));.        jfc.setdialogtitle(title);..        int result;.        if (open).            result = jfc.showopendialog(this);.        else.            result = jfc.showsavedialog(this);..        if (result == jfilechooser.approve_option) {.            file file = jfc.getselectedfile();.            filename = file.getabsolutepath();.        }..        return filename;.    }..    // reset image.    private void resetimage() {.        if (mstudent != null) {..            // copy the pixel values.            int image[][] = mstudent.imagedata();.            int rows = image.length;.            int cols = image[0].length;.            bufferedimage buffer = new bufferedimage(cols, rows, bufferedimage.type_int_argb);...            for (int row = 0; row &lt; rows; row++) {.                for (int col=0; col &lt; cols; col++) {.                    int rgb = pgm2rgb[image[row][col]];.                    buffer.setrgb(col, row, rgb);.                }.            }..            imageicon imageicon = new imageicon(buffer);.            mlabel.seticon(imageicon);.            misdirty = true;.            pack(); // make window just fit image.        }.    }..    // main program.    public static void main (string[] args) throws ioexception {.        imageprogram gui = new imageprogram();.        gui.setvisible(true);.    }.}.......public interface imageinterface {.. // read the image. public void readimage(string infile);.. // write the image. public void writeimage(string outfile);.. // get image data. public int[][] imagedata();.. // decode the pixels. public void decode();.. // swap the nibbles in each pixel. public void swap();.. // mirror the image corner to corner. public void mirror();. . // exchange two rectangles in image. public void exchange();.}"
