"using dynamic ""time"" value check out my app on google play: ...  code has been updated to use suggestions given by answer, however, still running into some problems......i am using a broadcast receiver within a service to get metadata from spotify (an external application). however, spotify is unique in the fact that it sends the following intent-actions:...metadatachanged which contains the song's artist, track, length, etc..playbackstatechanged which contains a boolean value for ""playing"" and an integer value for the current position in the song....however, i have been running into some problems. i have written the following code:..public class backgroundservice extends service {..audiomanager am;.int positioninms;.double eps = 5000;..string trackid = null;.string lasttrackid = null;.int lastplaytime = 0;.int addseconds = 0;.int tracklengthinsec = 0;.boolean playing = false;.boolean timerstarted = false;..void starttimer(){.    timerstarted = true;.    new timer(true).scheduleatfixedrate(.            new timertask() {.                @override.                public void run() {.                    if(playing) {.                        if(lasttrackid == null) {..                            lasttrackid = trackid;..                        }else if (!lasttrackid.equals(trackid)) {..                            addseconds = 1;.                            playing = true;.                            lastplaytime = positioninms;.                            // track changed. reset counter...                        }else{..                            addseconds++; // increment counter...                        }..                        checkmutestatus(tracklengthinsec, lastplaytime + addseconds * 1000 // multiply by 1000 as we're counting in seconds.                        );.                    }..                    log.e(""-------:"", ""last play time: "" + string.valueof(lastplaytime));.                    log.e(""-------:"", ""track length: "" + string.valueof(tracklengthinsec));.                    log.e(""-------:"", ""current position: "" + string.valueof(lastplaytime + addseconds * 1000));..                }.            },.            1000, // wait a second before first run.            1000 // runs every second.    );.}..@override.public void oncreate() {.    super.oncreate();..    am = (audiomanager)getsystemservice(context.audio_service);..    intentfilter filter;.    filter = new intentfilter();.    filter.addaction(""com.spotify.music.playbackstatechanged"");.    filter.addaction(""com.spotify.music.metadatachanged"");.    filter.addaction(""com.spotify.music.queuechanged"");..    notification notification = new notification();.    startforeground(1, notification);.    registerreceiver(receiver, filter);..}..@override.public int onstartcommand(intent intent, int flags, int startid) {..    return super.onstartcommand(intent, flags, startid);.}..private final broadcastreceiver receiver = new broadcastreceiver() {.    @override.    public void onreceive(context context, intent intent) throws nullpointerexception {..        long timesentinms = intent.getlongextra(""timesent"", 0l);..        string action = intent.getaction();..        if (action.equals(broadcasttypes.metadata_changed)) {..            trackid = intent.getstringextra(""id"");.            string artistname = intent.getstringextra(""artist"");.            string albumname = intent.getstringextra(""album"");.            string trackname = intent.getstringextra(""track"");.            tracklengthinsec = intent.getintextra(""length"", 0);..            log.e(""status:"", trackname);.            log.e(""status:"", artistname);.            log.e(""status:"", albumname);.            log.e(""status:"", ""track length: "" + string.valueof(tracklengthinsec));.            log.e(""status:"", trackid);..            log.e(""status:"", ""position: "" + string.valueof(positioninms));..            if(!timerstarted) {..                starttimer();..            }.....            //---------------------- if paused or song changed---------------------..        } else if (action.equals(broadcasttypes.playback_state_changed)) {..            playing = intent.getbooleanextra(""playing"", false);.            positioninms = intent.getintextra(""playbackposition"", 0);..            lastplaytime = positioninms;.            addseconds = 0; // reset counter as we've now got the current position...            if(!timerstarted) {..                starttimer();..            }..        }..    }..};..    void checkmutestatus(double tracklength, double currenttime) {..        if (math.abs(tracklength - currenttime) &lt; eps) {..            mute(am);.            log.e(""status:"", ""muted"");.            addseconds = 0;.            lastplaytime = 0;...        } else {..            unmute(am);.            log.e(""status:"", ""not muted"");...        }..    }.....@override.public void ondestroy() {.    super.ondestroy();..    log.e(""status:"", ""in ondestroy"");..    unregisterreceiver(receiver);.}..@nullable.@override.public ibinder onbind(intent intent) {.    return null;.}...static final class broadcasttypes {.    static final string spotify_package = ""com.spotify.music"";.    static final string playback_state_changed = spotify_package + "".playbackstatechanged"";.    static final string metadata_changed = spotify_package + "".metadatachanged"";.}..public void mute(audiomanager audiomanager){..    audiomanager.setstreammute(audiomanager.stream_system, true);.    audiomanager.setstreammute(audiomanager.stream_notification, true);.    audiomanager.setstreammute(audiomanager.stream_alarm, true);.    audiomanager.setstreammute(audiomanager.stream_music, true);.    audiomanager.setstreammute(audiomanager.stream_ring, true);..}..public void unmute(audiomanager audiomanager){..    audiomanager.setstreammute(audiomanager.stream_system,false);.    audiomanager.setstreammute(audiomanager.stream_notification, false);.    audiomanager.setstreammute(audiomanager.stream_alarm, false);.    audiomanager.setstreammute(audiomanager.stream_music, false);.    audiomanager.setstreammute(audiomanager.stream_ring, false);..}...}...which all works perfectly in getting the data, etc. ..essentially i am attempting to mute a user's phone when the length of the song subtracted from the current playback time in the song is less than a certain number. this basically allows me to have the device muted when an ad is playing, and unmuted when a new song is started. the only problem i consistently come across is that i can only access the current position in the song when the play state is changed. this essentially means that in order for my app to check whether it should mute the device, spotify must first be paused so that the current playback time is updated...so my question is, how can i keep my current playback time up-to-date so that my muting functionality is able to work? is there a way i can implement a ""timer"" of sorts which kicks in after i receive a value for the current playback time and then increments the time until next update?"
