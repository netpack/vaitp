"docx password verifier i've a small programme in blank that should verify a password but seems to be coming up short. if anyone here has any experience with offcrypto the help would be greatly appreciated...my main class is as follows. ..import blank.util.arrays;.import blank.util.logging.level;.import blank.util.logging.logger;.import blank.util.base64;.import blank.lang.reflect.field;..import blank.io.bufferedwriter;.import blank.io.file;.import blank.io.filewriter;.import blank.io.ioexception;  .import blank.io.*;..import blank.security.messagedigest;.import blank.security.digestexception;.import blank.security.generalsecurityexception;.import blank.security.key;..import blankx.crypto.cipher;.import blankx.crypto.spec.secretkeyspec;..import org.apache.poi.poifs.crypt.*;.import org.apache.poi.util.stringutil;.import org.apache.poi.util.littleendianconsts;.import org.apache.poi.encrypteddocumentexception;.import org.apache.poi.poifs.crypt.cipheralgorithm;..import blank.util.base64;..public class keygen.{.    public static void main(string args[]).    {.        /**********************************************************************.        *.        *       variables are extracted from docx in base64 format.        *.        *       then manually transformed to hex then byte array as per jtr.        *.        ***********************************************************************/.        string salt = ""gqjkqh6pdkplzlsvxznk/q=="";//initial values retrieved from word doc.        string hashinput =""jjyuf6daqql81tleovnr0w=="";.        string hashvalue=""vzuku9tikomd2hyof+qq1e9wjmgapvujuaauptyhxbtvpvvg4tfhbyg2vdjjfxo8v73dlacwesdqyllrd8/y3a=="";//this was truncated in jtr but will only work at full length here..        string hexsalt=""82a264407ea974a3cbccb4af5f3364fd"";.        string hexhashinput=""8e3cae7fa0daaaa2fcd532c4a2f9ebd3"";.        string hexhashvalue = ""559524bbdb4890e31dd87ca817e42ad44f708e681a3efba351a6aea6d607c5bb"";..        hex h = new hex();..        //hexsalt = h.hextoascii(hexsalt);.        //hexhashinput = h.hextoascii(hexhashinput);.        //hexhashvalue = h.hextoascii(hexhashvalue);..        int spincount = 100000;//loop count.        int blocksize = 16;.        int keysize = 32;//size in bytes = 256 bits.        string password = ""abc"";.        byte[] blockkeyinput = {(byte)0xfe,(byte)0xa7,(byte)0xd2,(byte)0x76,(byte)0x3b,(byte)0x4b,(byte)0x9e,(byte)0x79};//block key for input given by microsoft.        byte[] blockkeyvalue = {(byte)0xd7,(byte)0xaa,(byte)0x0f,(byte)0x6d,(byte)0x30,(byte)0x61,(byte)0x34,(byte)0x4e};//block key for value given by microsoft..        byte[] decodedvaluein = base64.getdecoder().decode(hashinput);//decode base64 values to byte array.        byte[] decodedvalueval = base64.getdecoder().decode(hashvalue);.        byte[] decodedsalt = base64.getdecoder().decode(salt);..        //decodedvalueval = hexhashvalue.getbytes();.        //decodedvaluein = hexhashinput.getbytes();.        //decodedsalt = hexsalt.getbytes();..        sha512 sha = new sha512();//create sha object..        /**********************************************************************.        *.        *       variables used in cryptofunctions class parameters.        *.        ***********************************************************************/..        hashalgorithm ha = hashalgorithm.sha512;//define hash algorithm.        cipheralgorithm ca = cipheralgorithm.aes256;//define encryption algorithm.        chainingmode cm = chainingmode.cbc;//define chaining mode.        int ciphermode = 0;//unused as cryptofunctions class code changed.        boolean iteratorfirst = true;//order of i (i+hash)..        cryptofunctions cf = new cryptofunctions();//call class instead of using library (for troubleshooting)..        byte[] hash = cf.hashpassword(password,ha,decodedsalt,spincount,iteratorfirst);//get hash from loop..        /**********************************************************************.        *.        *   generate an iv (initialization vector) for each key generated.        *.        ***********************************************************************/...        byte[] ivin = cf.generateiv(ha,decodedsalt,blockkeyinput,blocksize);//get iv from salt+blockkey.        byte[] ivval = cf.generateiv(ha,decodedsalt,blockkeyvalue,blocksize);..        /**********************************************************************.        *.        *       generate final byte arrays which are part of the key.        *.        ***********************************************************************/    ..        byte[] valuekey = cf.generatekey(hash,ha,blockkeyvalue,keysize);.        byte[] inputkey = cf.generatekey(hash,ha,blockkeyinput,keysize);//as above.        secretkeyspec inkey = new secretkeyspec(inputkey,""aes"");//generate key for cipher parameter.        secretkeyspec valkey = new secretkeyspec(valuekey,""aes"");//generate second key..        cipher cipherv = cf.getcipher(valkey,ca,cm,ivval,ciphermode);//get cipher from combined values.        cipher cipheri = cf.getcipher(inkey,ca,cm,ivin,ciphermode);..        /**********************************************************************.        *.        *       final step decrypt two values then hash input.        *.        ***********************************************************************/..        byte[] decryptedin = {};//initialize byte arrays outside try/catch.        byte[] decryptedval = {};.        byte[] hashedbytesin = {};..        try.        {.            decryptedin = cipheri.dofinal(decodedvaluein);//do final decrypts using aes256+key.            decryptedval = cipherv.dofinal(decodedvalueval);.            hashedbytesin = sha.hashbytes(decryptedin);//input must be hashed again.        }.        catch(exception ex){}..        /**********************************************************************.        *.        *       compare arrays to retrieve candidate key result.        *.        ***********************************************************************/..        boolean result = arrays.equals(hashedbytesin,decryptedval);..        if(result)//check for matching values.        {.            system.out.println(""success!"");.        }.        else.        {.            system.out.println("""");.            system.out.println(""fail!"");.            system.out.println("""");.        }.        system.out.println(""decryptedval""+arrays.tostring(decryptedval));.        system.out.println("""");.        system.out.println(""hashedbytesin""+arrays.tostring(hashedbytesin));     .    }..}..    /****************************************possible errors********************************************.    *.    *           no padding found in docx so field is empty in cryptofunctinos.getcipher().    *.    *           secret key is used in cf but in this class its secretkeyspec, can't instantiate secretkey.    *.    ****************************************************************************************************/...the encryptedverifierhashinput and encryptedverifierhashvalue are both stored in the encrypted document, i've just hard coded them for the time being. these are both decoded, then decrypted using the derived key and the input value is hashed again. they should both match to confirm the password. unfortunately they do not...i thought i had it cracked but there's a problem in there somewhere and i'm hoping someone here might spot it...the cryptofunctions class is from the library here...http://source.dussan.org/raw/mirrors/poi.git/trunk/src/blank/org/apache/poi/poifs/crypt/"
