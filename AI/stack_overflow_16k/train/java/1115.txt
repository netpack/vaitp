"safely pass a list of objects to a thread that reschedules itself i have a thread that is responsible for purging old data from a mysql database. we delete in batches so the db isn't consumed if there's a large purge, so the thread does the purge, waits for a few seconds, and then calls itself again to continue the purge (if there's any records left)...my issue is that we allow people to setup multiple rules for what needs to be purged. in an old system that didn't do anything in batches, we'd simply iterate through each ""purge rule"" and run the queries...however, now that we have a system where the thread schedules itself again, i can remove rules from the arraylist anymore, due to a concurrentmodificationexception..i have an arraylist&lt;queryparameters&gt; that we iterate. if there are no records left to purge, we should remove the rule from the list, so that the next time the thread runs it doesn't repeat it...how can i properly remove the rule from the list but not get the cme? i guess i could a concurrenthashmap but i don't want really want to store a key->value...the code is a plugin to a larger blank app, we're using their thread schedulder, just fyi...i've tried both ways to iterate the arraylist, a for loop and using an iterator..public class purgetask implements runnable {..    private prism plugin;.    private arraylist&lt;queryparameters&gt; paramlist;.    private int total_records_affected = 0, cycle_rows_affected = 0;.    private int purge_tick_delay;..    /**.     * .     * @param plugin.     */.    public purgetask( prism plugin, arraylist&lt;queryparameters&gt; paramlist, int purge_tick_delay ){.        this.plugin = plugin;.        this.paramlist = paramlist;.        this.purge_tick_delay = purge_tick_delay;.    }...    /**.     * .     */.    public void run(){.        if(paramlist.size() &gt; 0){.            actionsquery aq = new actionsquery(plugin);.            // execute in batches so we don't tie up the db with one massive query.            for (iterator&lt;queryparameters&gt; it = paramlist.iterator(); it.hasnext(); ) {.                queryparameters param = it.next();..                cycle_rows_affected = aq.delete(param);.                plugin.debug(""purge cycle cleared "" + cycle_rows_affected + "" rows."");.                total_records_affected += cycle_rows_affected;..                // if nothing (or less than the limit) has been deleted this cycle, we need to move on.                if( cycle_rows_affected == 0 || cycle_rows_affected &lt; plugin.getconfig().getint(""prism.purge.records-per-batch"") ){..                    // log final count of cleared records.                    plugin.log(""cleared "" + total_records_affected + "" rows from the database. using:"" + param.getoriginalcommand() );.                    total_records_affected = 0;..                    // remove the purge rule from the list so we don't repeat.                    paramlist.remove(param);..                } else {..                    // items we're deleted. leave params in queue and re-schedule this task.                    plugin.deletetask = plugin.getserver().getscheduler().runtasklaterasynchronously(plugin, new purgetask( plugin, paramlist, purge_tick_delay ), purge_tick_delay);..                }.            }.        }.    }.}"
