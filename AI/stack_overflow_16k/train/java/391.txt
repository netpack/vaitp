"blank concurrentmodificationexception; single thread; without for each loop i am currently programming a btree algorithm..i have already implemented the functionality to add numbers to it. as i went to test it, i ran into a concurrentmodificationexception...i researched the issue and found hints that it mainly is due to two things:...multiple threads accessing the same list..modifing the list while going through it using a for each loop....neither of these problems occur in my code, so i am completely lost.....i hope you guys can help me!..code from the ""knoten"" class:..public list&lt;nodes&gt; childnodes;.public list&lt;integer&gt; keys;..private baum tree;.private nodes parent;.private boolean isroot;...public void add(int number).{.    int lastsmallerposition = -1;..    for(int i = 0; i &lt; keys.size(); i++).    {.        if(keys.get(i) &lt; number).        {.            lastsmallerposition = i;.        }.        else.        {.            if( keys.size() &lt; i + 1 &amp;&amp; number == keys.get(i + 1)).            {.                return; .            }.            break;.        }.    }..    if(isleaf()).    {.        keys.add(lastsmallerposition + 1, number);..        if(keys.size() &gt; tree.maxkeys).        {.            if(isroot) .            {.                nodes k1 = new nodes(tree, this, false);.                nodes k2 = new nodes(tree, this, false);.                k1.keys.addall(keys.sublist(0, keys.size()/2));.                k2.keys.addall(keys.sublist(keys.size()/2 + 1, keys.size()));.                childnodes.add(k1);.                childnodes.add(k2);..                int sparenumber = keys.get(keys.size()/2);.                keys.clear();.                keys.add(sparenumber);.            }.            else.            {.                if(parent.keys.size() == tree.maxkeys).                {.                    list&lt;integer&gt; list = new arraylist&lt;integer&gt;();..                    if(parent.childnodes.indexof(this) == 0).                    {..                        int index = parent.childnodes.indexof(this);..                        list.addall(keys);.                        list.add(parent.keys.get(index));.                        list.addall(parent.childnodes.get(index + 1).keys);..                        keys.clear();.                        parent.keys.remove(index);.                        parent.childnodes.remove(index + 1);.                    }.                    else.                    {..                        int index = parent.childnodes.indexof(this) - 1; ..                        list.addall(parent.childnodes.get(index).keys);.                        list.add(parent.keys.get(index));.                        list.addall(keys);..                        parent.childnodes.remove(index);.                        parent.keys.remove(index);.                        keys.clear();.                    }..                    int keysperchildnode = (list.size() - tree.minkeys) / tree.minchilds;.                    int extrakeys = (list.size() - tree.minkeys) % tree.minchilds; .                    int usedextrakeys = 0;..                    for(int i = 0; i &lt; tree.minkeys - 1; i ++).                    {.                        childnodes.add(new nodes(tree, this, false));.                        childnodes.get(i).keys.addall(.                                list.sublist(i * keysperchildnode + usedextrakeys + i, (i + 1) * keysperchildnode + usedextrakeys + i));.                        if(usedextrakeys &lt; extrakeys).                        {.                            childnodes.get(i).keys.add(list.get((i + 1) * keysperchildnode + usedextrakeys + i));.                            usedextrakeys++;.                        }..                        keys.add(list.get((i + 1) * keysperchildnode + usedextrakeys + i));.                    }..                    childnodes.add(new nodes(tree, this, false));.                    childnodes.get(tree.minchilds - 1).keys.addall(list.sublist(list.size() - keysperchildnode, list.size()));.                }.                else.                {.                    nodes k = new nodes(tree,parent,false);.                    k.keys = keys.sublist(keys.size() / 2, keys.size());.                    int newparentkey  = keys.get(keys.size() / 2 - 1);..                    keys = keys.sublist(0, keys.size() / 2 - 1);..                    int index = parent.childnodes.indexof(this);..                    parent.keys.add(index, newparentkey);.                    parent.childnodes.add(index + 1, k);.                }.            }.        }.    }.    else .    {.        childnodes.get(lastsmallerposition + 1).add(number);.    }.}...exception:..blank.util.concurrentmodificationexception.    at blank.util.arraylist$sublist.checkforcomodification(unknown source).    at blank.util.arraylist$sublist.size(unknown source).    at baum.knoten.add(knoten.blank:39).    at baum.knoten.add(knoten.blank:175).    at baum.baum.add(baum.blank:31).    at test.baumtest.addtest(baumtest.blank:47).    at sun.reflect.nativemethodaccessorimpl.invoke0(native method).    at sun.reflect.nativemethodaccessorimpl.invoke(unknown source).    at sun.reflect.delegatingmethodaccessorimpl.invoke(unknown source).    at blank.lang.reflect.method.invoke(unknown source).    at org.junit.runners.model.frameworkmethod$1.runreflectivecall(frameworkmethod.blank:50).    at org.junit.internal.runners.model.reflectivecallable.run(reflectivecallable.blank:12).    at org.junit.runners.model.frameworkmethod.invokeexplosively(frameworkmethod.blank:47).    at org.junit.internal.runners.statements.invokemethod.evaluate(invokemethod.blank:17).    at org.junit.runners.parentrunner.runleaf(parentrunner.blank:325).    at org.junit.runners.blockjunit4classrunner.runchild(blockjunit4classrunner.blank:78).    at org.junit.runners.blockjunit4classrunner.runchild(blockjunit4classrunner.blank:57).    at org.junit.runners.parentrunner$3.run(parentrunner.blank:290).    at org.junit.runners.parentrunner$1.schedule(parentrunner.blank:71).    at org.junit.runners.parentrunner.runchildren(parentrunner.blank:288).    at org.junit.runners.parentrunner.access$000(parentrunner.blank:58).    at org.junit.runners.parentrunner$2.evaluate(parentrunner.blank:268).    at org.junit.runners.parentrunner.run(parentrunner.blank:363).    at org.eclipse.jdt.internal.junit4.runner.junit4testreference.run(junit4testreference.blank:86).    at org.eclipse.jdt.internal.junit.runner.testexecution.run(testexecution.blank:38).    at org.eclipse.jdt.internal.junit.runner.remotetestrunner.runtests(remotetestrunner.blank:459).    at org.eclipse.jdt.internal.junit.runner.remotetestrunner.runtests(remotetestrunner.blank:675).    at org.eclipse.jdt.internal.junit.runner.remotetestrunner.run(remotetestrunner.blank:382).    at org.eclipse.jdt.internal.junit.runner.remotetestrunner.main(remotetestrunner.blank:192)"
