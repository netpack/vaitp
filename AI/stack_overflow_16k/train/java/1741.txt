"background image in different place every time i have a large program that i will post some classes of and hopefully you guys can find the problem. basically, sometimes when i start it, it creates the game just fine, and others the background is up a few pixels to the north and west directions leaving very unsightly whitespace. i cannot seem to find the missing piece of code that decides whether not it does this. it honestly feel like some kind of rendering glitch on my machine. at any rate, i have put a background getx and gety method in for debugging and have noticed that whether the background is fully stretched to the screen(its a custom background so the pixel height and width match perfectly), or its up and to the left, the background still reads that it is displaying at (0,0). i will post all the methods from the main thread to the creating of the background in the menu. i will leave notes indicating the path it takes through this code that gets it to creating the background. thank you for your help and i will check in regularly for edits and more information...edit: added background.blank.edit2: added pictures explaining problem..menu.blank *ignore the fileio code, the main point is the creation of a new gamepanel()..    public class menu {..    private static file file;..    public static void main(string[] args) throws ioexception {.        file = new file(""saves.txt"");.        if(file.exists()){.            fileio.run();.            fileio.profilechoose();.        }.        else{.            fileio.profilecreate();.            fileio.run();.        }..        jframe window = new jframe(""jolly jackpot land"");.        window.setcontentpane(new gamepanel());.        window.setdefaultcloseoperation(jframe.exit_on_close);.        window.setresizable(false);.        window.pack();.        window.setlocationrelativeto(null);.        window.setvisible(true);.    }.}...next is the gamepanel.blank..    public class gamepanel extends jpanel implements runnable, keylistener {.    // id.    private static final long serialversionuid = 1l;..    // dimensions.    public static final int width = 320;.    public static final int height = 240;.    public static final int scale = 2;..    // thread.    private thread thread;.    private boolean running;.    private int fps = 30;.    private long targettime = 1000 / fps;..    // image.    private bufferedimage image;.    private graphics2d g;..    // game state manager.    private gamestatemanager gsm;..    public gamepanel() {.        super();.        setpreferredsize(new dimension(width * scale, height * scale));.        setfocusable(true);.        requestfocus();.    }..    public void addnotify() {.        super.addnotify();.        if (thread == null) {.            thread = new thread(this);.            addkeylistener(this);.            thread.start();.        }.    }..    public void paintcomponent(graphics g) {.        super.paintcomponent(g);.    }..    private void init() {.        image = new bufferedimage(width, height, bufferedimage.type_int_rgb);.        g = (graphics2d) image.getgraphics();.        running = true;..        gsm = new gamestatemanager();.    }..    @override.    public void run() {.        init();..        long start;.        long elapsed;.        long wait;..        // game loop.        while (running) {.            start = system.nanotime();.            update();.            draw();.            drawtoscreen();..            elapsed = system.nanotime() - start;.            wait = targettime - (elapsed / 1000000);..            if (wait &lt; 0) {.                wait = 5;.            }..            try {.                thread.sleep(wait);.            } catch (interruptedexception e) {.                e.printstacktrace();.            }.        }.    }..    private void update() {.        gsm.update();.    }..    private void draw() {.        gsm.draw(g);.    }..    private void drawtoscreen() {.        graphics g2 = getgraphics();.        g2.drawimage(image, 0, 0, width * scale, height * scale, null);.        g2.dispose();.    }..    @override.    public void keypressed(keyevent k) {.        gsm.keypressed(k.getkeycode());.    }..    @override.    public void keyreleased(keyevent k) {.    }..    @override.    public void keytyped(keyevent arg0) {.    }.}...this calls for the creation of a new gamestatemanager object in its init() method and the class for that is here...gamestatemanager.blank..public class gamestatemanager {...    private arraylist&lt;gamestate&gt; gamestates;.    private int currentstate;..    public static final int menustate = 0;.    public static final int slotgamestate = 1;.    public static final int dicegamestate = 2;.    public static final int roulettegamestate = 3;.    public static final int leaderboardstate = 4;.    public static final int settingsstate = 5;.    public static final int helpstate = 6;...    public gamestatemanager() {.        gamestates = new arraylist&lt;gamestate&gt;();..        currentstate = 0;.        gamestates.add(new menustate(this));.        gamestates.add(new slotgamestate(this));.        gamestates.add(new dicegamestate(this));.        gamestates.add(new roulettegamestate(this));.        gamestates.add(new leaderboardstate(this));.        gamestates.add(new settingsstate(this));.        gamestates.add(new helpstate(this));...    }..    public void setstate(int state){.        currentstate = state;.        gamestates.get(currentstate).init();.        currentstate = 0;.    }..    public int getstate() {.        return currentstate;.    }..    public void update() {.        gamestates.get(currentstate).init();.    }..    public void draw(blank.awt.graphics2d g){.        gamestates.get(currentstate).draw(g);.    }..    public void keypressed(int k){.        gamestates.get(currentstate).keypressed(k);.    }..    public void keyreleased(int k) {.        gamestates.get(currentstate).keyreleased(k);.    }.}...gamestate is an abstract class i have so its not worth posting, it only contains init(), draw(), etc. this next class is the last and final class and is called because gamestatemananger starts at menustate or 0, and when gsm is initialized it initializes its current state, thus taking us to the class menustate..menustate.blank..public class menustate extends gamestate {..    private background bg;..    public fontmetrics fontmetrics;..    private int choice = 0;.    private string[] options = { ""slot machine"", ""dice toss"", ""roulette wheel"", ""leaderboards"", ""settings"", ""help"",.            ""quit"" };..    private color titlecolor;.    private font titlefont;..    private font font;..    public menustate(gamestatemanager gsm) {.        this.gsm = gsm;.        try {.            bg = new background(""/backgrounds/happybg.png"");..            titlecolor = color.white;.            titlefont = new font(""georgia"", font.plain, 28);.        } catch (exception e) {.            e.printstacktrace();.        }..        font = new font(""arial"", font.plain, 12);.    }..    @override.    public void init() {.    }..    @override.    public void update() {.    }..    @override.    public void draw(graphics2d g) {.        canvas c = new canvas();.        fontmetrics = c.getfontmetrics(font);.        // draw bg.        bg.draw(g);..        // draw title.        g.setcolor(titlecolor);.        g.setfont(titlefont);.        string title = ""jolly jackpot land!"";.        g.drawstring(title, 36, 60);..        g.setfont(font);..        for (int i = 0; i &lt; options.length; i++) {.            if (i == choice).                g.setcolor(color.red);.            else.                g.setcolor(color.white);.            g.drawstring(options[i], 30, 120 + i * 15);.        }.        g.setcolor(color.white);.        g.setfont(new font(""arial"", font.plain, 10));.        g.drawstring(""v1.1"", 165, 235);..        object[] a = { (""name: "" + player.getname()), (""gil: "" + player.getgil()),.                (""personal best: "" + player.getpersonalbest()), (""winnings: "" + player.getwinnings()),.                (""wins: "" + player.getwins()), (""losses: "" + player.getlosses()),.                (""win/loss ratio: "" + string.format(""%.2f"", player.getratio()) + ""%"") };..        g.setfont(font);..        if (player.getname() != null) {.            for (int x = 0; x &lt; a.length; x++) {.                g.drawstring(a[x].tostring(), gamepanel.width - fontmetrics.stringwidth(a[x].tostring()) - 30,.                        120 + x * 15);.            }.        }.    }..    private void select() {.        if (choice == 0) {.            // slots.            gsm.setstate(gamestatemanager.slotgamestate);.        }.        if (choice == 1) {.            // dice.            gsm.setstate(gamestatemanager.dicegamestate);.        }.        if (choice == 2) {.            // roulette.            gsm.setstate(gamestatemanager.roulettegamestate);.        }.        if (choice == 3) {.            // leaderboards.            gsm.setstate(gamestatemanager.leaderboardstate);.        }.        if (choice == 4) {.            // settings.            gsm.setstate(gamestatemanager.settingsstate);.        }.        if (choice == 5) {.            // help.            gsm.setstate(gamestatemanager.helpstate);.        }.        if (choice == 6) {.            // quit.            system.exit(0);.        }.    }..    @override.    public void keypressed(int k) {.        if (k == keyevent.vk_enter) {.            select();.        }.        if (k == keyevent.vk_up) {.            choice--;.            if (choice == -1) {.                choice = options.length - 1;.            }.        }.        if (k == keyevent.vk_down) {.            choice++;.            if (choice == options.length) {.                choice = 0;.            }.        }.    }..    @override.    public void keyreleased(int k) {.    }.}...background.blank..public class background {..    private bufferedimage image;.    private double x;.    private double y;..    public background(string s) {.        try {.            image = imageio.read(getclass().getresourceasstream(s));.        } catch (exception e) {.            e.printstacktrace();.        }.    }..    public void setposition(double x, double y) {.        this.setx(x);.        this.sety(y);.    }..    public void draw(graphics2d g) {.        g.drawimage(image, 0, 0, null);.    }..    public double getx() {.        return x;.    }..    public void setx(double x) {.        this.x = x;.    }..    public double gety() {.        return y;.    }..    public void sety(double y) {.        this.y = y;.    }.}...this is where it waits for input in the game loop basically. i know this is a lot of code, but a lot of it is skimming till a method call takes you to the next class. i just can't figure out why it only happens sometimes, if it was consistent i could debug it. any help would be extremely appreciated......these are both from clicking the .jar of the above program, exact same .jar, exact same source code, different result. i am bewildered."
