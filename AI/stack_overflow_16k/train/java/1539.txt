"doubly generic linked list with anonymous inner class (in function) i deleted my last post and i rewrite the problem again (after i learn how to do it and what is the requirements...1.i need to define nodedouble as a generic inner class - private. in this class i need to write constructor that consume data and string method...2.i need to define linkedlistdouble in this class in need constructer without elements. methode to add an element and method to present the list...3.in the class linkedlistdouble i need to define method listiterator that return object from type listiteartor. in the functiob listiterator i need return 3 method:.- t next - return the next element.- boolean has next-return true if the list iteartor has more elements.- t previous- return the previous element in the list, if there is not an element - return exception....this is my code:..enter code here..public class doublylinkedlist&lt;t&gt; {./**. * . * @author user. *. * @param &lt;t&gt;. */.    class node &lt;t&gt;{..        private t data;.        private node previous;.        private node next;..        node(t data) { .            this.data = data; ..        }.        public node previous() { .            return this.previous; .        }..        public node next() { .            return this.next; .        }..        public t getcontent() { .            return this.data; .        }..        public void setprevious(node previous) { .            this.previous = previous; .        }.        public void setnext(node next) { .            this.next = next; .        }..        public string tostring() { .            return data.tostring(); .            }.    }...    private node head;.    private node tail;.    private int size = 0;..    public node head() { .        return this.head;.        }..    public node tail() {.        return this.tail; .        }..    public void add(t element) {.        node newnode = new node(element);.        if (this.size == 0) {.            this.head = newnode;.            this.tail = newnode;.        } else {.            this.tail.setnext(newnode);.            newnode.setprevious(this.tail);.            this.tail = newnode;.        }.        this.size++;.    }.    /*.     public boolean isempty(){..            return size==0;..        }.      public void push(int data){.            node n= new node(data);.            if(isempty()) {.                tail=n;.                head=n;.            }.            else {.               head.previous = n;.               n.next=head;.                head=n;.            }.            size++;.        }*/...    public string tostring() {.        stringbuilder stringbuilder = new stringbuilder();.        node currentnode = this.head;.        while (currentnode != null) {.            stringbuilder.append(currentnode.getcontent()).append("" "");.            currentnode = currentnode.next();.        }.        system.out.println(stringbuilder.tostring().trim());.        return stringbuilder.tostring().trim();.    }..    public listiterator listiterator() {..        return new listiterator() {.            node curr;..            public boolean hasnext() {.                return curr.next() != null;.            }..            public t next() {.                t element = (t) curr.getcontent();.                curr = curr.next();.                return element;.            }.            public t previous()  {.                t element = (t) curr.getcontent();.                if(curr.previous()!=null) {.                curr = curr.previous();.                return element;.                }.                throw new nosuchelementexception();.            }.            @override.            public boolean hasprevious() {.                if(curr.previous() != null) {.                    return true;.                }.                return false;.            }.            @override.            public void add(object e) {.             throw new unsupportedoperationexception();             .            }.            @override.            public int nextindex() {.                throw new unsupportedoperationexception();              .            }.            @override.            public int previousindex() {.                throw new unsupportedoperationexception();              .            }.            @override.            public void remove() {.                throw new unsupportedoperationexception();              ..            }..            @override.            public void set(object e) {.                throw new unsupportedoperationexception();              ..            }.        };..    }.     public static void main (string[]args) {.         doublylinkedlist&lt;integer&gt; a = new doublylinkedlist();.            a.add(7);.            a.add(8);.            a.add(9);.            a.add(10);.            a.tostring();..            listiterator &lt;integer&gt; iter = a.listiterator();.            while (iter.hasnext()) {.                system.out.println(iter.next());..            }..     }.        }...my questions:.1..i get a wrong when i try do do this code in the main:.how i can fix it? (the main is above)...i am reading some articles about anonymous inner class, i don't know if i indeed do it right in this exercise (in the function listiterator i try to define anonymous inner class but i don't know if this is the way to do it.....thank you!.have a good day"
