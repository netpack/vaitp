"count of consecutive duplicate integers in a list with frequency i want to count the number of consecutive repeating numbers from a list of bytes and show them as two integers arrays:...the first array contains the non-repeating integer values..the second array contains the consequent repetition counts....so, for an input like this: ..byte[] bytes = new byte[] {2, 2, 2, 0, 0, 0, 0, 2, 2, 0, 0, 2};...i expect an output like this:..integers  -[2, 0, 2, 0, 2].frequency -[3, 4, 2, 2, 1]...which is basically a compressed view of the input. the output says integer 2 repeats 3 times followed by 0 that repeats 4 times followed by 2 that repeats 2 times and so on.. ..i have written the below code. .. list&lt;byte&gt; integers = new arraylist&lt;&gt;();. list&lt;integer&gt; frequencies = new arraylist&lt;&gt;();.. for (int i=0; i &lt; bytes.size() - 1; i++) {.     byte current = bytes.get(i);.     byte next = bytes.get(i+1);.     if (current == next) {.         count ++;.         // if all bytes are of the same type.         if (count == bytes.size() || i == bytes.size() - 2) {.             integers.add(current);.             frequencies.add(count);.         }.         continue;.         integers.add(current);.         frequencies.add(count);.         count = 1;.     }. }. system.out.println(""integers "" +  integers + "" - frequency "" + frequencies);...this code works for most cases. but i am missing some edge cases. like for the example input, the output is missing to reach to the last element 2. the output from my code for input is - ..integers  -[2, 0, 2, 0].frequency -[3, 4, 2, 2]...i am adding a bunch of if statements to cover all corner cases but i want to know if there is a cleaner solution to this?"
