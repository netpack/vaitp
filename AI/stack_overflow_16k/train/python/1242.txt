"blank: fast and minimalistic way to zip and pair matching elements in two lists i have:..&gt;&gt;&gt; as = [1, 2, 5, 6].&gt;&gt;&gt; bs = [2, 3, 4, 5]...i want something like zip_fn below:..&gt;&gt;&gt; rs = zip_fn(as, bs, cmp).&gt;&gt;&gt; rs.[(1, none), (2, 2), (none, 3), (none, 4), (5, 5), (6, none)]...in other words, given two arbitrary sequences as and bs, i want to produce a list of tuples rs such that choices that satisfy cmp(a, b) == 0 are paired together into their own tuple (a, b), but those in as and bs without matching counterparts are output as (a, none) and (none, b) respectively...some points:...i'm not worried about duplicates in as or bs as there won't be any..rs can be an iterator that produces the same sequence..the ordering of rs is unimportant....i've already implemented something that satisfies the functional requirement using straight-forward presorted looping but it's roughly 30 lines.  i'm looking for something that makes better use of builtins or itertoolsesque libraries for shorter code and faster (c native) running...edit:..i should have made this clearer.  although i used a list of plain numbers in the example above for brevity, the elements i'm actually working with are tuples, and cmp tests only a part of the tuple for equality.  it might be easier to think of the elements as being records and cmp as something that matches on the key fields.  i could wrap the elements in a class and make it hashable on the key, but such a set up isn't required for anything else so any solution that requires this will get this as additional code and runtime overhead...summarizing this as additional points to the some above:...it's vital that cmp is used for comparison as it's not a test for basic equality..in the result [(a, b)], a should be the same instance as one of the elements in as and b the same instance of one of the elements in bs, provided they aren't none..elements in as and bs aren't hashable."
