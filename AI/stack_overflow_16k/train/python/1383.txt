"how should i expose read-only fields from blank classes? i have many different small classes which have a few fields each, e.g. this:..class article:.    def __init__(self, name, available):.        self.name = name.        self.available = available...what's the easiest and/or most idiomatic way to make the name field read only, so that..a = article(""pineapple"", true).a.name = ""banana""  # &lt;-- should not be possible...is not possible anymore?..here's what i considered so far:...use a getter (ugh!)...class article:.    def __init__(self, name, available):.        self._name = name.        self.available = available..    def name(self):.        return self._name...ugly, non-blankic - and a lot of boilerplate code to write (especially if i have multiple fields to make read-only). however, it does the job and it's easy to see why that is..use __setattr__:..class article:.    def __init__(self, name, available):.        self.name = name.        self.available = available..    def __setattr__(self, name, value):.        if name == ""name"":.            raise exception(""%s property is read-only"" % name).        self.__dict__[name] = value...looks pretty on the caller side, seems to be the idiomatic way to do the job - but unfortunately i have many classes with only a few fields to make read only each. so i'd need to add a __setattr__ implementation to all of them. or use some sort of mixin maybe? in any case, i'd need to make up my mind how to behave in case a client attempts to assign a value to a read-only field. yield some exception, i guess - but which?.use a utility function to define properties (and optionally getters) automatically. this is basically the same idea as (1) except that i don't write the getters explicitely but rather do something like..class article:.    def __init__(self, name, available):.        # this function would somehow give a '_name' field to self.        # and a 'name()' getter to the 'article' class object (if.        # necessary); the getter simply returns self._name.        definefield(self, ""name"").        self.available = available...the downside of this is that i don't even know if this is possible (or how to implement it) since i'm not familiar with runtime code generation in blank. :-)...so far, (2) appears to be most promising to me except for the fact that i'll need __setattr__ definitions to all my classes. i wish there was a way to 'annotate' fields so that this happens automatically. does anybody have a better idea?..for what it's worth, i'mu sing blank 2.6...update:.thanks for all the interesting responses! by now, i have this:..def ro_property(o, name, value):.    setattr(o.__class__, name, property(lambda o: o.__dict__[""_"" + name])).    setattr(o, ""_"" + name, value)..class article(object):.    def __init__(self, name, available):.        ro_property(self, ""name"", name).        self.available = available...this seems to work quite nicely. the only changes needed to the original class are...i need to inherit object (which is not such a stupid thing anyway, i guess).i need to change self._name = name to ro_property(self, ""name"", name)....this looks quite neat to me - can anybody see a downside with it?"
