"map and work with (x, y), (x,z) and (y,z) pairs and associated x, y or z coordinates i have a list of lists nledgers - a 3d cloud of points:..[nodeid, x, y, z]...with multiple rows. some nodes will have the same x and y coordinates and different z coordinate...i'd like to, first identify the different z coordinates which have the same x and y coordinates..then the same for x, and finally for y...then, using those (x,y), (x,z) or (y,z) pairs and different z, yor x levels i'd like to change the x and y coordinates of a second list (nodes)...the changes should respect the following:..1) for x,y,z in `nodes`, if x=x and y=y and z level 1 &lt;=z&lt; z level 2:.   change x and y coordinates between consecutive `z` levels, for each pair of `(x,y)` coordinates...2) for x,y,z in `nodes`, if x=x and y level 1 &lt;=y&lt; y level 2:.   change x coordinates between consecutive `y` levels, for each pair of `(y,z)` coordinates...3) for x,y,z in `nodes`, if y=y and x level 1 &lt;=x&lt; x level 2:.   change y coordinates between consecutive `x` levels, for each pair of `(x,z)` coordinates....any help is appreciated...based on previous posts i have the following code:..from ast import literal_eval.nledgers=[[literal_eval(x) for x in item] for item in nledgers] #transform list of strings to list of floats.nodes=[[literal_eval(x) for x in item] for item in nodes]..newnodescoord = [].dirx=1 #integer that changes the direction (x,y) of the vector to change the x and y coordinates.diry=1-dirx.newy1=0 #float that stores the new y coordinate at x=x1 and z=z .newy2=0 #float that stores the new y coordinate at x=x2 (x2&gt;x1) and z=z .newx1=0 #float that stores the new x coordinate at y=y1 and z=z .newx2=0 #float that stores the new x coordinate at y=y2 (y2&gt;y1) and z=z ..from collections import defaultdict.dic1=defaultdict(list) #dictionary of x and y pairs.dic2=defaultdict(list) #dictionary of x and z pairs.dic3=defaultdict(list) #dictionary of y and z pairs..for id,x,y,z in nledgers:.    dic1[(x,y)].append((id,z)).for key in dic1:.    dic1[key].sort( key=lambda x:float(x[1]) )..for id,x,y,z in nledgers:.    dic2[(x,z)].append((id,y)).for key in dic2:.    dic2[key].sort( key=lambda x:float(x[1]) ).#print dic2..for id,x,y,z in nledgers:.    dic3[(y,z)].append((id,x)).for key in dic2:.    dic3[key].sort( key=lambda x:float(x[1]) ).#print dic3..newnodes=[] #list with changed coordinates.for i,row in enumerate(nodes): #same x,y, different z.    id,x,y,z=row.    z_levels=[item[1] for item in dic1[(x,y)]].    for k,l in zip(z_levels,z_levels[1:]):.        if k&lt;=z&lt;l:.            nodes[i][1]=x+((l-k)/400*sin(pi*(z-k)/l)+max(z_levels)/800*(z/max(z_levels)))*dirx.            nodes[i][2]=y+((l-k)/400*sin(pi*(z-k)/l)+max(z_levels)/800*(z/max(z_levels)))*diry.            nodes[i][3]=z.            newnodes.append([nodes[i][0], nodes[i][1], nodes[i][2], nodes[i][3]]).#           break ..for i,row in enumerate(nodes):  #same x, different y.    id,x,y,z=row.    y_levels=[item[1] for item in dic2[(x,z)]].    z_levels=[item[1] for item in dic1[(x,y)]].    for k,l in zip(y_levels,y_levels[1:]):.        if x==dic2.keys()[0][0] and k&lt;y&lt;l:.            for m,n in zip(z_levels,z_levels[1:]):.                if m==z and y==k:.                    newx1=x+((n-m)/400*sin(pi*(z-m)/n)+max(z_levels)/800*(z/max(z_levels)))*dirx.                if m==z and y==l:.                    newx2=x+(n-m)/400*sin(pi*(z-m)/n)+max(z_levels)/800*(z/max(z_levels))   .            nodes[i][1]=x+(y-k)*(newx2-newx1)/(l-k)+newx1.            nodes[i][2]=y.            nodes[i][3]=z.            newnodes.append([nodes[i][0], nodes[i][1], nodes[i][2], nodes[i][3]])..for i,row in enumerate(nodes):#same y, different x.    id,x,y,z=row.    x_levels=[item[1] for item in dic3[(y,z)]].    z_levels=[item[1] for item in dic1[(x,y)]].    for k,l in zip(x_levels,x_levels[1:]):.#        print dic3.keys()[0][0].        if y==dic3.keys()[0][0] and k&lt;x&lt;l: #same x, different y.            for m,n in zip(z_levels,z_levels[1:]):.                if m==z and y==k:.                    newy1=y+((n-m)/400*sin(pi*(z-m)/n)+max(z_levels)/800*(z/max(z_levels)))*diry.                if m==z and y==l:.                    newy2=y+((n-m)/400*sin(pi*(z-m)/n)+max(z_levels)/800*(z/max(z_levels)))*diry  .            nodes[i][1]=x.            nodes[i][2]=y+(y-k)*(newy2-newy1)/(l-k)+newy1.            nodes[i][3]=z.            newnodes.append([nodes[i][0], nodes[i][1], nodes[i][2], nodes[i][3]])...the first change is working (the x,y pair), the other two aren't working. i've got a problem in dic2.keys()[0][0]. i'd like to loop over the keys of dic2 and compare the value of the first key with x."
