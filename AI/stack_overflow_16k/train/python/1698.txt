"iteration over an array is behaving as if the array is being modified during iteration, when this is not happening i’m writing some software for a weather station in blank. every minute, on the minute, new values are taken from sensors (the values are actually taken from a file that updates each minute) and added to an array. the items in this array are to be uploaded to an online database. the array acts as a buffer to stop the current latest data being overwritten by a newer version if, for example the internet connection goes down. when the connection comes back up, the items in the array can all be uploaded and nothing will have been lost. the population of the array happens in a separate thread...back on the main thread, 1 second after the minute a copy of the array is made. this copy is then iterated over and each item is uploaded to the database. following the upload of an item, it is removed from the original array but not the copy, to prevent errors caused by manipulating an while iterating over it. if an error occurs with uploading any of the items then the entire iteration stops and is left to be resumed on the next minute, in order to preserve the chronology of data in the database. this is thread safe because i’m deleting from the original array, but i am iterating over a copy of it, and i see no problems with the threading side of things anywhere in the code...however, i am having a very hard to remove problem that looks like something you would find when modifying a list while iterating over it, even though this is not happening anywhere. when supplied with one piece of data every minute (this is normal operation), everything uploads fine. additionally, it also works fine if there are two items in the array (done by removing the internet connection for one minute). both items upload in the right order. however, if there are more than two items to upload in the list (internet is down for more than a minute) then the iteration seems to skip every other item in the list. this results in every other item being uploaded, then every other item of the remaining items in the array being uploaded and so on until the array returns to a normal one per minute. this leads to the uploads in the database being out of order...i have narrowed the error down to the line that deletes the item from the uploadbuffer array, as without this line it works fine (except obviously the items aren’t removed from the buffer once uploaded). i don’t see how this problem can be exist because i’m iterating over a copy of the original list. removal of the item from the original list happens using its value and not its index, so that can’t be the problem. also, the copy of the original array is made once, before the iteration begins, so i don’t see how removing items from the original can affect the iteration over the copy...i really would like to get this fixed as i’ve been trying for over two weeks with no luck, so thanks for any help, and my code is below. also, please mention if you notice any problems with how i am using the threading locks as i’m not completely sure if i’m using them correctly...import urllib2.from lxml import etree.import os.import datetime.import time.import httplib.import socket.import threading..timeformat = ""%d/%m/%y at %h:%m:%s.%f"".rollingdata = ""/home/pi/weatherstation/other/latest.xml"".bufferlock = threading.lock()..print(""mod_upload: file watching started on "" +.      datetime.datetime.now().strftime(timeformat)).uploadbuffer = []..def watchforreport():.    previousmodified = os.stat(rollingdata)[8]..    while true:.        try:.            currentmodified = os.stat(rollingdata)[8]..            # new data needs to be uploaded.            if not currentmodified == previousmodified:.                newdata = open(rollingdata, ""r"").read()..                bufferlock.acquire().                uploadbuffer.append(newdata).                bufferlock.release()..                previousmodified = currentmodified..        except:.            print(""oserror"")..# watch for new data in separate thread.threading.thread(target = watchforreport).start()...while true:.    currentsecond = datetime.datetime.now().strftime(""%s"")..    if currentsecond == ""01"" or currentsecond == ""02"":.        if bufferlock.locked() == false:..            bufferlock.acquire().            buffercopy = uploadbuffer.            bufferlock.release()..            # if there are records to be uploaded.            if len(buffercopy) &gt; 0:..                for item in buffercopy:.                    print(""nreport: "" + item[:35]).                    print(""buffercount: "" + str(len(buffercopy)))..                    if item == """":.                        # this isn't the problem, as the text 'empty' is almost never printed.                        print(""empty"").                        buffercopy.remove(item).                        break.                    else:.                        report = etree.fromstring(item)..                    # separate date and time and format.                    timestamp = report.xpath(""@time"")[0]..                    tdate = timestamp.rsplit(""t"", 2)[0].                    ttime = timestamp.rsplit(""t"", 2)[1].                    ttime = ttime.replace("":"", ""-"")..                    # generate url to write data to the database.                    url = ""http://www.example.com/uploadfile.php?date="".                    url += tdate + ""&amp;time="" + ttime + ""&amp;shieldedtemp="".                    url += report.xpath(""@shieldedtemp"")[0] + ""&amp;exposedtemp="".                    url += report.xpath(""@exposedtemp"")[0] + ""&amp;soil10temp="".                    url += report.xpath(""@soil10temp"")[0] + ""&amp;soil30temp="".                    url += report.xpath(""@soil30temp"")[0] + ""&amp;soil100temp="".                    url += report.xpath(""@soil100temp"")[0]..                    try:.                        # upload report to database.                        response = urllib2.urlopen(url, timeout = 9).read().                        print(""response: "" + response)..                        # response[4] means success.                        if response == ""response[4]"":.                            bufferlock.acquire().                            # thus is the line causing the problem:.                            uploadbuffer.remove(item).                            bufferlock.release()..                        else:.                            # break out of loop on failure to preserve chronology.                            break..                    except urllib2.httperror:.                        print(""urllib2.httperror"").                        print(""bufferrecount: "" + str(len(buffercopy))).                        break..                    except httplib.badstatusline:.                        print(""httplib.badstatusline"").                        print(""bufferrecount: "" + str(len(buffercopy))).                        break..                    except urllib2.urlerror:.                        print(""urllib2.urlerror"").                        print(""bufferrecount: "" + str(len(buffercopy))).                        break..                    except socket.timeout:.                        print(""timeout"").                        print(""bufferrecount: "" + str(len(buffercopy))).                        break..                    print(""bufferrecount: "" + str(len(buffercopy)))"
