"split blank game into function i'd like to make my code more logical and clean by creating more functions for sections of the game. currently, there is only one function which is the round_process i like to call it - where it loops until the number of rounds the player inputted is reached. .could anyone help me out with doing this? i feel my code is overly messy and not logical whatsoever. thank you so much. ..# i implemented a random module into my.# program as it is needed to shuffle the 'cpu_choices' list randomly..import random.import time.# time module will be used to roll out the output less rapidly..# so it isn't jarring for the user and they can fully.# comprehend the content that is showing....# ---------------variables---------------#.# i started to plan what variables were necessary to meet the specifications..# i designated variables to sections to make it easier for myself.# and future-proofing as users can gain an understanding.# of each variable and their purpose...# game_rules are capitalized to represent it is a constant.# - meaning they never change. .game_rules = [""rules:"", ""- paper wins against rock"",.              ""- rock wins against scissors"",.              ""- scissors wins against paper"",.              ""- when asked: 'y' = yes, and 'n' = no""].cpu_choices = [""paper"", ""scissors"", ""rock""].# cpu_choices isn't a constant because the order of the.# choices will change. (though the list will not)..player_name = 0  # stores the player's name after input..player_score = 0  # player_score remembers the score of the player..player_history = [].# a placeholder list that holds the player's movement history..player_move = 0.# player_move temporarily holds the move that the player plays...intro_loop = true.# intro_loop is the condition that keeps or stops the introduction running..game_loop = true.# game_loop keeps the ""gameplay"" section of the code.# running if the player wants to do another set of rounds...replay_loop = true.# replay_loop keeps asking the user if they want to replay.# incase they enter an incorrect input..replay_choice = ""y"".# replay_choice is the user's input that decides.# whether or not the ""gameplay"" loop repeats...round_repeat = true.# this variable keeps the code asking what move the player.# wants to play if they enter the wrong thing..total_rounds = 0  # holds the # of rounds the user wants to play..round_num = 0.# round_num stores what number the current round is,.# as well as dictating how many times it runs..round_history = [[]].# round history was included as a placeholder list that.# will hold the move history of the rounds..# this will be used for the 'match overview' part at the end of the game...cpu_move = 0  # cpu_move temporarily holds the move that the computer plays..cpu_score = 0  # cpu_score remembers the score of the computer..cpu_history = []  # a placeholder list that holds the cpu's move history...# ----------------------------------------#..# this function serves as the code portion that.# handles the processes in a round..# (num) is a parameter that is used to insert the current round number...# -----------------------------------------------------------------------------...def round_process(num):.    # function that will operate the rounds.    global cpu_history.    global cpu_score.    global player_score.    global player_history.    # identifying global variables that will be used within.    # this specific function..    # changes made to these variables..    # resets the while loop condition.    round_repeat = true.    random.shuffle(cpu_choices).    # creating a random.shuffle for the cpu choices list.    # to allow for a random and unbiased.    # choice of either r, p or s (obviously)...    # this allows the cpu move to be the first move of 'cpu_choices'..    # the list will always begin at the number 0, not 1..    # the order of the list is shuffled, so the index.    # should always stay the same..    # this allows for the cpu to stay with non-biased.    # randomised choices.    cpu_move = cpu_choices[0]..    # i implemented a while loop to make the input repeat in case the user.    # doesn't input correctly. e.g. inputs a number or misspells a choice..    while round_repeat is true:.        print(""n--------------nround"", num, ""n--------------"").        time.sleep(1).        # all time sleeps incorporated are used to delay the program.        # from running until the bracket number is reached..        # in this case, it's 1 second. this allows for a more fluent,.        # and less jarring and overstuffed program when playing..        player_move = input(.            ""nwhat's your move? 'paper', 'scissors' or 'rock't?"").            .strip().capitalize().        # the .strip gets rid of spaces in the player move, before and after..        # this is useful in a situation where the player may accidentally.        # hit space before or after their answer, and it will still be valid..        # this input asks and stores what move the user wants to make..        # players move is capitalized so if they type 'rock'.        # without a capital r, the program will still.        # recognize it as a valid answer...        # this 'if' statement validates the user's input..        # otherwise they will be asked again via the else statement..        # both not capitalized and capitalized inputs can be accepted, as.        # .capitalize is utilized in my player_move variable..        if player_move == ""paper"" .           or player_move == ""rock"" .           or player_move == ""scissors"":.            # if the input is equal to.            # paper, scissors, or rock, the program will proceed..            # keep in mind capitalized characters will not matter,.            # due to the strip and capitalize method..            print(.                ""nlocked in! you weapon of choice was"", player_move,.                ""nthe cpu chose"", cpu_move)..# -----------------------------------------------------------------------------..            # ----------scoring----------#..            # the if and elif statements within the scoring.            # section dictate whether the user wins, draws, or.            # loses with the cpu..            # scores are added according to the result..            # wins count for two points, draws 1, losses 0..            if player_move == ""paper"" and cpu_move == ""rock"" .                or player_move == ""rock"" and cpu_move == ""scissors"" .                    or player_move == ""scissors"" and cpu_move == ""paper"":.                player_score += 2.                # point is added to the player's score by 2..                time.sleep(1).                print(""nnice work, "", player_name, ""! you win this round!"").            elif player_move == cpu_move:.                player_score += 1.                # this elif gives both the cpu and the.                # player a point each..                cpu_score += 1.                time.sleep(1).                print(""looks like both of you had the same idea!"").                print(""it's a draw!"").            else:.                time.sleep(1).                cpu_score += 2.                # only adds to the cpu_score because the player lost..                print(""nyikes! you lose this round! he beat you with"",.                      cpu_move)..            time.sleep(0.5).            print(""n"", player_name, ""'s score is"", player_score).            # states scores so far for player and cpu.            print(""computer's score is"", cpu_score).            # player_history and cpu_history append, or add,.            # their specific moves from each round into the list..            # this is required in my specifications and can.            # show a 'match history' type screen in the end...            # ----------add scores----------#.            # adding scores from each round and.            # appending the points to the history.            # lists for a match overview and game history at end of the game..            player_history.append(player_move).            cpu_history.append(cpu_move).            # adds the cpu move for each round to the cpu_history list..            round_repeat = false.            # the round loop turns false (not true) so the player.            # continues to next round or end of game..            # ------------------------------#.        else:.            print(""n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"").            print(""|                                 |"").            print(""|         invalid input           |"").            print(""|        please try again.        |"").            print(""|                                 |"").            print(""!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"")..            # ---------------------------#.# -----------------------------------------------------------------------------..print(""-----------------------------------"").print(""|                                 |"").print(""|       t1g3r games presents..    |"").print(""|                                 |"").print(""|       rock paper scissors       |"").print(""|        blank remastered        |"").print(""|                                 |"").print(""-----------------------------------"").time.sleep(1).for rule in game_rules:.    print(rule).# this for loop prints game_rules in a list layout by printing.# each rule within game_rules for every cycle of the loop..# a for loop is used for iterating over a sequence..while intro_loop is true:.    # valid name input is stored inside the player_name variable.    # (was formerly blank).    print(""nwelcome to rock paper scissors, blank remastered!"").    player_name = input(""what is your name?t"").strip().capitalize().    # .capitalize capitalises the first letter of the.    # username for a more aesthetically pleasing look in the game..    if player_name:  # if player name is blank (no characters).        # if statement forces the name to not be blank and to.        # reinput its data input..        intro_loop = false.        # introduction is false so it stops -.        # moves on to next part of the game (round selection and gameplay).        print(""nhey there"", player_name, ""! that's a cool name!"").    else:.        print(""-------nsurely you've got a name! try againn-------"").# i started the game loop here because from here on all inputs.# i request from the user will be only used to play the game..# i felt the user didn't have the need to reinput their name -.# so the while statement goes straight to the rounds part...        # -------------------round option-------------------#..while game_loop:.    try:.        total_rounds = int(input(.            ""nenter a round count: '3', '5', '7' or '9't"")).        if total_rounds not in range(3, 10, 2):.            # start, stop, step. starts at 3, ends at 10.            # (but doesn't include) and.            # steps every 2 to make sure user's input is odd #..            print(.                ""n-------nplease enter '3', '5', '7' or '9'n-------"")..        # --------------------------------------------------#..        else:.            # i reset these variables in the else statement,.            # in case the user wants to replay the game..            # this ensures the scores and histories won't mess up..            player_history = [].            cpu_history = [].            round_num = 1.            cpu_score = 0.            player_score = 0.            replay_loop = true..            while round_num &lt;= total_rounds:.                # this while loop repeats the gameplay function.                # (round_process) until the.                # total amount of rounds inputted by user has been met..                # this is constructed by adding 1 to.                # round_num every time the loop cycles through..                round_process(round_num).                round_num += 1.                # concatenates lists.            round_history = [list(a) for a in zip(player_history, cpu_history)].            # merges history lists together for the ""history"".            # or match overview section..            # the lists become what is known as a.            # ""multidimensional list"" which overrides the prior data.            print(""n-------nhistoryn-------"").            # this for loop prints out the history of the.            # choices both the user and computer.            # by printing the history lists..            # i acts as a counter, increasing by 1 every cycle of the loop..            # the range ends at the amount of rounds..            for i in range(0, round_num - 1):.                print(""nround"", str(i + 1) + "": you chose"", round_history.                      [i][0] + "". the cpu chose"", round_history[i][1]).            print(""n----------nmatch resultsn----------"").            print(""nyou finished on a total score of"", player_score,.                  ""nthe computer finished on a total score of"", cpu_score)..# -----------------------------------------------------------------------------..            # ------------winner determined------------#.            # simple code which identifies a winner, loser, or a tie..            if player_score &gt; cpu_score:.                print(""n you won! congratulations"", player_name, ""!"").            elif player_score &lt; cpu_score:.                print(""nunlucky mate! you lost :("").            elif player_score == cpu_score:.                print(""nyou drew! :|"")..            # -----------------------------------------#..            while replay_loop is true:.                replay_choice = input(.                    ""nwould you like to play again? 'y' or 'n't"").                replay_choice = replay_choice.lower().                # y and n capitals can be accepted,.                # as it lowercases the replay_choice input..                if replay_choice == ""y"" or replay_choice == ""n"":.                    if replay_choice == ""n"":.                        # if statement validates the user's input..                        print(""nhave a good day"", player_name, ""!"").                        # the game_loop and replay_loop will.                        # break on input n, ending game..                        game_loop = false.                    replay_loop = false.                else:.                    print(""n-------nplease enter 'y' or 'n'n-------"").                    # where the input is invalid, the.                    # user will be asked again until they input 'y' or 'n'..    except:.        print(""n-------nplease enter a digitn-------"")```"
