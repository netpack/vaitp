"blank time results not as expected: time.time() - time.time() in playing around with the blank execution of time, i found an odd behavior when calling time.time() twice within a single statement.  there is a very small processing delay in obtaining time.time() during statement execution. ..e.g. time.time() - time.time()..if executed immediately in a perfect world, would compute in a result of 0. ..however, in real world, this results in a very small number as there is an assumed delay in when the processor executes the first time.time() computation and the next. however, when running this same execution and comparing it to a variable computed in the same way, the results are skewed in one direction...see the small code snippet below..this also holds true for very large data sets..import time..counts = 300000..def at_once():.  first = 0.  second = 0.  x = 0.  while x &lt; counts:.      x += 1.      exec_first = time.time() - time.time().      exec_second = time.time() - time.time()..      if exec_first &gt; exec_second:.          first += 1.      else:.          second += 1...print('1sts: %s' % first).print('2nds: %s' % second)...prints:..1sts: 39630.2nds: 260370...unless i have my logic incorrect, i would expect the results to very close to 50:50, but it does not seem to be the case. is there anyone who could explain what causes this behavior or point out a potential flaw with the code logic that is making the results skewed in one direction?"
