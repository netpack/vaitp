"math domain error in blank this program works for the value of the variable ""n"" set to 4, as it's the case in the following code:..from __future__ import division.from numpy import zeros.import numpy as np.import matplotlib.pyplot as plt..from numpy.linalg import linalg.import math...def geta(kappa):.    matrix = zeros((n, n), float).    for i in range(n):.        for j in range(n):.            matrix[i][j] = 2*math.cos((2*math.pi/n)*(abs(j-i))*kappa).    return matrix...def getf(csi, a):.    csiinv = linalg.inv(csi).    valuef = np.dot(csiinv, a).    valuef = np.dot(valuef, csiinv).    valuef = np.dot(valuef, a).    tracef = valuef.trace().    return 0.5 * tracef...def getg(csi, f, a):.    csiinv = linalg.inv(csi).    valueg = np.dot(csiinv, a).    valueg = np.dot(valueg, csiinv).    valueg = valueg / (2 * f).    return valueg...def gete(g, k):.    #m = 10 ^ -6.    #kinv = linalg.inv(k + np.eye(k.shape[1])*m).    kinv = linalg.inv(k).    #kinv = linalg.pinv(k).    ktrans = k.transpose().    #ktransinv = linalg.pinv(ktrans).    #ktransinv = linalg.inv(ktrans + np.eye(ktrans.shape[1])*m).    ktransinv = linalg.inv(ktrans).    e = np.dot(ktransinv,g).    e = np.dot(e, kinv).    return e..def getw(k, a, e):.    ktrans = k.transpose().    w = np.dot(k, a).    w = np.dot(w, ktrans).    w = np.dot(w, e).    valuew = w.trace().    return valuew..def getv(csi, e, e2, k):.    v = np.dot(csi, k).    v = np.dot(v, e).    v = np.dot(v, k).    v = np.dot(v, csi).    v = np.dot(v,  k).    v = np.dot(v, e2).    v = np.dot(v, k).    tracev = v.trace().    return tracev...handle_2 = open(""test.txt"", ""w"")..n = 4...power_spectrum_k = np.zeros(n, float).for i in range(n):.    power = math.exp(-(2*math.pi*i/n)*(2*math.pi*i/n)).    power_spectrum_k[i] = power..# ora posso chiamare l'anti-trasformata.inverse_transform = np.fft.ifft(power_spectrum_k).print 'inverse_transform:', inverse_transform.csi = zeros((n, n)).for i in range(n):.    for j in range(n):.        csi[i][j] = inverse_transform[abs(i-j)]...betaarray = zeros(n, float).wabarray = zeros((6, n), float).correlation = zeros((6, 6), float)..list = [1, 2, 3, 4, 5, 6]..k = zeros((n, n), float).for i in range(n):.    for j in range(i+1):.        i_shifted = i + 2.        j_shifted = j + 1.        print ""###############################"".        print i_shifted.        print j..        component1 = ((3.0*70.0*70.0*0.3)/(2.0*300000.0*300000.0)).        component2 = ((j_shifted*(i_shifted-j_shifted))/(i_shifted)).        component3 = (1.0+(70.0/300000.0)*j_shifted)..        print component1.        print component2.        print component3..        k[i][j] = component1*component2*component3..#print 'detk:', np.linalg.det(k).print 'k:n', k..counter = 0..for alpha in list:.    counter2 = 0.    aa = geta(alpha).    faa = getf(csi, aa).    ga = getg(csi, faa, aa).    ea = gete(ga, k).    #print 'ea:', ea.    v_alphaalpha = getv(csi, ea, ea, k).    for beta in xrange(n):.            ab = geta(beta + 1).            #print ""calling getw with k="", k, ""n ab="", ab, ""nea="", ea.            w_ab = getw(k, ab, ea).            #print ""ngot w_ab="", w_ab.            betaarray[beta] = beta + 1.            wabarray[counter][beta] = w_ab.            output_string = "" {0} {1} n"".format(str(beta + 1), str(w_ab)).            handle_2.write(output_string).            fbb = getf(csi, ab).            gb = getg(csi, fbb, ab).            eb = gete(gb, k).    #print ""beta array"".    #print betaarray.    #print ""wab array"".    #print wabarray.    for gamma in list:.        ac = geta(gamma).        fcc = getf(csi, ac).        gc = getg(csi, fcc, ac).        ec = gete(gc, k).        v_alphagamma = getv(csi, ea, ec, k).        v_gammagamma = getv(csi, ec, ec, k).        c_alphagamma = v_alphagamma/(math.sqrt(v_alphaalpha * v_gammagamma)).        correlation[counter][counter2] = c_alphagamma.        counter2 = counter2 + 1.    counter = counter + 1...print 'correlation:n', correlation.wabarray_all = [].betaarray_all = [].for b in range(0, len(wabarray), 1):.  for n in betaarray:.    betaarray_all.append(n).  for n in wabarray[b]:.    wabarray_all.append(n)...now, as soon as i get n = 5 and any other value bigger than 4, i receive the error: ..line 148, in &lt;module&gt;.    c_alphagamma = v_alphagamma/(math.sqrt(v_alphaalpha * v_gammagamma)).valueerror: math domain error...which i interpret as a math error due to the fact that i performing the square root of a negative value. nevertheless, i cannot understand where exactly is the error, in the sense that i cannot understand why changing from 4 to, say, 5 makes the difference. has anyone any idea of what is going wrong?"
