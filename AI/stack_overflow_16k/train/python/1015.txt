"implementation of agent based model i'm trying to implement an agent based model in blank (without using the mesa package) as practice. i've written code that describes an observer (containing all the agents) which can help the neighbour agents and tells each agent to do a step. the step is saved in a new list before its copied to a list containing the previous situation...the agents (domain models essentially) are either of the type: 't' (tree), 's' (soil), 'b' (burning tree) and 'bd' (burned tree)...the concept is simple: we start with a number of trees, a number of burning trees and the rest is soil..- soil doesn't burn..- trees that have been burned remain burned trees.- burning trees ignite the trees directly next to it (left, right, up or down) and become burned trees in the next step.- trees remain trees unless they get ignited by a neighbouring burning tree...below the code for this. i've had a few versions but none seem to work. when i run the below version i get an error. ..import os.import sys.from copy import deepcopy.import random..# observer class.class obs:.    def __init__(self, max_iters=10):.        self.agents = [].        self.max_iters = max_iters..    def run(self):.        self.history = [].        self.prev_agents = none.        self.iters = 0..        while self.iters &lt; self.max_iters:.            print(self.iters).            self.history.append(deepcopy(self.agents)).            self.prev_agents = deepcopy(self.agents).            for agent in self.prev_agents:.                agent.step().            self.iters += 1..    def add_agent(self, x, y, agent_type, num_agent):.        self.agents.append(.            agent(.                agent_type=agent_type,.                x=x,.                y=y,.                observer=self,.                agent_id=num_agent.            ))..    def get_neighbours(self, x, y):.        # items do not move so use current_situation.        nbs = [].        for agent in self.agents:.            if (abs(agent.x-x) == 1) &amp; (abs(agent.y-y) == 1) &amp; (abs(agent.x-x) == abs(agent.y-y)):.                nbs.append(agent).        return nbs..    def set_agent(self, index, agent):.        self.agents[index] = agent..    def changed(self, agent_id):.        if self.prev_agents[agent_id].agent_type != self.agents[agent_id].agent_type:.            # been changed, can't change it back so skip it.            return true.        return false..class agent:.    def __init__(self, agent_type, x, y, observer, agent_id):.        self.agent_type = agent_type.        self.x = x.        self.y = y.        self.observer = observer.        self.agent_id = agent_id..    def step(self):.        # perform action.        if self.agent_type == 'b':.            # burning.            nbs = self.observer.get_neighbours(self.x, self.y).            for nb in nbs:.                if nb.agent_type == 't':.                    self.observer.set_agent(.                        nb.agent_id,.                        agent('b',.                          nb.x,.                          nb.y,.                          nb.observer,.                          nb.agent_id))..            # set to burned.            self.agent_type = 'bd'.            self.observer.set_agent(.                self.agent_id,.                self).        elif self.agent_type == 't':.            if not self.observer.changed(self.agent_id):.                self.observer.set_agent(.                    self.agent_id,.                    self).        else:.            # nothing happens to soil or burned trees.            self.observer.set_agent(.                    self.agent_id,.                    self)...xsize, ysize = 10, 10.num_trees = 40.num_burning = 10.num_soil = (xsize * ysize) - num_trees - num_burning..items = ['t'] * num_trees + ['b'] * num_burning + ['s'] * num_soil.random.shuffle(items).observer = obs(10)..for i, item in enumerate(items):.    x = i % xsize.    y = i // xsize.    observer.add_agent(x=x, y=y, agent_type=item, num_agent=i)..observer.run()...the error i get:..---------------------------------------------------------------------------.typeerror                                 traceback (most recent call last).&lt;iblank-input-26-74779de210e4&gt; in &lt;module&gt;.    104     observer.add_agent(x=x, y=y, agent_type=item, num_agent=i).    105 .--&gt; 106 observer.run()..&lt;iblank-input-26-74779de210e4&gt; in run(self).     20             self.prev_agents = deepcopy(self.agents).     21             for agent in self.prev_agents:.---&gt; 22                 agent.step().     23             self.iters += 1.     24 ..&lt;iblank-input-26-74779de210e4&gt; in step(self).     79                 self).     80         elif self.agent_type == 't':.---&gt; 81             if not self.observer.changed(self.agent_id):.     82                 self.observer.set_agent(.     83                     self.agent_id,..&lt;iblank-input-26-74779de210e4&gt; in changed(self, agent_id).     45 .     46     def changed(self, agent_id):.---&gt; 47         if self.prev_agents[agent_id].agent_type != self.agents[agent_id].agent_type:.     48             # been changed, can't change it back so skip it.     49             return true..typeerror: 'nonetype' object is not subscriptable"
