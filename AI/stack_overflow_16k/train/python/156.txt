"voltage and current rms calculations blank im doing som calculations for voltage and current rms values, and just got a new way to do it with more precision. .it works well for what it was designed for, full period values, but it doesnÂ´t work for half period values...spp = 200, and the input is an array with nx200 values, (period by period)...so i get full 230 v  when i do the full period version, but only get around 100 v from the half period version..full period calculations:..k = np.arange(spp) # .v_samples = np.vstack((np.zeros(spp), data_u_periods)).#print (""v_samples"", v_samples).v_samples = np.diff(v_samples, axis=0).#print (""v_samples :"", v_samples)..v_cossum = np.cumsum(v_samples * np.cos(2*np.pi/spp*k)) * np.sqrt(2)/spp.v_sinsum = np.cumsum(v_samples * np.sin(2*np.pi/spp*k)) * np.sqrt(2)/spp.print (""fp"", 2*np.pi/spp*k).v_complex = v_cossum + 1j*v_sinsum.v_complex = np.mean(v_complex.reshape((-1,spp)), axis=1)..i_samples = np.vstack((np.zeros(spp), data_i_periods)).i_samples = np.diff(i_samples, axis=0)..i_cossum = np.cumsum(i_samples * np.cos(2*np.pi/spp*k)) * np.sqrt(2)/spp.i_sinsum = np.cumsum(i_samples * np.sin(2*np.pi/spp*k)) * np.sqrt(2)/spp..i_complex = i_cossum + 1j*i_sinsum.i_complex = np.mean(i_complex.reshape((-1,spp)), axis=1).s_complex = v_complex * i_complex.conjugate() # save for power calculations..ueffs = np.abs(v_complex).ieffs = np.abs(i_complex)..half period calculations:.data_u_periods = data_u_periods.flatten().data_i_periods = data_i_periods.flatten().data_u_periods = data_u_periods.reshape((int(data_u_periods.shape[0]/(int(spp/2))),int(spp/2))).data_i_periods = data_i_periods.reshape((int(data_i_periods.shape[0]/(int(spp/2))),int(spp/2)))..spp = spp/2.k = np.arange(spp) # .#print(spp).#print (k).#print (data_u_periods.shape).v_samples = np.vstack((np.zeros(spp), data_u_periods)).#print (""v_samples"", v_samples).v_samples = np.diff(v_samples, axis=0).#print (""v_samples :"", v_samples).#input(""press enter"").v_cossum = np.cumsum(v_samples * np.cos(2*np.pi/spp*k)) * np.sqrt(2)/spp.v_sinsum = np.cumsum(v_samples * np.sin(2*np.pi/spp*k)) * np.sqrt(2)/spp..v_complex = v_cossum + 1j*v_sinsum.v_complex = np.mean(v_complex.reshape((-1,spp)), axis=1)..i_samples = np.vstack((np.zeros(spp), data_i_periods)).i_samples = np.diff(i_samples, axis=0)..i_cossum = np.cumsum(i_samples * np.cos(2*np.pi/spp*k)) * np.sqrt(2)/spp.i_sinsum = np.cumsum(i_samples * np.sin(2*np.pi/spp*k)) * np.sqrt(2)/spp..i_complex = i_cossum + 1j*i_sinsum.i_complex = np.mean(i_complex.reshape((-1,spp)), axis=1).#s_complex = v_complex * i_complex.conjugate() # save for power calculations.print (""hp"", 2*np.pi/spp*k).ueffs = np.abs(v_complex).ieffs = np.abs(i_complex)"
