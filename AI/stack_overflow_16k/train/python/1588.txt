"can i efficiently swap two class instances by swapping __dict__? i have a big class with lots of members, and quite a few references to instances of this class lying around. unfortunately (for reasonable reasons) all these references are the wrong way around...instead of re-creating each (and finding and updating everywhere the objects are referenced), or adding an extra level of indirection each time i access this class, or individually swapping members, i have defined a method:..def swap(self, other):.    assert(isinstance(other, self.__class__)).    self.__dict__, other.__dict__ = other.__dict__, self.__dict__...so i can do:..instance_a.swap(instance_b).# now all references to instance_a everywhere are as if instance_a is instance_b...the question:.it seems to work fine (i don't use __slots__), but it feels like there might be a reason i shouldn't do this, is there?....here's my actual use case:..i have a type that implements comparison operators in a (necessarily) expensive way. i have various sorted data-structures containing objects of this type...when i do something to one of the objects, i know that the comparison order has changed, and that order in my data structures (all of them!) can be restored by swapping the modified object with the 'next bigger' one."
