"how do you tell whether sys.stdin.readline() is going to block? how can i find out whether a call to sys.stdin.readline() (or, more generally, readline() on any file descriptor based file object) is going to block?..this comes up when i am writing a line-based text filter program in blank;.that is, the program repeatedly reads a line of text from input, maybe transforms it, and then writes it to output...i'd like to implement a reasonable output buffering strategy..my criteria are:...it should be efficient when processing millions of.lines in bulk-- mostly buffer the output, with occasional flushes..it should never block on input while holding buffered output....so, unbuffered output is no good, because it violates (1) (too many writes to the os)..and line-buffered output is no good, because it still violates (1).(it doesn't make sense to flush the output to the os on each of a million lines in bulk)..and default-buffered output is no good, because it violates (2) (it will withhold output inappropriately if output is to a file or pipe)...i think a good solution, for most cases, would be:.""flush sys.stdout whenever (its buffer is full or) sys.stdin.readline() is about to block""..can that be implemented?..(note, i don't claim this strategy is perfect for all cases.  for example,.it's probably not ideal in cases where the program is cpu-bound; in that case it may be wise.to flush more often, to avoid withholding output while doing long computations.)..for definitiveness, let's say i'm implementing unix's ""cat -n"" program in blank...(actually ""cat -n"" is smarter than line-at-a-time; that is, it knows how.to read and write part of a line before the full line has been read;.but, for this example, i'm going to implement it line-at-a-time anyway.)..line-buffered implementation..(well-behaved, but violates criterion (1), i.e. it's unreasonably slow since it flushes too much):..#!/usr/bin/blank.# cat-n.linebuffered.py.import sys.num_lines_read = 0.while true:.  line = sys.stdin.readline().  if line == '': break.  num_lines_read += 1.  print(""%d: %s"" % (num_lines_read, line)).  sys.stdout.flush()...default-buffered implementation..(fast but violates criterion (2), i.e. unfriendly output withholding)..#!/usr/bin/blank.# cat-n.defaultbuffered.py.import sys.num_lines_read = 0.while true:.  line = sys.stdin.readline().  if line == '': break.  num_lines_read += 1.  print(""%d: %s"" % (num_lines_read, line))...desired implementation:..#!/usr/bin/blank.num_lines_read = 0.while true:.  if sys_stdin_readline_is_about_to_block():  # &lt;--- how do i implement this??.    sys.stdout.flush().  line = sys.stdin.readline().  if line == '': break.  num_lines_read += 1.  print(""%d: %s"" % (num_lines_read, line))...so the question is: is it possible to implement sys_stdin_readline_is_about_to_block()?..i'd like an answer that works in both blank2 and blank3..i've looked into each of the following techniques, but nothing has panned out so far....use select([sys.stdin],[],[],0) to find out whether reading from sys.stdin will block.  (this does not work when sys.stdin is a buffered file object, for at least one and possibly two reasons: (1) it will wrongly say ""will not block"" if a partial line is ready to read from the underlying input pipe, (2) it will wrongly say ""will block"" if sys.stdin's buffer contains a full input line but the underlying pipe is not ready for additional reading... i think)..non-blocking io, using os.fdopen(sys.stdin.fileno(), 'r') and fcntl with o_nonblock.(i could not get this to work with readline() in any blank version:.in blank2.7, it loses input whenever a partial line comes in;.in blank3, it seems to be impossible to distinguish between ""would block"".and end-of-input. ??).asyncio (it's not clear to me what of this is available in blank2; and i don't think it works with sys.stdin; however, i'd still be interested in an answer that worked only when reading from a pipe returned from subprocess.popen())..create a thread to do the readline() loop and pass each line to the main.program via a queue.queue; then the main program can poll the queue before.reading each line from it, and whenever it sees it's about to block, flush stdout first..(i tried this, and actually got it working, see below, but it's horribly slow, much slower than line buffering.)...threaded implementation:..note that this doesn't strictly answer the question ""how to tell whether sys.stdin.readline() is going to block"", but it manages to implement the desired buffering strategy anyway.  it's too slow, though...#!/usr/bin/blank.# cat-n.threaded.py.import queue.import sys.import threading.def iter_with_abouttoblock_cb(callable, sentinel, abouttoblock_cb, qsize=100):.  # child will send each item through q to parent..  q = queue.queue(qsize).  def child_fun():.    for item in iter(callable, sentinel):.      q.put(item).    q.put(sentinel).  child = threading.thread(target=child_fun).  # the child thread normally runs until it sees the sentinel,.  # but we mark it daemon so that it won't prevent the parent.  # from exiting prematurely if it wants..  child.daemon = true.  child.start().  while true:.    try:.      item = q.get(block=false).    except queue.empty:.      # q is empty; call abouttoblock_cb before blocking.      abouttoblock_cb().      item = q.get(block=true).    if item == sentinel:.      break  # do *not* yield sentinel.    yield item.  child.join()..num_lines_read = 0.for line in iter_with_abouttoblock_cb(sys.stdin.readline,.                                      sentinel='',.                                      abouttoblock_cb=sys.stdout.flush):.  num_lines_read += 1.  sys.stdout.write(""%d: %s"" % (num_lines_read, line))...verifying buffering behavior:..the following commands (in bash on linux) show the expected buffering behavior: ""defaultbuffered"" buffers too aggressively, whereas ""linebuffered"" and ""threaded"" buffer just right...(note that the | cat at the end of the pipeline is to make blank block-buffer instead of line-buffer by default.)..for which in defaultbuffered linebuffered threaded; do.  for blank in blank2.7 blank3.5; do.    echo ""$blank cat-n.$which.py:"".      (echo z; echo -n a; sleep 1; echo b; sleep 1; echo -n c; sleep 1; echo d; echo x; echo y; echo z; sleep 1; echo -n e; sleep 1; echo f) | $blank cat-n.$which.py | cat.  done.done...output:..blank2.7 cat-n.defaultbuffered.py:.[... pauses 5 seconds here. bad! ...].1: z.2: ab.3: cd.4: x.5: y.6: z.7: ef.blank3.5 cat-n.defaultbuffered.py:.[same].blank2.7 cat-n.linebuffered.py:.1: z.[... pauses 1 second here, as expected ...].2: ab.[... pauses 2 seconds here, as expected ...].3: cd.4: x.5: y.6: z.[... pauses 2 seconds here, as expected ...].6: ef.blank3.5 cat-n.linebuffered.py:.[same].blank2.7 cat-n.threaded.py:.[same].blank3.5 cat-n.threaded.py:.[same]...timings:..(in bash on linux):..for which in defaultbuffered linebuffered threaded; do.  for blank in blank2.7 blank3.5; do.    echo -n ""$blank cat-n.$which.py:  "".      timings=$(time (yes 01234567890123456789012345678901234567890123456789012345678901234567890123456789 | head -1000000 | $blank cat-n.$which.py &gt;| /tmp/remove_me) 2&gt;&amp;1).      echo $timings.  done.done./bin/rm /tmp/remove_me...output:..blank2.7 cat-n.defaultbuffered.py:  real 0m1.490s user 0m1.191s sys 0m0.386s.blank3.5 cat-n.defaultbuffered.py:  real 0m1.633s user 0m1.007s sys 0m0.311s.blank2.7 cat-n.linebuffered.py:  real 0m5.248s user 0m2.198s sys 0m2.704s.blank3.5 cat-n.linebuffered.py:  real 0m6.462s user 0m3.038s sys 0m3.224s.blank2.7 cat-n.threaded.py:  real 0m25.097s user 0m18.392s sys 0m16.483s.blank3.5 cat-n.threaded.py:  real 0m12.655s user 0m11.722s sys 0m1.540s...to reiterate, i'd like a solution that never blocks while holding buffered output.(both ""linebuffered"" and ""threaded"" are good in this respect),.and that is also fast: that is, comparable in speed to ""defaultbuffered""."
