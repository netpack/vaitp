"find the leftmost duplicate in bisect search i read binary search algorithm - wikipedia to bisect search the leftmost element of duplicates.the psudocodes:..function binary_search_leftmost(a, n, t):.    l := 0.    r := n.    while l &lt; r:.        m := floor((l + r) / 2).        if a[m] &lt; t:.            l := m + 1.        else:.            r := m.    return l...implement in blank..def search_leftmost(nums: list[int], target: int) -&gt; list[int]:.    if len(nums) &lt; 1: return [-1, -1].    lo = 0.    hi = len(nums).    logging.debug(f""nums:{list(enumerate(nums))}, target: {target}"").    while lo &lt; hi: .        mid = (lo+hi) // 2.        logging.debug(f""lo:{lo} mid:{mid} hi:{hi}"").        if target &gt; nums[lo]:.            lo = mid + 1.        else:.            hi = mid .    logging.debug(f""lo: {lo}"").    return lo...unfortunately, when test with nums = [5,7,7,8,8,8,8,10]; target = 8..$ blank 0.bi_search.py .debug nums:[(0, 5), (1, 7), (2, 7), (3, 8), (4, 8), (5, 8), (6, 8), (7, 10)], target: 8.debug lo:0 mid:4 hi:8.debug lo:5 mid:6 hi:8.debug lo:5 mid:5 hi:6.debug lo: 5...it return 5 which is neither leftmost or rightmost. ..what's the problem with my implementation?"
