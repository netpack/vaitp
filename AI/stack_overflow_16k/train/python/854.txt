"blank multiprocessing variables how could i use data obtained(a variable) from a process in another process of the same project ? for example from the code below i want to use variable ""b"" in an interface for plotting and analysing that. thanks!..import time.import multiprocessing.import time.import os.import sys.import matplotlib.animation as animation.import time.import libtiepie.import numpy as np.import matplotlib.pyplot as plt.from copy import deepcopy.from printinfo import *.from math import*.import pylab.import tkinter as tk.import matplotlib.animation as animation.from tkinter import*.from tkinter import ttk.from matplotlib.backends.backend_tkagg import figurecanvastkagg, navigationtoolbar2tkagg.from matplotlib.figure import figure.from matplotlib.animation import funcanimation..def calc_square():..    k=0.    fig=plt.figure().    while k&lt;3000:..        # print library info:.        print_library_info()..        # search for devices:.        libtiepie.device_list.update()..        # try to open an oscilloscope with block measurement support:.        scp = none.        for item in libtiepie.device_list:.            if item.can_open(libtiepie.devicetype_oscilloscope):.                scp = item.open_oscilloscope().                if scp.measure_modes &amp; libtiepie.mm_block:.                    break.                else:.                    scp = none..        if scp:.            try:..                    # set measure mode:.                    scp.measure_mode = libtiepie.mm_block..                    # set sample frequency:.                    scp.sample_frequency = 5e6  # 1 mhz..                    # set record length:.                    scp.record_length = 1000  # 15000 samples..                    # set pre sample ratio:.                    scp.pre_sample_ratio = 0.1  # 0 %..                    # for all channels:.                    for ch in scp.channels:.                        # enable channel to measure it:.                        ch.enabled = true..                        # set range:.                        ch.range = 8  # 8 v..                        # set coupling:.                        ch.coupling = libtiepie.ck_acv  # dc volt..                    # set trigger timeout:.                    scp.trigger_time_out = 100e-3  # 100 ms..                    # disable all channel trigger sources:.                    for ch in scp.channels:.                        ch.trigger.enabled = false..                    # setup channel trigger:.                    ch = scp.channels[0]  # ch 1..                    # enable trigger source:.                    ch.trigger.enabled = true..                    # kind:.                    ch.trigger.kind = libtiepie.tk_risingedge  # rising edge..                    # level:.                    ch.trigger.levels[0] = 0.75  # 50 %..                    # hysteresis:.                    ch.trigger.hystereses[0] = 0.1  # 5 %..                    # print oscilloscope info:.                    #print_device_info(scp)..                    # start measurement:.                    scp.start()..                    # wait for measurement to complete:.                    while not scp.is_data_ready:.                        time.sleep(0.01)  # 10 ms delay, to save cpu time..                    # get data:.                    data = scp.get_data()..                    ax = fig.add_subplot(111).                    t = np.linspace(0, (scp.record_length/scp.sample_frequency)*1000, scp.record_length).                    a=deepcopy(data).                    a=np.transpose(a).                    b=a[:,0].                    #ax.plot(t,b).                    #plt.ion().                    #plt.show().                    #plt.pause(0.001).                    #ax.cla()..            except exception as e:.                print('exception: ' + e.message).                sys.exit(1)..            # close oscilloscope:.            del scp..        else:.            print('no oscilloscope available with block measurement support!').        k=k+1..if __name__ == ""__main__"":..    p1 = multiprocessing.process(target=calc_square)      ..    p1.start().    # p2.start().    p1.join().    # p2.join()"
