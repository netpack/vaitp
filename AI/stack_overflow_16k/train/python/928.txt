"chaining comparisons (overloading the not overloadable ""and"" operator) i'm asking for suggestions on how to get ""close"" to overloading the and operator.  a code example to hint at what i'm doing:..import operator...op = { operator.ge: ""&gt;="", operator.le: ""&lt;="" }...class expression(object):.    def __init__(self, left, right, op):.        self.left = left.        self.right = right.        self.op = op..    def __le__(self, other):.        return expression(self, other, operator.le)..    def __ge__(self, other):.        return expression(self, other, operator.ge)..    def __str__(self):.        return ""(%s %s %s)"" % (self.left, op[self.op], self.right)..    def __repr__(self):.        return ""&lt;expression: %s %s %s&gt;"" % (self.left, self.op, self.right)...class variable(expression):.    def __init__(self, name):.        self.name = name..    def __str__(self):.        return self.name..    def __repr__(self):.        return ""&lt;variable: %s&gt;"" % self.name...def _and(left, right):.    return (left, right)..print 1 &lt;= variable(""x"") &lt;= 3.print _and(1 &lt;= variable(""x""), variable(""x"") &lt;= 3)...the above example prints:...(x &lt;= 3).(&lt;expression: x &lt;built-in function ge&gt; 1&gt;, &lt;expression: x &lt;built-in function le&gt; 3&gt;)...according to the blank docs an expression 1 &lt;= a &lt;= 2 translates to 1 &lt;= a and a &lt;= 2, so i'm guessing that in my example 1 &lt;= variable(""x"") evaluates to true so the expression returns the value of variable(""x"") &lt;= 3.  i need a way to get both expressions (1 &lt;= a, and a &lt;= 2) separately, and preferably without writing out the middle expression twice (like i did with the _and function), since the middle expression could be quite complex and bothersome to have twice (i realize i could save it to a variable and use it, but this is also less readable).  according to this se post the and operator can't be overloaded, so what i'm asking is whether this can be done, and then how, or if i have to resort to splitting the comparison in two (specifying the middle expression twice).  any suggestions in the right direction are appreciated!  thank you...possibly related:...chained comparisons in sqlalchemy...edit:.so what i'm essentially doing is writing out constraints for a linear program, so relevant parts of my code currently look something like this:..model.add_constr(a &lt;= b).model.add_constr(b &lt;= c).# now i could alter add_constr to support either a tuple or two arguments enabling:.model.add_constr(a &lt;= b, b &lt;= c).model.add_constr((a &lt;= b, b &lt;= c)).# but most pleasing would be if i could do .model.add_constr(a &lt;= b &lt;= c).# that would return for example a two tuple that could be interpreted appropriately by .# add_constr()"
