"how to predict a testing dataset using a training dataset using blank ive been conducting a sentiment analysis with blank to do a machine learning model comparison. i have a training dataset of manually labeled sentiments of -1, 0, 1 representing negative, neutral and positive.  and have been using train_test_split to split my training dataset into a testing and training one. im just wondering how can i use  the training data to predict a separate test dataset? everything i found online uses sklearn train_test_split. ..import pandas as pd.df = pd.read_csv('consumer_complaints.csv').df.head()...df = df[pd.notnull(df['text'])].col = ['sentiment', 'text'].df = df[col]..df.columns = ['sentiment', 'text'].df['category_id'] = df['sentiment'].factorize()[0].from io import stringio.category_id_df = df[['sentiment',   'category_id']].drop_duplicates().sort_values('category_id').category_to_id = dict(category_id_df.values).id_to_category = dict(category_id_df[['category_id', 'sentiment']].values)..import matplotlib.pyplot as plt.fig = plt.figure(figsize=(8,6)).df.groupby('sentiment').text.count().plot.bar(ylim=0).plt.show()..from sklearn.feature_extraction.text import tfidfvectorizer..tfidf = tfidfvectorizer(sublinear_tf=true, min_df=5, norm='l2', encoding='latin-1', ngram_range=(1, 2), stop_words='english')..features = tfidf.fit_transform(df.text).toarray().labels = df.category_id.features.shape..from sklearn.feature_selection import chi2.import numpy as np..n = 2.for sentiment, category_id in sorted(category_to_id.items()):.  features_chi2 = chi2(features, labels == category_id).  indices = np.argsort(features_chi2[0]).  feature_names = np.array(tfidf.get_feature_names())[indices].  unigrams = [v for v in feature_names if len(v.split(' ')) == 1].  bigrams = [v for v in feature_names if len(v.split(' ')) == 2].  print(""# '{}':"".format(sentiment)).  print(""  . most correlated unigrams:n       . {}"".format('n       . '.join(unigrams[-n:]))).  print(""  . most correlated bigrams:n       . {}"".format('n       . '.join(bigrams[-n:])))..from sklearn.model_selection import train_test_split.from sklearn.feature_extraction.text import countvectorizer.from sklearn.feature_extraction.text import tfidftransformer.from sklearn.naive_bayes import multinomialnb..x_train, x_test, y_train, y_test = train_test_split(df['text'], df['sentiment'], random_state = 0).count_vect = countvectorizer().x_train_counts = count_vect.fit_transform(x_train).tfidf_transformer = tfidftransformer().x_train_tfidf = tfidf_transformer.fit_transform(x_train_counts)...from sklearn.linear_model import logisticregression.from sklearn.ensemble import randomforestclassifier.from sklearn.naive_bayes import multinomialnb.from sklearn.svm import linearsvc..from sklearn.model_selection import cross_val_score...models = [.    randomforestclassifier(n_estimators=200, max_depth=3, random_state=0),.    linearsvc(),.    multinomialnb(),.    logisticregression(random_state=0),.]...cv = 5.cv_df = pd.dataframe(index=range(cv * len(models))).entries = [].for model in models:.  model_name = model.__class__.__name__.  accuracies = cross_val_score(model, features, labels, scoring='accuracy', cv=cv).  for fold_idx, accuracy in enumerate(accuracies):.    entries.append((model_name, fold_idx, accuracy)).cv_df = pd.dataframe(entries, columns=['model_name', 'fold_idx',  'accuracy'])..import seaborn as sns..sns.boxplot(x='model_name', y='accuracy', data=cv_df).sns.stripplot(x='model_name', y='accuracy', data=cv_df, .          size=8, jitter=true, edgecolor=""gray"", linewidth=2).plt.show()..cv_df.groupby('model_name').accuracy.mean()..from sklearn.model_selection import train_test_split..model = linearsvc()..x_train, x_test, y_train, y_test, indices_train, indices_test =    train_test_split(features, labels, df.index, test_size=0.33, random_state=0).model.fit(x_train, y_train).y_pred = model.predict(x_test)...from sklearn.metrics import confusion_matrix..conf_mat = confusion_matrix(y_test, y_pred).fig, ax = plt.subplots(figsize=(8,6)).sns.heatmap(conf_mat, annot=true, fmt='d',   xticklabels=category_id_df.sentiment.values,      yticklabels=category_id_df.sentiment.values).plt.ylabel('actual').plt.xlabel('predicted').plt.show()..from sklearn import metrics.print(metrics.classification_report(y_test, y_pred,                                         target_names=df['sentiment'].unique()))"
