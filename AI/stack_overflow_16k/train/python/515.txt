"get full module path to class i'm using a wrapper to dock a qt window in a program. the issue is the wrapper takes any window class as a str, then initialises it later, making it not very blankic if you have split things over multiple files (see the original edit for an idea of how it works, not important to the question though)...for example:..import module.submodule.mainwindow: the path is ""module.submodule.mainwindow""..import module.submodule.mainwindow as mw: the path is ""mw""..from module import submodule: the path is ""submodule.mainwindow""..my current workaround is module.mainwindow.shpw(namespace=""module.mainwindow""), but i would prefer not to be required to provide it as an argument..i tried making a function to parse globals() to find the path, and it does work quite nicely at the top level. however, i found out that globals() is unique to each import, so it does nothing when called from within my template class...from types import moduletype.import inspect.import site..site_packages_loc = site.getsitepackages()..default_modules = set([sys.modules[i] for i in set(sys.modules.keys()) &amp; set(sys.builtin_module_names)])..def get_class_namespace(search, globals_dict=none, path=[]):.    if globals_dict is none:.        globals_dict = globals()..    #find all objects that are modules.    modules = {}.    for k, v in globals_dict.iteritems():.        if v == search:.            return '.'.join(path + [v.__name__]).        if isinstance(v, moduletype) and v not in default_modules:.            modules[k] = v..    #check recursively in each module.    for k, v in modules.items():..        #check it's not a built in module.        module_path = inspect.getsourcefile(v).        if any(module_path.startswith(i) for i in site_packages_loc):.            continue..        module_globals = {func: getattr(v, func) for func in dir(v)}.        return_val = get_class_namespace(search, module_globals, path=path+[k]).        if return_val is not none:.            return return_val...is there a better way to go about this, or could i somehow request the very top level globals() from within an import?"
