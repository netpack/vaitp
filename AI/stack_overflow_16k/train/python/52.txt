"blank - recursively create a nested dictionary from a list of other dictionaries i have the following list: ..[.{('pct',): ([], '0.750000008089')}, .{(u'gp',): ('balance', '')}, .{(u'uk', u'uz', u'uf', u'us', u'zu'): ([], '')}, .{(u'uk', u'uz'): ('balance', '')}, .{(u'uf', u'us', u'zu'): ([], '')}, .{(u'uf', u'us'): ('pro rata', '')}, .{(u'zu',): ('zero', '')}, .{(u'uk', u'uz'): ('zero', '')}, .{(u'gp',): ('zero', '')}, .{(u'gf',): ('zero', '0.249999991911')}.]...and i would like to create a list of nested dictionaries as follows: ..[.{('pct',): ([], '0.750000008089')}, .{(u'gp',): ('balance', '')}, .{(u'uk', u'uz', u'uf', u'us', u'zu'): ([.    {(u'uk', u'uz'): ('balance', '')},.    {(u'uf', u'us', u'zu'): ([.        {(u'uf', u'us'): ('pro rata', '')}, .        {(u'zu',): ('zero', '')}, .        ], '')},.    {(u'uk', u'uz'): ('zero', '')},.    ], '')},  .{(u'gp',): ('zero', '')}, .{(u'gf',): ('zero', '0.249999991911')}.]...the final result can have any depth.  i've always struggled with recursive functions; i suspect there's a relatively easy way to accomplish this.  i started with this: ..def populate_subrules(full_list, required_classes):.    for each_rule in full_list:.        this_key = each_rule.keys()[0].        if set(this_key).issubset(set(required_classes)) and set(this_key) != set(required_classes):.            if each_rule[this_key][0] != []:.                for idx, found in enumerate(full_list):.                    if found.keys()[0] == required_classes:.                        full_list[idx][required_classes][0].append(each_rule).                        # full_list.remove(each_rule).            else:.                populate_subrules(full_list, this_key).    return full_list...removing values from this list of course doesn't work, and i'm not sure why i'm even returning the full_list.  the final result has two issues: the ""unneeded"" items remain (which is easy enough to remove from the final list), but more importantly, the middle section..{(u'uf', u'us', u'zu'): ([.    {(u'uf', u'us'): ('pro rata', '')}, .    {(u'zu',): ('zero', '')}, .    ], '')},...doesn't get populated inside the bigger section, {(u'uk', u'uz', u'uf', u'us', u'zu')...at this point, i'm thinking of just removing ""unneeded"" items from the list after the ""recursive"" function is ran, and then trying to replace ""uf, us"" and ""zu"" inside {(u'uk', u'uz', u'uf', u'us', u'zu') with (u'uf', u'us', u'zu') and its values, but that's not very recursive and generally pretty dumb...what am i missing in the implementation?"
