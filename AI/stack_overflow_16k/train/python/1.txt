"how to create an infinite loop with apply_async? i havea pool of processes with apply_async in which the different processes take different times to provide output. once one process is finished i do some calculations with their output. after i want to launch another process. in this way i want to create an infinite loop which launches processes, reads the output of the recently finished process, does some calculations and relaunches another process...so far i have been able to do what i want except that the main process gets stuck in the get() function. this because i don't know which process terminated and hence which entry of results i should do get()...some attempt code:..import multiprocessing as mp.import numpy as np.from time import sleep...def squared(x,y):.    result = np.array((x,x)).    if x%2 == 0:.    sleep(2) .return result.....if __name__ == ""__main__"":..    pool = mp.pool() ..    pool_r = [].    for i in xrange(0,8):.        pool_r.append(pool.apply_async(squared, (i,i)))..    count_results = 0..    for j in xrange(0,10):.        result = pool_r[count_results].get().        print result.        count_results += 1.        pool_r.append(pool.apply_async(squared, (j,j)))..    pool.close().    pool.join()...and the output is: .    [0 0].    [1 1].    [2 2].    [3 3].    [4 4].    [5 5].    [6 6].    [7 7].    [0 0].    [1 1]..instead of the odd numbers first and then the even ones (since these ones have a sleep)...any suggestions?....thank you very much for your fast reply abarnert. ..in reality i want to keep an infinite loop after the processes are completed (i need their results to be able to enter the loop). ..q1 - if i create a pool with 30 works can i submit more than 30 processes? will the computer wait for one to finish to put another to work? ..q2 - in your code there is a callback function. however, the code that the i need to run when one worker finishes has to be in the main process since i have to update variables which will be sent to the new processes that i create...q3 - the code that the main process does takes, let say 10% of the time that the processes need to realize their tasks. so is it a good approach to have the main process to realize some calculations and then launch new processes? ..q4 - right now if i ctrl+c the code only terminates when all the processes are over. what can i do to be able to terminate the code as soon as i do ctrl+c? and finally, after my comment do you think futures is still the way to go?..some pseudo-code for what i need:..launch several processes.wait for the results..launch several processes..while true:..    get results from a recently finished process..    do some calculations..    launch two more processes..    # some ending condition"
