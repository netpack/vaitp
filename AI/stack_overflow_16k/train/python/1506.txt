"different instance-method behavior between blank 2.5 and 2.6 trying to change the __unicode__ method on an instance after it's created produces different results on blank 2.5 and 2.6...here's a test script:..class dummy(object):..    def __unicode__(self):.        return u'one'..    def two(self):.        return u'two'..d = dummy().print unicode(d).d.__unicode__ = d.two.print unicode(d).print d.__unicode__()...on blank 2.5, this produces..one.two.two...that is, changing the instance's __unicode__ also changes unicode(instance)..on blank 2.6, this produces..one.one.two...so, after a change, unicode(instance) and instance.__unicode__() return different results...why? how can i get this working on blank 2.6?..(for what it's worth, the use case here is that i want to append something to the output of __unicode__ for all subclasses of a given class, without having to modify the code of the subclasses.)..edit to make the use case a little clearer..i have class a, which has many subclasses. those subclasses define simple __unicode__ methods. i want to add logic so that, for instances of a class a subclass, unicode(instance) gets something tacked on to the end. to keep the code simple, and because there are many subclasses i don't want to change, i'd prefer to avoid editing subclass code...this is actually existing code that works in blank 2.5. it's something like this:..class a(object):..    def __init__(self):.        self._original_unicode = self.__unicode__.        self.__unicode__ = self.augmented_unicode..    def augmented_unicode(self):.        return self._original_unicode() + u' extra'...it's this code that no longer works on 2.6. any suggestions on how to achieve this without modifying subclass code? (if the answer involves metaclasses, note that class a is itself a subclass of another class -- django.db.models.model -- with a pretty elaborate metaclass.)"
