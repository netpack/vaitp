"customize how a blank object is processed as a function argument? a blank class's __call__ method lets us specify how a class member should be behave as a function. can we do the ""opposite"", i.e. specify how a class member should behave as an argument to an arbitrary other function?..as a simple example, suppose i have a listwrapper class that wraps lists, and when i call a function f on a member of this class, i want f to be mapped over the wrapped list. for instance:..x = wrappedlist([1, 2, 3]).print(x + 1) # should be wrappedlist([2, 3, 4])..d = {1: ""a"", 2: ""b"", 3:""c""}.print(d[x]) # should be wrappedlist([""a"", ""b"", ""c""])...calling the hypothetical __call__ analogue i'm looking for __arg__, we could imagine something like this: ..class wrappedlist(object):.    def __init__(self, to_wrap):.        self.wrapped = to_wrap..   def __arg__(self, func):.       return wrappedlist(map(func, self.wrapped))...now, i know that (1) __arg__ doesn't exist in this form, and (2) it's easy to get the behavior in this simple example without any tricks. but is there a way to approximate the behavior i'm looking for in the general case?"
