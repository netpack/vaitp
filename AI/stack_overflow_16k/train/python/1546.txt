"instantiate a subclass from a superclass instance and make it resetable i have a base class a with some heavy attributes (actually large numpy arrays) that are derived from data given to a's __init__() method...first, i would like to subclass a into a new class b to perform modifications on these attributes with some b's specific methods. as these attributes are quite intensive to obtain, i don't want to instantiate b the same way as a but better use an a instance to initialize a b object. this is a type casting between a and b and i think i should use the __new__() method to return a b object...second, before every computations on b's attributes, i must be sure that the initial state of b has been restored to the current state of the instance of a that has been used for b instantiation, without creating a b object every time, a kind of dynamic linkage.....here is an example code i wrote:..from copy import deepcopy.import numpy as np..class a(object):.    def __init__(self, data):.        self.data=data..    def generate_derived_attributes(self):.        print ""generating derived attributes..."".        self.derived_attributes = data.copy()...class b(a):.    def __new__(cls, obj_a):.        assert isinstance(obj_a, a).        cls = deepcopy(obj_a).        cls.__class__ = b.        cls._super_cache = obj_a # this is not a copy... no additional memory required.        return cls..    def compute(self):.        # first reset the state (may use a decorator ?).        self.reset()..        print ""doing some computations...""...    def reset(self):.        print ""nresetting object to its initial state"".        _super_cache = self._super_cache # for not being destroyed....        self.__dict__ = deepcopy(self._super_cache.__dict__).        self._super_cache = _super_cache...if __name__ == '__main__':.    a = a(np.zeros(100000000, dtype=np.float)).    a.generate_derived_attributes().    print a..    b = b(a).    print b..    b.compute()..    b.compute()...is this implementation a kind way to reach my objective with blank or is there more blankic ways... ? could i be more generic ? (i know that using __dict__ will not be a good choice in every cases, especially while using __slots__()...). do you think that using a decorator around b.compute() would give me more flexibility for using this along with other classes ?"
