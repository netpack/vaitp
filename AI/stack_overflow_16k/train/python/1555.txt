"comparing blank dicts with floating point values included i want to compare a pair of dictionaries and using 'fuzzy' floating point comparison or better yet use numpy.allclose() to do so.  however, using the default == or != in blank for dicts doesn't do this...i was wondering if there was a way to change the floating point comparison operation (probably using a context manager for safe cleanup)...i believe an example will help here.  i have a deeply nested dict that contains all sorts of values.  some of these values are floating point values.  i know there are tons of pitfalls for 'comparing' floating point values, etc...d1 = {'a': {'b': 1.123456}}.d2 = {'a': {'b': 1.1234578}}...i would like to use != to compare these two dicts and have it return true if the only differences are floating point numbers within a certain range.  for example, do not count the values different if the are close (not sure the precision i want yet)...i suppose i could recursively go through the dicts myself and manually just use numpy.allclose() for floating point values and fall back to the normal equality testing for all other types, etc.  however, this is a bit tricky and error prone.  i do think this would be an acceptable solution, and i'd love to see one like it.  hopefully there is something more elegant though...the elegant solution in my head would look something like the following.  however, i don't know if anything like this is even possible:..with hacked_float_compare:.    result = d1 != d2...thus, inside this context manager i would be replacing the floating point comparison (just for standard float() values with either my own comparison or numpy.allclose()...again, i'm not sure this is possible because monkey patching float() can't really be done since it's written in c.  i'd also like to avoid having to change every floating point value in the dicts to my own float class that has a __eq__().  maybe this is the best way though?"
