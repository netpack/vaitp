"blank set operations on custom classes - union definition / lookup having a class with overridden __eq__ and __hash__ method i use sets for easy lookups (has also other reasons)...class foo:..    def __init__(self, name, value):.        self.name = name.        self.value = value..    def __eq__(self, other):.        return self.value == other.value..    def __hash__(self):.        return self.value..    def __repr__(self):.        return ""{} {}"".format(self.name, self.value)..mylist = [foo(none, 1), foo(none, 2), foo(none,3)].reference = [foo(""a"", 1), foo(""b"", 2), foo(""c"", 3)]...apparently blank uses the first set when i perform operations like a union for the result set:..print(set(mylist) | set(reference)) # {none 1, none 2, none 3}.print(set(reference) | set(mylist)) # {a 1, b 2, c 3}...i could not find any documentation on this behaviour...is there a formal definition for this?.or is it just undefined which set the interpreter takes on unions?..edit to make it clear:..a union on two sets is mathematically a symmetric operation, the behavior here is not symmetric. can i rely on it?"
