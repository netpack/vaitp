"simple blank issue with dictionaries and iteration i was writing an implementation of the iterated prisoner's dilemma in blank, and am having the following problem...for p in players:.    for o in players:.        if p.name != o.name:.            try:.                p.history[o.name].            except keyerror:.                p.history[o.name] = [].                o.history[p.name] = [].                for i in xrange(0,2):.                    result = play(p.logic(p.history[o.name]),.                                  o.logic(o.history[p.name])).                    p.history[o.name].append(result[0]).                    o.history[p.name].append(result[1])...this is the code i have. the 'players' list is a list of strategy objects which have 'name' a string, and 'logic' a function. the trouble i am having occurs at the lines..p.history[o.name].append(result[0])...i am attempting to create the following dictionaries:..player 1.history = {""player 2 name"": [result, result, result]}.player 2.history = {""player 1 name"": [result, result, result]}...but i get this instead:..player 1.history = {""player 1 name"": [wrong results], .                    ""player 2 name"": [wrong results]}...the results aren't all wrong, but some are. does anyone know why either the results aren't all right or why i have the key ""player 1 name"" in player 1's dictionary and ""player 2 name"" in player 2's dictionary?..edit: some more code on request..class strategy:.    """"""basic class for all strategies to use. the 'logic' function is defined oustide and governs behavior"""""".    def __init__(self, logic, name):.        self.logic = logic.        self.name = name.    history = {}..def makeplayer(name):.    if name == ""defects"":.        def logic(hist):.            return 1.    if name == ""tit for tat"":.        def logic(hist):.            for i in xrange(1,3):.                try:.                    if hist[len(hist) -  i][1] == 1:.                        return 1.                except indexerror:.                    pass.            return 0.    return strategy(logic, name)..payoff = [[100, 0], [101, 1]]..def play(choice1, choice2): #choicefoo = 0 =&gt; cooperate; 1 =&gt; defect.    return [[choice1, choice2, payoff[choice1][choice2]], [choice2, choice1, payoff[choice2][choice1]]]"
