"not sharing object properties in oloo inheritance i'm not sure on the best approach to have object properties that are individual for each object in a oloo inheritance chain...check this fiddle or consider the following code:.http://jsfiddle.net/hb7lu/19413/..parent = {.    array: [],..    add: function(element) {.        this.array.push(element + this.array.length.tostring());.        return this;.    },..    getall: function() {.        return this.array;.    }.};..child = object.create(parent, {.    removeallbutone: { value: function() {.        this.array.splice(1);.        return this;.    }}.});..foo = object.create(parent);.foo.add('foo');..bar = object.create(child);.bar.add('bar');...in the fiddle a click on the foo or bar text will call the foo.add(...) or bar.add(...) function to add an element to the objects array, resulting in one extra &lt;p&gt; tag in the output..the result is not what i want. both foo and bar share the same array. but its easy to understand what happens, if we look up the object inheritance we can see the following:...ok then, what can i do go get around this? there were two options that came to my mind:..option 1).http://jsfiddle.net/hb7lu/19419/..parent = function() {.    return {.        array: [],..        add: function(element) {.            this.array.push(element + this.array.length.tostring());.            return this;.        },..        getall: function() {.            return this.array;.        }.    };.};..child = object.create(parent(), {.    removeallbutone: { value: function() {.        this.array.splice(1);.        return this;.    }}.});..foo = object.create(parent());.foo.add('foo');..bar = object.create(child);.bar.add('bar');...this would create a new parent object, creating all the functions of the parent object each time a parent object is created or a child ""inherits"" from a (new) parent object. while this solves the problem i had, it seems like a bad idea to always recreate the same functions over and over again for each child type object...option 2).http://jsfiddle.net/hb7lu/19420/..parent = object.create({.    add: function(element) {.        this.array.push(element + this.array.length.tostring());.        return this;.    },..    getall: function() {.        return this.array;.    }.}, {.    ctor: { value: function(someargs) {.        this.array = [];.        // maybe use someargs.        return this;.    }}.});..child = object.create(parent, {.    removeallbutone: { value: function() {.        this.array.splice(1);.        return this;.    }}.});..foo = object.create(parent).ctor();.foo.add('foo');..bar = object.create(child).ctor();.bar.add('bar');...this seems to also solve the problem but avoids the recreation of the parent object and its functions. so is this the way to go? what if i had multiple children in the inheritance chain that also have private properties?..something like this?..child = object.create(parent, {.    ctor: { value: function(someargs) {.        this.__proto__.ctor(someargs);.        this.otherprivate = {};.        // maybe use someargs.        return this;.    }},..    removeallbutone: { value: function() {.        this.array.splice(1);.        return this;.    }}.});...children would be shadowing the parent ctor with their own function... but in their ctor function they could call the parents ctor to not break functionality...thoughts and advice is highly appreciated, thanks!"
