"enclosure memory copies function myclass().{.  //lots and lots of vars and code here...   this.bar = function().   {.     //do something with the numerous enclosed myclass vars.   }..   this.foo = function().   {.      alert('hello'); //don't do anything with the enclosed variables..   }.}...each instance of myclass gets its own copy of bar and foo, which is why prototyped methods use less memory. however, i would like to know more about the memory use of inner methods. ..it seems obvious to me that (1) below must be true. do you agree? ...not only do distinct myclass instances have their own distinct copies of bar, but they also must have their own distinct copies of the myclass enclosure. (or else how does the bar method keep the myclass variables straight on a per instance basis?)...now (2) is the question i'm really after....since the inner foo method doesn't use anything in the myclass enclosure a natural qustion is: is blank smart enough to not keep a myclass enclosure in memory for the use of foo?"
