"checking decimal floating point number normally we expect 0.1+0.2===0.3 to be true. but it is not what blank will result. as blank displays decimal floating point number but stores binary floating point number internally. so this returns false...if we use chrome developer tool console, we'll get the following result:..0.1+0.2;//0.30000000000000004..0.1+1-1;//0.10000000000000009...0.1 + 0.2 === 0.3 ;// returns false but we expect to be true..0.1+1-1===0.1;//returns false...due to rounding errors, as a best practice we should not compare non-integers directly. instead, take an upper bound for rounding errors into consideration. such an upper bound is called a machine epsilon...and here is the epsilon method:..var eps = math.pow(2,-53);.function checkeq(x,y){.    return math.abs(x - y) &lt;  eps;.}...now, if we check it returns true...checkeq(0.1+0.2,0.3);// returns true.checkeq(0.1+1-1,0.1);//returns true...it's okay and fine. but if i check this:..checkeq(0.3+0.6,0.9);// returns false...which is not okay and not as what we expect...so, how should we do to return the correct results?....what i've tried to solve this is like this:..var lx,ly,lxi,lyi;.function isfloating(x){.   return x.tostring().indexof('.');.}.function checkeq(x,y){.   lxi = x.tostring().length - x.tostring().indexof('.') - 1;.   lyi = y.tostring().length - y.tostring().indexof('.') - 1;.   lx = isfloating(x) &gt; -1 ? lxi : 0;.   ly = isfloating(y) &gt; -1 ? lyi : 0;.   return x.tofixed(lx) - y.tofixed(ly)===0;.}...now, fixed. and it results fine if i check like this:..checkeq(0.3,0.3); //returns true...but the following returns false ..checkeq(0.3+0.6,0.9)...as here first it's value is stored in binaray floating point number and then returning decimal floating point number after calculating...so now, how can i set tofixed() method for each input like in checkeq(0.3+0.6,0.9) 0.3.tofixed(lx) and 0.6.tofixed(lx) and then only add:..    var lx,ly,lxi,lyi;.    function isfloating(x){.    return x.tostring().indexof('.');.    }.    function checkeq(x,y){.    x = x.tostring().split(/+ | - | / |  | \ */);.    y = x.tostring().split(/+ | - | / |  | \*/);..    for(var i=0;i&lt;x.length,y.length;i++){.    //here too i may be wrong....       lxi = x[i].tostring().length - x[i].tostring().indexof('.') - 1;.       lyi = y[i].tostring().length - y[i].tostring().indexof('.') - 1;.    // particularly after this would wrong....       lx = isfloating(x[i]) &gt; -1 ? lxi : 0; .       ly = isfloating(y[i]) &gt; -1 ? lyi : 0;..    //and, here i'm stucked too badly....    //take splitted operators to calculate:.    //ex- '0.3 + 1 - 1' .    // number('0.3').tofixed(1) + number('1').tofixed(0) - number('1').tofixed(0).    //but careful, we may not know how many input will be there.......    }..//return x.tofixed(lx) - y.tofixed(ly)===0;.}...other answers are also welcome but helping me with my code is greatly appreciated."
