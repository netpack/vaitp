"want the script corrected not to change the size of images i want this script not to change the sizes of the images but the same sizes anywhere they are during sliding. the issue is somewhere in this code but i don't know which one that is changing the size. i want an even size../**.     * given the item and position, this function will calculate the new data.     * for the item. one the calculations are done, it will store that data in.     * the items data object.     */.    function performcalculations($item, newposition) {.      var newdistancefromcenter = math.abs(newposition);..  // distance to the center.  if (newdistancefromcenter &lt; options.flankingitems + 1) {.    var calculations = data.calculations[newdistancefromcenter];.  } else {.    var calculations = data.calculations[options.flankingitems + 1];.  }..  var distancefactor = math.pow(options.sizemultiplier, newdistancefromcenter).  var newwidth = distancefactor * $item.data('original_width');.  var newheight = distancefactor * $item.data('original_height');.  var widthdifference = math.abs($item.width() - newwidth);.  var heightdifference = math.abs($item.height() - newheight);..  var newoffset = calculations.offset.  var newdistance = calculations.distance;.  if (newposition &lt; 0) {.    newdistance *= -1;.  }..  if (options.orientation == 'horizontal') {.    var center = data.containerwidth / 2;.    var newleft = center + newdistance - (newwidth / 2);.    var newtop = options.horizon - newoffset - (newheight / 2);.  } else {.    var center = data.containerheight / 2;.    var newleft = options.horizon - newoffset - (newwidth / 2);.    var newtop = center + newdistance - (newheight / 2);.  }..  var newopacity;.  if (newposition === 0) {.    newopacity = 1;.  } else {.    newopacity = calculations.opacity;.  }..  // depth will be reverse distance from center.  var newdepth = options.flankingitems + 2 - newdistancefromcenter;..  $item.data('width',newwidth);.  $item.data('height',newheight);.  $item.data('top',newtop);.  $item.data('left',newleft);.  $item.data('oldposition',$item.data('currentposition'));.  $item.data('depth',newdepth);.  $item.data('opacity',newopacity);.}..function moveitem($item, newposition) {.  // only want to physically move the item if it is within the boundaries.  // or in the first position just outside either boundary.  if (math.abs(newposition) &lt;= options.flankingitems + 1) {.    performcalculations($item, newposition);..    data.itemsanimating++;..    $item.      .css('z-index',$item.data().depth).      // animate the items to their new position values.      .animate({.        left:    $item.data().left,.        width:   $item.data().width,.        height:  $item.data().height,.        top:     $item.data().top,.        opacity: $item.data().opacity.      }, data.currentspeed, options.animationeasing, function () {.        // animation for the item has completed, call method.        itemanimationcomplete($item, newposition);.      });..  } else {.    $item.data('currentposition', newposition).    // move the item to the 'hidden' position if hasn't been moved yet.    // this is for the intitial setup.    if ($item.data('oldposition') === 0) {.      $item.css({.        'left':    $item.data().left,.        'width':   $item.data().width,.        'height':  $item.data().height,.        'top':     $item.data().top,.        'opacity': $item.data().opacity,.        'z-index': $item.data().depth.      });.    }.  }..}"
