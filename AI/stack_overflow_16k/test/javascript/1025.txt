"remove asynchronous code into callback in $.each() loop in me.getissuesfromreturnslist the uploadlist variable is being returned before the rest of the code executes because it is asynchronous (as per this question)..me.getissuesfromreturnslist = function () {.    var uploadlist = [];.    $.each(me.returnslist(), function (index, i) {.        var issue = issuerepository.getdefaultissue();.        issue.barcode = i.barcode;.        issue.returnsamount(i.amount);..        var uploaditem = {.            barcode: i.barcode,.            amount: i.amount,.            issue: ko.observable(issue).        };..        uploadlist.push(uploaditem);..        issuerepository.getissuesoffline(i.barcode, function (issues) {.            if (issues.length &gt; 0) {.                uploaditem.issue(issues[0]);.            }.        });.    });..    return uploadlist;.}...i want to alter this code so that the calls are no longer asynchronous, and instead waits for all the inner code to execute before returning the uploadlist...i know that i need to add a callback to part of the code so that it will wait for issuerepository.getissuesoffline to finish, but because this is part of a $.each() loop i am really struggling to see where this callback would go...(i have asked this as a new question because the answers given in the suggested duplicate answer are generic examples and don't have a $.each() loop in them)...in the comments below, bergi has asked for the contents of getissuesoffline:..getissuesoffline:..getissuesoffline: function (barcode, callback) {.    var me = this;..    issuedatabase.getissues(barcode, function (issues) {.        me._processissues(issues);..        return callback(issues);.    });.}...issuedatabase.getissues:..getissues: function (barcode, callback) {.    var me = this;.    db.transaction(.        function (context) {.            var query = ""select * from issues where barcode like '"" + barcode + ""%' order by offsaledate desc limit 25"";.            context.executesql(query, [], function (context, result) {.                var issues = [];..                for (var i = 0; i &lt; result.rows.length; i++) {.                    var issue = result.rows.item(i);.                    issue.source = datasources.local;.                    issue.isranged = issue.isranged == 1 ? true : false;.                    issues.push(issue);.                }..                callback(issues);.            }, me.errorhandler);.        }.        , me.errorhandler);.}...me.processissues:.._processissues: function (issues) {.    var me = this;.    $.each(issues, function (index, i) {.        if (i.issuenumber == null) {.            i.issuenumber = '';.        }..        i.issuenumber = i.issuenumber + '';.        i.productnumber = i.productnumber + '';..        if (i.issuenumber.length == 1) {.            i.issuenumber = '0' + i.issuenumber;.        }..        i.barcode = parseint(i.productnumber + '' + i.issuenumber);.        i.status = me.getissuestatus(i);.        i.supplier = me.getissuesupplierdetails(i);.        i.returnsamount = ko.observable(0);.        i.returns = ko.observable({ totes: [] });..            returnsrepository.getreturn(i.barcode, function (r) {.                i.returnsamount(r.amount);..                if (r.amount &gt; 0) {.                    i.returns(r);.                } else {.                    i.returns({ totes: [] });.                }.            });.        };.        i.refreshreturnsamount();..        me.issuedatabase.updateissue(i, function (issue) {.            me.issuedatabase.updateissuelastupdated(issue);.        });.    });.}"
