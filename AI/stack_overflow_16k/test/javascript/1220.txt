"recursively find arbitrary node path in tree i have a tree of objects composed with the following structure:..interface node {.  name: string;.  children?: node[];.}...where, for example, { name: ""foo"", children: [ { name: ""bar"" } ] } is a valid tree. i'm trying to get the address of an arbitrary node, that can be a leaf, returned as an array of the path to arrive it, where the node will be compared by object reference. example given, i have the following structure:..var data = {.  name: ""languages"",.  children: [{.    name: ""functional"",.    children: [.      { name: ""ocaml"" },.      { name: ""haskell"" },.      { name: ""erlang"" }.    ].  }, {.    name: ""imperative"",.    children: [.      { name: ""basic"" },.      { name: ""clipper"" }.    ].  }].};...it is expected that, for example, if i have a reference for ocaml stored in a variable called ocaml that points exactly to that reference in memory, an array of steps be returned with the path to reach it, that would be, in this case, [0, 0]...i already can locate the object, but i'm not able to store the previous index, because this is non-deterministic:..var tree = function(struct, cmp) {.  if (struct.children) {.    var lookup = [];.    for (var i = 0; i &lt; struct.children.length; i++) {.      lookup.push(tree(struct.children[i], cmp));.    }.    return lookup;.  } else {.    if (struct === cmp) {.      return ""pass"";.    }.    return ""fail"";.  }.}...i can find the element, but how can i store the previous indexes to reach it from the base?"
