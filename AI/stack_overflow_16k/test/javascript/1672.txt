"unitialized variables in an array when using only array.push? i've run into a rather interesting problem. the code below generates an array that, when logged, gives the value [undefined × 1]. according to this answer, that means that the array has unitialized indexes--in this case, only one. however, since i'm only using array.push() to avoid exactly this sort of problem, i'm kind of lost. to the best of my knowledge only assigning an index at least one index greater than other initialized indexes could cause the problem. anyhow, here's the code:..function thing(params) {.    var that = this;..    this.otherobject = function otherobject(param) {.        this.param = param;.    }..    this.foo = function foo() {.        this.bar = [];..        this.add = function(item) {.            if (this.bar.length != 0) {.                for (var i = 0, len = this.bar.length; i &lt; len; i++) {.                    if (this.bar[i].param &lt;= item.param) {.                        this.bar.splice(i, 0, item);.                    }.                }.            } else {.                this.bar[0] = item;.                console.log(this.bar);.            }.        }..        this.pop = function() {.            return this.bar.pop();.        }..        this.length = function() {.            return this.bar.length;.        }.    }..    this.somefunc = function() {.        var mything = new that.foo();.        mything.add(new that.otherobject(3));..        while (mything.length() &gt; 0) {.            var somevar = mything.pop();.        }.    }.}..var mything = new thing({.    myparam: ""somevalue"".});..mything.somefunc();.​...i created a test case to see if i could narrow the problem down, but i ended up re-typing 95% of my code until i ran into the issue again, which appears to be related with my use of mything.pop(). you can find a fiddle here which demonstrates the issue in question. ..so... any ideas as to what could be causing this? is this actually a problem with the way i've nested my objects? (which i did following a pattern given to me in this answer to a previous question of mine). ..in case you're wondering what i could possibly be trying to do here, i'm treating the outside object like a sort of namespace, which i'm doing to avoid cluttering up the global namespace (this will eventually be a pathfinding library, if i get my act together here). the foo object is meant to be a sort of ordered list such that i can get the closest node (the one with the lowest param property) by pop()ing the stack."
