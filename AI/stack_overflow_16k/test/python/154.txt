"blank: how to run a function within another function in the same class suppressing the other function output i am coding a class called bivar in that class i have a function called resiplot that plots a figure. however, in that function, i have defined a variable that is known as self.resi. in that particular class, i have another function called hztest. in this function, i am not interested in the plot or the print of the function resiplot. all i need is to make sure that self.resi has been defined. ..therefore, what i am actually looking for is how to define self.resi in the function hztest. i.e. calling the function resiplot supressing its figure or any printed output. ..my code:..from statsmodels.tsa.api import var.import matplotlib.pyplot as plt, subprocess.# calling built-in functions from r.rsummary = robjects.r['summary']..class bivar:..    def __init__(self, df, restrict=0): # initialize when created.        self.data = np.array(df.values, dtype=float) # self is the new object.        self.isrestricted = restrict.        if self.isrestricted ==0:.            self.model= var(self.data).        else:.            p = int(input(""since, you want a restricted model please enter the lag p: "")).            self.p=p.            if p==0: p=1.            t= rvars.var(self.data, p, type='const').            self.model= rvars.restrict(t,method = ""ser"").    def bestlagaic(self):.        if self.isrestricted==1: .            print('sorry this can not be excuted since you chose the model to be restricted').        else:.            r=self.model.select_order(15).            return r['aic'] # split string on blanks.    def fit(self, *parameters, **keyword_parameters):.    # this function allows you to specify the lag variable. if not specified it will use the p value you previously .    # give it for the restricted var model otherwise it will use the best lag based on aic .        if self.isrestricted ==0:.            if len(parameters)==1:.                p=parameters[0].                results = self.model.fit(p).                print(results.summary()).            elif len(parameters)==0:.                p=self.bestlagaic().                results = self.model.fit(p).                print(results.summary()).            else:.                print('you included so many unrequired variables').        else:.            p=self.p.            t= rvars.var(self.data, p, type='const').            t1= rvars.restrict(t, method = ""ser"").            h=str(rsummary(t1)).            start = h.find('var estimation results:') + 23.            end = h.find('roots of the characteristic', start).            pvalue=h[start:end].            start1 = h.find('estimation results for equation') + 31.            pvalue1=h[start1::].            print(pvalue+pvalue1).    def resiplot(self, *parameters):.        # this function plots the residuals when fitted with a var(p) model.        if self.isrestricted ==0:.            if len(parameters)==1:.                p=parameters[0].                results = self.model.fit(p).                resi=results.resid.                self.resi=pd.dataframe(resi, columns=['bond-resi','equity-resi']).                pd.dataframe(resi).plot().                plt.show().            elif len(parameters)==0:.                p=self.bestlagaic().                results = self.model.fit(p).                resi=results.resid.                self.resi=pd.dataframe(resi, columns=['bond-resi','equity-resi']).                pd.dataframe(resi).plot().                plt.show().            else:.                print('you included so many unrequired variables').        else: .            t= rvars.var(self.data, self.p, type='const').            t1= rvars.restrict(t, method = ""ser"").            t2=t1.rx2('varresult').rx2('y1').rx2('residuals').            t3=t1.rx2('varresult').rx2('y2').rx2('residuals').            resi=pd.dataframe(np.column_stack((np.array(t2), np.array(t3))), columns=['bond-resi','equity-resi']).            self.resi=resi.            pd.dataframe(resi).plot().            plt.show().    def hztest(self):.        print('this is the henze-zirkler multivariate normality test applied on the residuals of the fitted model').        subprocess.call('self.resiplot').        mvnresult =mvn.hztest(self.resi, qqplot = 0).        np.array(mvnresult.slots[tuple(mvnresult.slotnames())[1]])[0]"
