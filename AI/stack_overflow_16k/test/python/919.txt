"tool to inspect blank objects without changing them while trying to track down a resource leak in a blank program this evening, it occurred to me that modern orms make the job quite difficult. an object which is, in fact, sitting alone in memory with no children will suddenly appear to have a dozen associated objects as you start checking its attributes because, of course, each attribute dereference invokes a descriptor that pulls in additional information on-the-fly...i even noticed that doing a simple print of one particular object wound up doing a database query and pulling more linked objects into memory — ruining the careful reference counts that i had been computing — because its __repr__() built the displayed name out of a few associated objects...there are, it happens, a few techniques that allow objects to be inspected without affecting them — operations like type(obj) and id(obj) and obj.__dict__. (but not printing the __dict__, since that invokes __repr__() on every single value in the dictionary!) has anyone ever combined these few “safe” inspection methods to support, at a prompt like the blank debugger, convenient inspection and exploration of a blank object graph so that i can see where these files are being held open, running me out of file descriptors?..i need, essentially, an anti-heisenberg tool, that prevents my acts of inspection from having any side effects!..the “inspect” module:..one answer suggests that i try the inspect() module, but it looks like it dereferences every attribute on the object you supply:..import inspect.class thing(object):.    @property.    def one(self):.        print 'one() got called!'.        return 1.t = thing().inspect.getmembers(t)...this outputs:..one() got called!.[('__class__', &lt;class '__main__.thing'&gt;),. ('__delattr__', &lt;method-wrapper '__delattr__'…),. …. ('one', 1)]"
