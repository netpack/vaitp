"blank parallel input and outputs with pipeline i want to build a blank game that simultaneously takes input and prints output as a study project..the game:..the user is given a sentence. a timer counts down (with the count displayed), while the user tries to write the sentence backwards in the output. ..if you type in the output correctly, the timer is extended .the game ends if the timer runs out, or the input is incorrect..thus far:..i've been going through the different modules i can find (subprocesses, parallel blank, multiprocessing), but have gotten stuck at various points. the furthest i've gotten was with the concurrent futures module. the only problem is that the lose scenarios aren't updating immediately (ie. you can run out of time and it doesn't tell you that you've lost)..i find my way a bit hacky, i thought multiprocessing would be the best way, but i got stuck early with async calling of timer and input functions ..from concurrent.futures import threadpoolexecutor.import time..def timer(n, pipe):.    count = n.    # count down.    while count &gt; 0 and not pipe.flag_lose:.        # add more time if flag has been raised.        if pipe.can_has_additional_time():.            count += 10..        count -= 1.        print(' '*10, end='r') # hacky way to clear line when going from double to single digits.        print(count, end='r').        time.sleep(1).    print()..def get_input(pipe):.    while not pipe.flag_lose:.        sentence = ""i never should have started this project"".        print(""quick! print this backwards:"", sentence).        answer = input(""your answer: "")..        # validate.        if answer == sentence[::-1]:.            pipe.flag_additional_time = true.        else:.            print(""wrong!"").            pipe.flag_lose = true..class hackedpipeline:.    def __init__(self):.        # end game when this is true.        self.flag_lose = false.        # give more time when this is true.        self.flag_additional_time = false..    def can_has_additional_time(self):.        '''.        giving this flag an accessor because it needs to reset.        '''.        if self.flag_additional_time:.            self.flag_additional_time = false.            return true.        return false # no!..with threadpoolexecutor(max_workers=2) as executor:.    hacked_pipeline = hackedpipeline().    input_task = executor.submit(get_input, hacked_pipeline).    output_task = executor.submit(timer, n=10, pipe=hacked_pipeline)...p.s. the answer is tcejorp siht detrats evah dluohs reven i for c+p purposes"
