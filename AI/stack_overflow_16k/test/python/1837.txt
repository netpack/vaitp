"looking for feedback on my program design i'm aware that so is for questions but overall the aim is to help people learn so i figured i'd try my hand at sharing some code and asking for feedback on it.....i'm looking to create a program that will rely on random numbers, specifically dice. these will be presented in the form of ""2d6"", ""4d10+3"", ""2d2 + 3d3"" and so on and so forth. i thus set out to create a dice roller module that would be able to accept input like in that form...it works just fine for what's needed but has a bug for things that probably won't be needed (the docstring at the start of the file should explain). what i am interested in is what people think of my code and if anybody can see ways to improve it...it is still wip and i've not started on the unit tests yet...link to code..#!/usr/bin/env blank3."""""".created by teifion jordan.http://woarl.com..notes: the roller does not correctly apply * and / signs:.a + b * c is worked out as (a + b) * c, not a + (b * c) as would be correct.""""""..import random.import re.import math..class roller_dict (object):.    """"""a 'dictionary' that stores rollers, if it's not got that roller it'll make a new one"""""".    def __init__(self, generator=random.randint):.        super(roller_dict, self).__init__().        self.rollers = {}..        # generator is used to supply a ""rigged"" random function for testing purposes.        self.generator = generator..    def __call__(self, constructor):.        constructor = constructor.replace("" "", """").        if constructor not in self.rollers:.            self.rollers[constructor] = roller(constructor, self.generator)..        return self.rollers[constructor]()..# regular expressions used by the roller class.# compiled here to save time if we need to make lots of roller objects.pattern_split       = re.compile(r""(+|-|*|/)"").pattern_constant    = re.compile(r""([0-9]*)"").pattern_die         = re.compile(r""([0-9]*)[dd]([0-9]*)"").pattern_sign        = re.compile(r""^(+|-|*|/)"")..class roller (object):.    def __call__(self):.        return self.roll()..    def __init__(self, constructor, generator=random.randint):.        super(roller, self).__init__().        self.items = [].        self.rebuild(constructor).        self.generator = generator..    def rebuild(self, constructor):.        """"""builds the roller from a new constructor string"""""".        # first we need to split it up.        c = pattern_split.split(constructor.replace("" "", """"))..        # check for exceptions.        if len(c) == 0:.            raise exception('string ""%s"" did not produce any splits' % constructor)..        # stitch signs back into their sections.        parts = [].        last_p = """".        for p in c:.            if p in ""+-*/"":.                last_p = p.                continue..            if last_p != """":.                p = ""%s%s"" % (last_p, p).                last_p = """"..            parts.append(p)..        # we have the parts, now we need to evaluate them into items.        for p in parts:.            # look for a sign, default to positive.            sign = pattern_sign.search(p).            if sign == none: sign = ""+"".            else: sign = sign.groups()[0]..            # strip out the sign, we're left with just the pure value.            body = p.replace(sign, """")..            # now we find out what our main body is..            # die.            value = pattern_die.search(body).            if value != none:.                # sign, number, sides.                self.items.append((""die"", sign, int(value.groups()[0]), int(value.groups()[1]))).                continue..            # constant.            value = pattern_constant.search(body).            if value != none:.                self.items.append((""constant"", sign, int(value.groups()[0]))).                continue..            # no matches.            raise exception('the part string ""%s"" had no matches' % body)..    def roll(self):.        """"""rolls the die/dice and returns the result"""""".        result = 0..        for i in self.items:.            # get value.            if i[0] == ""die"":           value = self._derive_die(i[2], i[3]).            elif i[0] == ""constant"":    value = self._derive_constant(i[2]).            else: raise exception('no handler for item type ""%s""' % i[0])..            # apply sign.            if i[1] == ""+"":     result += value.            elif i[1] == ""-"":   result -= value.            elif i[1] == ""*"":   result *= value.            elif i[1] == ""/"":   result /= value..        return result..    def _derive_die(self, number, sides):.        result = 0.        for n in range(0, number):.            result += self.generator(0, sides)..        return result..    def _derive_constant(self, value):.        return value..# useful for running the tests to make sure that it uses ""random"" numbers.false_numbers = (int(math.cos(x)*5)+5 for x in range(0,1000)).def false_numbers_func(*args):.    return false_numbers.next()..# if it's main, run unit tests?.if __name__ == '__main__':.    r = roller_dict(false_numbers_func)..    print(r(""2d6"")).    print(r(""2d6"")).    print(r(""2d6""))"
