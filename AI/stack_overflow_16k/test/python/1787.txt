"joining multiple iteratorars by a key given: n iterators, and a function to get a key for an item for each of them..assuming: ...the iterators provide the items sorted by the key.the keys from any iterator are unique...i want to iterate through them joined by the keys. eg, given the following 2 lists:..[('a', {type:'x', mtime:datetime()}), ('b', {type='y', mtime:datetime()})].[('b', datetime()), ('c', datetime())]...using the first item in each tuple as the key, i want to get:..(('a', {type:'x', mtime:datetime()}), none).(('b', {type:'y', mtime:datetime()}), ('b', datetime()),).(none, ('c', datetime()),)...so i hacked up this method:..def iter_join(*iterables_and_key_funcs):.    iterables_len = len(iterables_and_key_funcs)..    keys_funcs = tuple(key_func for iterable, key_func in iterables_and_key_funcs).    iters = tuple(iterable.__iter__() for iterable, key_func in iterables_and_key_funcs)..    current_values = [none] * iterables_len.    current_keys= [none] * iterables_len.    iters_stoped = [false] * iterables_len..    def get_nexts(iters_needing_fetch):.        for i, fetch in enumerate(iters_needing_fetch):.            if fetch and not iters_stoped[i]:.                try:.                    current_values[i] = iters[i].next().                    current_keys[i] = keys_funcs[i](current_values[i]).                except stopiteration:.                    iters_stoped[i] = true.                    current_values[i] = none.                    current_keys[i] = none..    get_nexts([true] * iterables_len)..    while not all(iters_stoped):.        min_key = min(key.                      for key, iter_stoped in zip(current_keys, iters_stoped).                      if not iter_stoped)..        keys_equal_to_min = tuple(key == min_key for key in current_keys).        yield tuple(value if key_eq_min else none.                    for key_eq_min, value in zip(keys_equal_to_min, current_values))..        get_nexts(keys_equal_to_min)...and test it:..key_is_value = lambda v: v.a = (  2, 3, 4,  ).b = (1,          ).c = (          5,).d = (1,   3,   5,).l = list(iter_join(.        (a, key_is_value),.        (b, key_is_value),.        (c, key_is_value),.        (d, key_is_value),.    )).import pprint; pprint.pprint(l)...which outputs:..[(none, 1, none, 1),. (2, none, none, none),. (3, none, none, 3),. (4, none, none, none),. (none, none, 5, 5)]...is there an existing method to do this? i checkout itertools, but could not find anything...are there any ways to improve my method? make it simpler, faster, etc....update: solution used..i decided to simplify the contract for this function by requiring the iterators to yield tuple(key, value) or tuple(key, *values). using agf's answer as a starting point, i came up with this :..def join_items(*iterables):..    iters = tuple(iter(iterable) for iterable in iterables).    current_items = [next(itr, none) for itr in iters]..    while true:.        try:.            key = min(item[0] for item in current_items if item != none).        except valueerror:.            break..        yield tuple(item if item != none and item[0]==key else none.                    for item in current_items)..        for i, (item, itr) in enumerate(zip(current_items, iters)):.            if item != none and item[0] == key:.                current_items[i] = next(itr, none)...a = (      (2,), (3,), (4,),      ).b = ((1,),                        ).c = (                        (5,),).d = ((1,),       (3,),       (5,),).e = (                             )..import pprint; pprint.pprint(list(join_items(a, b, c, d, e)))..[(none, (1,), none, (1,), none),. ((2,), none, none, none, none),. ((3,), none, none, (3,), none),. ((4,), none, none, none, none),. (none, none, (5,), (5,), none)]"
