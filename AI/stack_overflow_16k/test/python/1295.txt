"most blankic way of ensuring a list of objects contains only unique items i have a list of objects (foo). a foo object has several attributes. an instance of a foo object is equivalent (equal) to another instance of a foo object iff (if and only if) all the attributes are equal...i have the following code:..class foo(object):.    def __init__(self, myid):.        self.myid=myid..    def __eq__(self, other):.        if isinstance(other, self.__class__):.            print 'debug: self:',self.__dict__ .            print 'debug: other:',other.__dict__ .            return self.__dict__ == other.__dict__.        else:.            print 'debug: attempt to compare different classes:',self.__class__,'compared to:', other.__class__.            return false    ...import copy..f1 = foo(1).f2 = foo(2).f3 = foo(3).f4 = foo(4).f5 = copy.deepcopy(f3) # overkill here (i know), but needed for my real code..f_list = [f1,f2,f3,f4,f5]..# surely, there must be a better way? (this dosen't work btw!).new_foo_list = list(set(f_list))...i often used this little (anti?) 'pattern' above (converting to set and back), when dealing with simple types (int, float, string - and surprisingly datetime.datetime types), but it has come a cropper with the more involved data type - like foo above...so, how could i change the list f1 above into a list of unique items - without having to loop through each item and doing a check on whether it already exists in some temporary cache etc etc?...what is the most blankic way to do this?"
