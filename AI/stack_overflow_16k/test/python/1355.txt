"proper way to subclass in blank for decoupling in client code i've got into some interesting design question...i have some abstract class, let's name it serviceclass..let's say i have 2 subclasses, named coolserviceclass and amazingserviceclass, both inheriting from serviceclass...class serviceclass(abc):.    @abstractmethod.    def do_something(self):.        pass...class coolserviceclass(serviceclass):.    def do_something(self):.        return 'cool!'..    def do_nothing(self):.        return 'nothing!'...class amazingserviceclass(serviceclass):.    def do_something(self):.        return 'amazing!'..    def just_do_it(self):.        return 'nope'...i want to write the client code but i don't want it to be coupled to one of the sub-classes in the client code. i don't want the client code to be able to use any of the methods just_do_it or do_nothing, so i'll be able to replace between their implementations easily. i know that blank is duck-typed language but i still wonder what is the proper way to handle this situation? ..one solution i thought of is using some kind of proxy class that looks something like this:..class proxyserviceclass(serviceclass):.    def __init__(self, service_class):.        self.service_class = service_class..    def do_something(self):.        return self.service_class.do_something()...and then the client code will look like this:..service_class1 = proxyserviceclass(coolserviceclass()).service_class2 = proxyserviceclass(amazingserviceclass())...now, if i'll try to use any of the methods just_do_it or do_nothing i'll get an exception...i am a little bit skeptic about this solution because i haven't seen similar solutions, i'll be happy to hear your opinions...thanks!"
