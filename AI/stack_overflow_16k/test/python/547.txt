"specifying tkinter callbacks in dictionary for display launcher function i am having trouble building a blank function that launches tkinter objects, with commands bound to menu buttons, using button specifications held in a dictionary...situation..i am building a gui in blank using tkinter.  i have written a display class (based on the guimaker class in lutz, ""programming blank"") that should provide a window for data entry for a variety of entities, so the commands and display of any instance will vary.  i would like to configure these entity-specific commands and displays in a dictionary file.  the file is evaluated when the script is run, and its dictionary passed to a launcher function when a display instance is called for.  but the instances' commands can't find the instance methods i'm trying to bind to them...specification in functions works..this isn't a problem when the display instance is launched with configurations specified in a dedicated function.  for instance this works fine:..def launchemployee():.    display = ''.    menubar = [('file', 0, [('save', 0, (lambda: display.onsave()))])].    title = 'employee data entry'.    display_args = {'title': title,.                    'menubar': menubar}.    display = displayscreen(**display_args)...the displayscreen subclasses from the guimaker, which has methods for processing the menubar object to create a menu.  it has an onsave() method...done this way, the display instance finds and runs its own onsave() method when the 'save' button is clicked...specification from dictionary file doesn't work..but this doesn't work when i try to launch the display instance from a launcher function, pulling its specification from a dictionary held in a separate file...config_file:..{'menubar':[('file', 0, [('save', 0, (lambda: display.onsave()))])],. 'title': 'employee data entry'}...script file:..config = eval(open('config_file', 'r').read())..def launchdisplay(config):.    display = ''.    display = displayscreen(**config)...run this way, clicking 'save' generates an error, saying there is no global object 'display'...theory: dictionary case looks for objects in scope at eval() call..i speculate that in the function case, 'display' is a string object, whose lack of the method onsave() isn't a problem for the the assigment to menubar because its examination for the method is deferred inside the lambda function.  when the display instance is assigned to the 'display' object, this overloads the prior assignment of the string object, but blank still knows about 'display' and goes to it when asked for its onsave() method...if so, the configuration case is failing because the 'display' object doesn't exist at all when the config dictionary is created by evaluation.  this doen't cause an error at the eval() call because, again, the lambda function hides the object from inspection until called.  but when called, blank goes looking for the 'display' object in scope at the moment of the eval() call, where it finds nothing, and then reports an error...but: putting eval() call in scope doesn't help..but i have tried moving the evaluation of the dictionary file into the function and after the creation of the 'display' string object, and this doesn't work either...so:..what is going on here?.how can i specify methods to be bound to commands in a dictionary to be accessed when instantiating the display object?   it really seems better to specify these screens in a configuration file than in a host of duplicative functions."
