"work-around for module that performs (bad) initialization we have a central module that within the module calls an init() function on loading:..import x.import y.import z..def init():.    ......init()..if __name__ == '__main__':.    ......this gets pulled into every one of our application modules with a statement like:..if __name__ == '__main__':.    import central_module as b.    b.do_this().    b.do_that()...init() does a number of bad things, notably establish connections to databases. because of this, it breaks any unit tests, and the modules i write expect the usual behavior where you import the module and explicitly invoke any initialization...i've implemented a work-around by adding an initialize variable up top:..#initialize = true.initialize = false  # for dev/test..if initialize:.    init()...but requires me to edit that file in order to run my tests or do development, then revert the change when i'm ready to commit &amp; push...for political reasons, i haven't gotten any traction on just fixing it, with something like:..import central_module as b.....    b.init().    b.do_this().    b.do_that()...is there some way that i can more transparently disable that call when the module loads? the problem is that by the time the module is imported, it's already tried to connect to the databases (and failed)...right now my best idea is: i could move the initialize variable into a previous import, and in my tests import that, set initialize to false, then import central_module...i'll keep working on the political side (arg), but was wondering if there's a better work-around i could drop in place to disable that init call without disrupting all the existing scripts."
