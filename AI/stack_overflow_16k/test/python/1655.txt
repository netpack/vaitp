"mergesort , undertanding list slicing and manipulation? i have gotten the following code from the book: ""learn blank programming"":..def sortm(v,parts=2):.    assert parts&gt;1, ""parts should be greater or equal than 2"".    if len(v)&lt;=1:.        return v.    chunk_len=max(1,len(v)//parts).    chunks=(.            sortm(v[k:k+chunk_len],parts=parts).            for k in range(0,len(v),chunk_len).            ).    return multi_merge(*chunks)..def multi_merge(*v):.    return reduce(merge,v)..def merge(v1,v2):.    v=[].    h=k=0.    len_v1,len_v2=len(v1),len(v2).    while h&lt;len_v1 or k&lt;len_v2:.        if k==len_v2 or (h&lt;len_v1 and v1[h]&lt;v2[k]):.            v.append(v1[h]).            h=h+1.        else:.            v.append(v2[k]).            k=k+1.    return v...this code is the draft part for performing mergesort by using concurrency. so far i understand the simple merguesort, but i have some questions regarding the code that the author does not specify. my questions are related to these statements:..chunks=(.                sortm(v[k:k+chunk_len],parts=parts).                for k in range(0,len(v),chunk_len).                )...i have tried to print what chunks contain but only i get like objects with no meaning. so in this part, what the author is doing? for what i see is making a recursive call to sortm() with a slice of the original list, is it like that?..also, does multi_merge(*chunks) is putting into a tuple the two lists or lists generated by chunks?..thanks for your help with this code."
