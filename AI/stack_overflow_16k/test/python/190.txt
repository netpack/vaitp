"how to make function calls obey lexical scope in blank? i want to make prevent an already defined function from looking up function names in the global scope, and instead to always call the versions available when the function was defined...in the following snippet (http://ideone.com/gvghay), foo() always looks up add() in the global scope, so when add() is replaced by sub(), foo() calls sub() instead. on the other hand, when bar() is defined, it captures a reference to the original add() function so calls to bar() will always call the original add(), even when add() is redefined...from operator import add, sub..def foo(a, b):.    return add(a, b)..def create_bar_function():.    original_add = add.    def bar_function(a, b):.        return original_add(a, b).    return bar_function..bar = create_bar_function()..print(""foo before redefinition: "" + str(foo(3, 4))) # 7.print(""bar before redefinition: "" + str(bar(3, 4))) # 7..# someone redefines add() with a different function.add = sub..print(""foo after redefinition: "" + str(foo(3, 4))) # -1.print(""bar after redefinition: "" + str(bar(3, 4))) # 7...is it possible to create a function decorator such that the decorated function always captures references to the functions available when the decorated function was defined?"
