"shipyard system linked list blank i'm trying to build a shipyard function by using blank linked list and class..this is what i have right now:..class package:..    def __init__(self,owner,destination,weight):.    self.weight = weight # sets the package weight to the weight that is input.    self.destination = destination # sets the package destination to the destination that was input.    self.owner = owner # sets the package owner to the owner that was input.    self.id = self.id() # calls the id function to make a unique id.    self.npack = none # used to singuly link list in a container..def id(self):.    global packnum.    package == 100000 + packnum # adds the package number to 100000 to make the id.    packnum += 1 # increases pack num by 1.    return package # returns the id..def readin(self,id):.    self.id = id # sets the package.id to the sent id..class container:..def __init__(self,p):.    self.destination = p.destination # makes the container desintaion to that of the first package.    self.weight = p.weight # makes the container weigh as much as the only package in the list.    self.fpackage = p # a pointer that points to the first package in the container.    self.id = self.id() # calls id() to make a custom conainer id.    self.nt = none # pointer that points to the next container in the yard.    self.lt = none # pointer that points to the previous container in the yard..def readin(self,id):.    self.id = id # sets the container id to that of the file.    self.fpackage = none # makes it so there is no package in the container.    self.weight = 0 # sets teh weight to 0..def id(self):.    global connum # holds the number of container that exist + 1.    contain = 300000 + connum # adds connum to 300000 to make an id.    connum += 1 # increments connum.    return contain #returns the id..def maxweight(self,p):.    if (self.weight + p.weight) &gt; 2000: # if the package will put the container over the limit.        return 1 # returns true.    else:.        return 0 # if the package will fit returns false..def add(self,p,n):.    if self.fpackage == none: # if there are no packages in the container.        self.fpackage = p # makes the new package equal the head.        self.weight += p.weight # adds the weigh into the container.    elif p.weight &lt; self.fpackage.weight: # if the package is lighter than the current first package.        p.npack = self.fpackage # makes the p.npack point to the current head.        self.fpackage = p # makes p the new head.        self.weight += p.weight # adds the weight of p to the container.    elif n.npack == none: # if the current package being looked at is the end of the list.        n.npack = p # makes the end point to p making p the new end.        self.weight += p.weight # adds the weight to the container.    elif n.npack.weight &gt;= p.weight: # if the next package is larger than the new package.        p.npack = n.npack # makes p point the the next package.        n.npack = p # makes the current package point to the new package.        self.weight += p.weight # adds teh weight of p into the container.    else: # if none of the above are true.        self.add(p, n.npack) # recurses forward in the list..def search(self,id,pack):.    found = 0 # a variable used to indicate if the id is found in the container.    noin = 0 # a variable used to indicate if the id was not found in the container.    while found == 0 and noin == 0: # runs till one of teh two variable are make true.        if pack.id == id: # if the current package is the one being looked for.            found = 1 # makes found = 1.        elif pack.npack == none: # if the current package being looked at is the last in the list.            noin = 1 # sets noin to 1.        else: # if neather of the above is true.            pack = pack.npack # moves to the next package in the list.    if found == 0 and noin == 1: # if the package was not found.        return 2 # returns 2.    elif found == 1: # if the package was found in the container.        return 1 # returns 1..def remove(self,id,pack):.    found = 0 # a variable used to indicate if the package was removed.    noin = 0 # a variable used to indicate if the package was not found in the current container.    while found == 0 and noin == 0: # while both variable are false.        if self.fpackage.id == id: # if the first package in the list is the target.            self.weight -= pack.weight # removes the weight of the package from the container.            self.fpackage = pack.npack # makes the head point to the second package in the container.            found = 1 # sets found to 1.        elif pack.npack == none: # if the current package is the end of the list.            noin = 1 # sets noin to 1.        elif pack.npack.id == id: # if the next package is the target.            self.weight -= pack.npack.weight # removes the targest weight from the container.            pack.npack = pack.npack.npack #  makes the current package point to the package after the target.            found = 1 # sets found to 1.        else: # if none of the above are true.            pack = pack.npack # moves to the next package in the list.    if found == 0 and noin == 1: # if the package was not found.        return 2 # returns 2.    elif found == 1: # if the package was found.        return 1 # returns 1..def writeall(self,pack,file):.    if pack != none: # if its not the last package.        file.write(str(pack.id) + ', ' + pack.owner +', ' + str(pack.weight) +'n') # creates a string of the id, ownerm weight of the package.        self.writeall(pack.npack,file) # recurses to the next package in the list..def printall(self,pack):.    if pack != none: # if its not the last package in the container.        print ('  ' + str(pack.id) + ' , ' + pack.owner + ' , ' + pack.destination + ' , ' + str(pack.weight)) # prints out the id, owner and weight of the package.        self.printall(pack.npack) # recureses to the next package in the list..class shipyard:..def __init__(self):.    self.ccount = 0 # sets teh number of container to 0.    self.fcontainer = none # sets the first container refrence to none..def readin(self,file):.    n = file.readline().    while n != '': # while not at the end of the file.        if n[0] == '%': # if the read in information is for a container.            line = [] # a blank list to put the good character into.            for x in n: # goes through all the letters.                if x.isalpha() == 1 or x.isdigit() or x == ' ': # checks if its a character to keep.                    line.append(x) # puts the character into the list.            l = ''.join(line) # reforms all the words from the individual charcters.            l = l.split(' ') # makes a list fo the values.            l.pop(0) # removes the blank value in the 0 spot of teh list.            dest = l[1] # makes the destination equal the input value(used when adding packages).            tem = package('temp',l[1].capitalize(),2000) # makes a temporary package that will make a new container.            temp = container(tem) # makes a container with the temp package.            temp.readin(int(l[0])) # makes the container empty but set to the destination.            self.place(temp,self.fcontainer) # puts the container in its appropriate place in teh yard(alphabeticly by destination).            n = file.readline() # reads the next line of the file.        else: # if the line was a package.            line = [] # a blank list to put the good character into.            for x in n: # goes through all the letters.                if x.isalpha() == 1 or x.isdigit() or x == ' ' or x == '_': # checks if its a character to keep.                    line.append(x) # puts the character into the list.            l = ''.join(line) # reforms all the words from the individual charcters.            l = l.split(' ') # makes a list of the read values.            if len(l) == 4: # if the file input is like the exapmle with the name seperated.                a = l[0] # sets a to the id.                b = str(l[1] + '_' + l[2]) # combins the first and last name seperated by a _.                c = l[3] # makes c = weight.                l = [a,b,c] # remakes the list of values.            p = package(l[1], dest.capitalize(), int(l[2])) # makes a package using the values in the list.            p.readin(int(l[0])) # sets the package id to that from the file.            self.fillcontainer(p,self.fcontainer) # adds the package into the appropriate container.            n = file.readline() # eads teh next line in the file..def place(self,p,f):.    if self.fcontainer == none: # if there are no containers in the yard.        self.fcontainer = p # sets the first container to the empty container.    elif p.destination &lt; self.fcontainer.destination: # if the destaintion of the empty container comes before the first container.        self.fcontainer.lt = p # make the current first container previous point to the empty container.        p.nt = self.fcontainer # sets the empty conainers next pointer to point at the current first container.        self.fcontainer = p # sets the empty container to the yards first containers.    elif f.nt != none and p.destination &gt;= f.nt.destination: # if the destination of the empty container comes after the next container in the list.        self.place(p,f.nt) # recurse so with the next container in the list being the current.    elif f.nt != none and p.destination &lt; f.nt.destination: # if the next containers destination comes after the new containers destination.        f.nt.lt = p # sets the next containers previous pointer to point to the new container.        p.nt = f.nt # sets the new container's next pointer to point to the next container.        p.lt = f # sets the new container's previous pointer to point to the current container.        f.nt = p  # sets the current container's next pointer to point to the new container.    elif f.nt == none: # if the current container is the end of the list.        f.nt = p # makes the current container's next pointer point to the new container.        p.lt = f # makes the new container's previous pointer point to the current container..def search(self,id,dest,cont):.    found = 0 # a variable that is used to keep track if the package is found.    while cont.destination == dest and found == 0: # if the current container's destination is the same as the input one and the package is not found.        found = cont.search(id,cont.fpackage) # searches throught the packages of the current container looking for the matching package id.    if found == 1: # if the package was found.        return cont # it returns the container class of the current container.    elif cont.nt != none and cont.nt.destination &lt;= dest and found != 1: # if the package was not found and the next container's destination is less than or matches the target.        return self.search(id,dest,cont.nt) # recurses with the next container being the current.    elif cont.nt == none or cont.nt.destination &gt; dest: # if there is no next container or the next container's destination is larger than the target.        return 0   # return 0..def fillcontainer(self,new,cont):.    if self.fcontainer == none: # if there are no containers in the yard yet.        self.fcontainer = container(new) # makes the first container point to the new container.    elif new.destination == cont.destination: # if the current container has the same destination as the package.        # the next if statment checks if there is no room in the container and if the next container is to a diffrent destination.        if cont.maxweight(new) == 1 and cont.nt != none and cont.nt.destination != new.destination:.            self.newcontainer(cont,cont.nt,new) # if it passes it inserts a new container between the two.        # the next if statment passes if there is no room in the container and the next container is to the same destination.        elif cont.maxweight(new) == 1 and cont.nt != none and cont.nt.destination == new.destination: .            self.fillcontainer(new,cont.nt) # it recurses with with the next container being the current.        elif cont.maxweight(new) == 1 and cont.nt == none: # this checks if this container is the last in line and there is no room left in the container.            c = container(new) # makes a new container set to c.            c.lt = cont # makes c's previous pointer point to the current container.            cont.nt = c # makes the current container's next point point to c.        else: # if it fails all the above if statments.            cont.add(new,cont.fpackage) # it adds the package to the current container.    elif cont.nt != none and cont.nt.destination &lt;= new.destination: # if the next container's destination is less than or equal to the package destination.        self.fillcontainer(new,cont.nt) # puts the packahe into the next container.    elif cont.nt != none and cont.nt.destination &gt; new.destination and cont.destination &lt; new.destination:.        self.newcontainer(cont,cont.nt,new) # makes a new container with the package in it that is placed between the current and next container.    else: # if the current container is the first or last container.        if new.destination &lt; cont.destination: # if the package destination comes before the first containers destination.            c = container(new) # makes a new container with the package.            c.nt = cont # makes the new container point to current container.            cont.lt = c # makes the current container point back to the new container.            self.fcontainer = c # makes the new container the first container in the yard.        else: # if the current container is the last in the list.            c = container(new) # makes a new container with the package.            c.lt = cont # makes the new container point back to the last in the list.            cont.nt = c # makes the last container in the list point to the new container..def newcontainer(self,cont,contn,new):.    new = container(new) # makes the new container.    contn.lt = new # makes the later container point back to new.    cont.nt = new  # makes the first container point to new.    new.nt = contn # makes new point forward to the later container.    new.lt = cont  # makes new point back to the first container..def locate(self,dest,cont):.    if cont.destination == dest: # if the containers destination is the same as the peramiter.        return cont # returns the container.    elif cont.nt != none: # if the next container is not none .        return self.locate(dest,cont.nt) # recurses to the next container.    else:.        return 0 # returns 0 if no matching container is found..def remove(self,id,dest,cont):.    found = 0 # if package has been found.    while cont.destination == dest and found == 0: # while the container is for the same destination and the package has not been found.        found = cont.remove(id,cont.fpackage) # it goes through the contianer to try and find the package.    if found == 1: # if the package was found in the container.        if cont.fpackage == none: # if there is no more packages in the container.            if cont.lt == none and cont.nt == none: # if there are no more packages in the yard.                self.fcontainer = none # sets the first container in the yard to none.            elif cont.lt == none and cont.nt != none: # if the container is the first container.                self.fcontainer = cont.nt # makes the first container pointer point to the next container.            elif cont.lt != none and cont.nt == none:.                cont.lt.nt = none.            else: # if there is a before and after the current container.                cont.lt.nt = cont.nt # makes the previous container point to the next container.                cont.nt.lt = cont.lt # makes the next container point back to the previous container.    elif cont.nt != none and cont.nt.destination &lt;= dest and found != 1: # if the next container has a lower or equal destination as the target.        self.remove(id,dest,cont.nt) # recurses with the next container being set as the current..def printmd(self,dest,cont):.    if cont.destination == dest: # if the container is going to the target destination.        print('% ' + str(cont.id) + ', ' + cont.destination + ', ' + str(cont.weight)) # prints out the information for the destination.        cont.printall(cont.fpackage) # calls print all that prints the packages in the container.    if cont.nt != none: # if not at the end of the list of containers.        self.printmd(dest,cont.nt) # moves to the next container..def filewrite(self,cont,file):.    if cont == none: # if there is no more containers.        file.close() # closes the file.    else: # if there is still containers to be writen.        file.write('% ' + str(cont.id) + ', ' + cont.destination + 'n') # writes the container information to the file.        cont.writeall(cont.fpackage,file) # writes the packages in the container to the file.        self.filewrite(cont.nt,file) # uses recursion to go to the next container..def printma(self,cont):.    if cont == none: # if there are no more containers.        none # terminates the function.    else:.        print('% ' + str(cont.id) + ', ' + cont.destination + ', ' + str(cont.weight)) # prints out the container information.        cont.printall(cont.fpackage) # prints out all the packages in the container.        self.printma(cont.nt) # goes to the next container in the list..def printcc(self,cont):.    if cont == none: # if there are no more containers.        none # terminates teh function.    else:.        print('% ' + str(cont.id) + ', ' + cont.destination + ', has ' + str(2000 - cont.weight) + ' pounds of space left') # prints the information for the current container.        self.printcc(cont.nt) # goes to the next container..def shipout(self):.    weight = 0 # a variable that keeps track of the weight of the containers shiped out.    count = 0 # keeps track of the number of containers shipped out.    dest = input(""what destinations do you want to send containers to: n"") # gets the target destination from the user.    dest = dest.capitalize().    first = self.locate(dest,self.fcontainer) # finds the first container with a matching destination.    if first == 0: # if no containers have a matching destination.        print(""there are no container to go to that destination n"") # prints a message stating there are no containers.    else: # else there were containers.        st = first # keeps track of the first container.        while first.nt != none and first.destination == dest: # while the container equals the target.            count += 1 # increases the container count by 1.            weight += first.weight # adds the weight of the container to the weight.            first = first.nt # moves first to the next container.        if st.lt == none and first.destination != dest: # if the first container was the start.            first.lt = none # makes the last container looked at point back to none.            self.fcontainer = first # makes thefirst container in the yard equal first.            print(""there were "" + str(count) + "" containers shipped out weighing "" + str(weight) + ""n"") # prints out the final statment.        elif st.lt != none and first.nt == none and first.destination == dest: # if the final container is the end of the list.            weight += first.weight # adds the weight of the last container.            count += 1 # adds 1 to the count of containers.            st.lt.nt = none # makes the container before st point to none.            print(""there were "" + str(count) + "" containers shipped out weighing "" + str(weight) + ""n"") # prints out the end statment.        elif st.lt == none and first.nt == none and first.destination == dest: # if the all of the containers were shipped out.            weight += first.weight # adds the weight of the last container to the count.            count += 1 # increases the number of container by one.            self.fcontainer = none # sets the first container in the yard to none.            print(""there were "" + str(count) + "" containers shipped out weighing "" + str(weight) + ""n"") # prints out the end statment.        else: # if the containers sent out were in the middle of the list.            st.lt.nt = first # sets the next pointer of the preceding container to point to the last container.            first.lt = st.lt # sets the last container to point to the container preceding the ones being shipped out.            print(""there were "" + str(count) + "" containers shipped out weighing "" + str(weight) + ""n"") # print the end statement...and this is the code for display menu for user:..from shippingyardclass import * # imports the 3 classes shipyard, container and package..def main():.    print(""the commands that this program takes are:"") .    print(""a = add package"").    print(""s = search for a package"") .    print(""p = print"").    print(""r = remove package"").    print(""sh = ship containers"").    print(""q = quit"")..    order = input(""make a decision by entering letter that you would like to do:"") # gets what the user wants to do.    while order != 'q': .        if order == 'a':.            values = input(""enter the owner, destination and weight(seperate them with a space, if there is a space in the owner or destination use a _ to represent it): n"") .            i = values.split(' ') .            while len(i) != 3: .                values = input(""error: enter the owner, destination and weight(seperate them with a space, if ther is a space in it use a _ to represent it): n "").                i = values.split(' ') .            while i[2].isdigit() == 0 or int(i[2]) &gt; 2000:.                i[2] = input(""you did not enter a valid weight, please enter one below 2000: n"") .            new = package(i[0].capitalize(),i[1].capitalize(),int(i[2])).        shipyard.fillcontainer(new,shipyard.fcontainer)..    if order == 's':.        values = input(""enter the id number then the destination of the package(seperate them with a space, use _ for spaces in destination): n "").        i = values.split(' ').        while len(i) != 2 and i[0].isdigit != 1:.            values = input(""enter the id number then the destination of the package(seperate them with a space): n "") .            i = values.split(' ') .        r = shipyard.search(int(i[0]),i[1].capitalize(),shipyard.fcontainer) .        if r != 0: .            print(""package "" + i[0] + "" going to "" + i[1].capitalize() + "" is in container "" + str(r.id) + ""n"") .        else: .            print(""there is no package with the id "" + i[0] + "" going to "" + i[1].capitalize() + "" is not in the yard n"") ..    if order == 'p':.        t = input(""what would you like to print(md = manifest for a destination, ma = manifest for the yard, cc = list of containors): n"") .        if t == 'md': .            dest = input(""what is the destination you want a manifest for: n "") .            shipyard.printmd(dest,shipyard.fcontainer) .        if t == 'ma':.            shipyard.printma(shipyard.fcontainer) .        if t == 'cc':.            shipyard.printcontainers(shipyard.fcontainer) ..    if order == 'r':.        values = input(""enter the id and destination of the package you want removed(seperate them with a space): n "").        i = values.split(' ') .        while len(i) != 2 and i[0].isdigit() == 0: .            values = input(""enter the id and destination of the package you want removed(seperate them with a space): n "").            i = values.split(' ') .        shipyard.remove(int(i[0]),i[1].capitalize(),shipyard.fcontainer) ..        if order == 'sh': .            shipyard.shipout().        if order != 'a' and order != 'p'and order != 'r'and order != 'sh'and order != 'q':.            raise typeerror(""wrong input letter"").        return main()..main()...however, when i run the meun function and choose ""a"" in the menu and try to enter a owner, destination and weight. for example: jack japan 80. it comes out an error ""nameerror: name 'package' is not defined"" back to the id function of package class. .what's wrong for my code and how do it fix it? thank you!"
