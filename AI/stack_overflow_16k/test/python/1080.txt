"dictionary runtime (codility test) i tried a codility sample question, answering in blank. i am not getting 100 score because it failed to finish in time on large data set...the following is the question:...  a non-empty zero-indexed array a consisting of n integers is given..  the first covering prefix of array a is the smallest integer p such.  that 0 ≤ p &lt; n and such that every value that occurs in array a also.  occurs in sequence a[0], a[1], ..., a[p]....for example, the first covering prefix of the following 5−element array a:..a[0] = 2  a[1] = 2  a[2] = 1.a[3] = 0  a[4] = 1...is 3, because sequence [ a[0], a[1], a[2], a[3] ] equal to [2, 2, 1, 0], contains all values that occur in array a...my answer is:..def ps ( a ):.    n = len(a);.    if n == 0: return -1.    bit = {}.    for i in range(n):.        if not a[i] in bit.keys():.            bit[a[i]] = 1.            p = i.    return p...result:..it doesn't give me 100 for this question because it thinks my algo is o(n**3), and failed test cases are..random_n_log_100000 .random test 100 000 elements and n/log_2 n values.  10.025 s.   timeout error .running time: &gt;10.02 sec., time limit: 9.82 sec...random_n_10000 .random test 10 000 elements and values. 1.744 s.    timeout error .running time: &gt;1.74 sec., time limit: 1.10 sec...random_n_100000 .random test 100 000 elements and values.    10.025 s.   timeout error .running time: &gt;10.02 sec., time limit: 9.94 sec....analysis:...at first i believe my code is o(n) as i assume the key part of my code, a[i] in bit.keys(), has constant run-time, i.e. o(1). but perhaps on large data set, the hash function gives a lot of collision so the runtime is no longer o(1)?.does o(n**3) means o(n^3)? i have this question because i have seen other post where codility report an n square algo as o(n^2). so i suppose they will be consistent in their report?.if they really think my answer is o(n^3), then is it reasonable because my code only run past their time limit by less than 1 second? here i assume their time limit is for an o(n) algo because this is what they request in the question. if that is the case, i can't see why an o(n^3) algo is just >1 sec slow??"
