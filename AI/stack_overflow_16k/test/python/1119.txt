"problems about blank closure:why does the code keep the value of local variable in a function? in my idea,inside a closure we can reference variable beyond its own scope.but there's something i can't understand in the following code:..def counter(start_at=0) :.    count = [start_at].    def incr():.        count[0] += 1.        return count[0].    return incr..count = counter(5).print count() # 6.print count() # 7.count2 = counter(100).print count2() # 101.print count() # 8...it seems like that inside the function 'counter',local variable 'count' is never destroyed,and i can run count() again and again to increase the previous value count[0]..what's special for closure in this case? what does the interpreter do to manage and recycle the resources of the function containing a closure? .hope for your help!"
