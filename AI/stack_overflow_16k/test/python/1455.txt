"basics of simulated annealing in blank i have to use simulated annealing for a certain optimization problem. to get a 'feel' of the technique, i wrote a small blank code and tried to run it. however, it doesn't seem to be giving satisfactory results...import random;.import math;.from math import *;.limit=100000;....def update_temperature(t,k):.    t1=t/log(k+1);.#   print ""temp now is "" + str(t1);.    return t1;..def get_neighbors(i,l):.    if(l&gt;1):.        if(0&lt;=i and i&lt;l):.            if(i==0):.                return [1];.            if(i==l-1):.                return [l-2];.            return [i-1,i+1];.    return [];..def make_move(x,a,t):.    nhbs=get_neighbors(x,len(a));..    nhb=nhbs[random.choice(range(0,len(nhbs)))];...    delta=a[nhb]-a[x];..    if(delta &lt; 0):.        return nhb;.    else:.        r=random.random();.        if(r &lt;= (e**(-1*delta)/(t*1.0))):.            return nhb;..    return x;...def simulated_annealing(a):.    l=len(a);.    init_pos=random.choice(xrange(0,l));.    t=10000**30;.    k=1;..    x_best=init_pos;.    x=x_best;..    while(t&gt;0.0000001 ):.        x=make_move(x,a,t);.        if(a[x] &lt; a[x_best]):.            x_best=x;.        t=update_temperature(t,k);.        k+=1;..    return [x,x_best,init_pos];....def isminima_local(p,a):.    l=len(a);.    if(l==1 and p==0):.        return true;.    if(l&gt;1):.        if(p==0):.            if(a[0] &lt;=a[1]):.                return true;.        if(p==l-1):.            if(a[p-1] &gt;=a[p]):.                return true;.        if(0&lt;=p and p&lt;l and a[p-1]&gt;=a[p] and a[p]&lt;=a[p+1]):.            return true;.    return false;...def func(x):.    f=sin(x);.    return f;..def initialize(l):.    a=[0]*l;.    for i in xrange(0,l):.        a[i]=func(i);.    return a;..def main():.    a=initialize(limit);...    local_minima=[];.    for i in xrange(0,limit):.        if( isminima_local(i,a)):.            local_minima.append([i,a[i]]);  .    sols=simulated_annealing(a);..    m,p=a[0],0;.    for i in xrange(1,limit):.        if(m&gt;a[i]):.            m=a[i];.            p=i;..    print ""global minima at n"";.    print p,m;...    print ""after annealingn"";..    print ""solution is "" + str(sols[0]) + "" "" + str(a[sols[0]]);.    print ""best solution is "" + str(sols[1]) + "" "" + str(a[sols[1]]);.    print ""start solution is "" + str(sols[2]) + "" "" + str(a[sols[2]]);..    for i in xrange(0,len(local_minima)):.        if([sols[0],a[sols[0]]]==local_minima[i]):.            print ""solution in local minima"";.        if([sols[1],a[sols[1]]]==local_minima[i]):.            print ""best solution in local minima"";.    for i in local_minima:.        print i;..main();...i am unable to understand where i am going wrong. is there something wrong with the implementation or is there something wrong in my understanding about simulated annealing ? please point out the error....my rough idea about sa:. pick a random neighbor. if neighbor improves your condition, move there,. else, move there with certain probability. . the probability is such that initially bad moves are 'allowed' but they are 'prohibited'   later on. finally you will converge to your solution...i have found the set of local minima and global minima using brute force. then i run sa. i was expecting that sa will atleast converge to a local minima but that doesn't seem to be the case always. also, i am not sure if at every step i choose a neighbor randomly and then try to move or i choose the best neighbor ( even if none of the neighbors improve my condition) and then try to move there."
