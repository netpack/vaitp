"removing adjacent numbers dilemma i was writing a function to remove adjacent equivalent numbers in a list. i wrote remove_adjacent(nums) in honestly less than a minute. however i seem to be stuck in this rut where what i write is not blankic at all. and also it is not nearly as fast as i would like. the second solution was the intended one written by google. this is a google basic coding problem solution doc that i have been working through i forgot where specifically i got it from however it is from google development...# d. given a list of numbers, return a list where.# all adjacent == elements have been reduced to a single element,.# so [1, 2, 2, 3] returns [1, 2, 3]. you may create a new list or.# modify the passed in list...def remove_adjacent(nums):..  index, index_1 = 0, 1.  while index_1 &lt; len(nums):.      if nums[index] == nums[index_1]:.          nums = nums[:index] + nums[index+1:].      else:.          index = index_1.          index_1 += 1 .  return nums..#googles solution.def remove_adjacent2(nums):.    result = [].    for num in nums:.        if result == [] or num not in result:.            result.append(num).    return result...i feel like my problem stems from my previous experiences with c and c++. any thoughts on how to improve? do i just need brute force practice? continuous reiterations of ""i wrote it like this but it is way more blank to write it like this"""
