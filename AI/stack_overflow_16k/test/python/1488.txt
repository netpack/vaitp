"blank: using rlock with multiple threads the expected output should be for all 3 func() processes to complete and for 'finished' to not be printed, but instead test() returns finished after the first print(i) in func(). ..rlock = threading.rlock()..def func(): .    rlock.acquire().    for i in range(3): .        time.sleep(2).        print(i).    rlock.release().    return..def test(): .    l = [].    for i in range(3): .        time.sleep(1).        threading.thread(target=func).start() .    print(rlock) # prints &lt;_thread.rlock owner=140092805895936 count=1&gt;.    print(rlock._is_owned()) #prints false .    if not rlock._is_owned(): .        return 'finished' #returns 'finished'..test()...update: specifically i would like to have a test() function that does not return until all threads in rlock are finished. but i'm having trouble determining whether the rlock counter is incremented or not  - there doesn't seem to be a method corresponding to that."
