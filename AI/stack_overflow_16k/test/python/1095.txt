"assign methods from class in imported module to current namespace i would like assign methods (more at once) from class in imported module to current namespace and i would like to do the ""assign process"" not in the ""current"" namespace but from the imported module. how can i do that?..this file is imported from another one:..# file mylib.py..class mylib():.    def hello1(self, text):.        print('hello1: %s' % text)..    def goodbye1(self, text):.        print('goodbye1: %s' % text)..    def hello2(self, text):.        print('hello2: %s' % text)..    def goodbye2(self, text):.        print('goodbye2: %s' % text)..    def assign1(self):.        pass.        # this should assign self.hello1() and self.goodbye1().        # to ""parent"" namespace as hello() and goodbye()..    def assign2(self):.        pass.        # similar behaviour to self.assign1()...this file is the ""main"" one...# file myscript.py..import mylib..l = mylib.mylib().l.assign1()..# after this i would like to have mylib.hello1() assigned to hello().# and mylib.goodbye1() to goodbye()..hello('hi').goodbye('see you')..l.assign2().# after this i would like to have mylib.hello2() assigned to hello().# and mylib.goodbye2() to goodbye()..hello('hi').goodbye('see you')...so far i tried globals() with no success and found that __builtins__ might work but seemed not the right way because of polluting __builtins__ namespace with content that does not belong there...what i do not want:..# in the ""current"" namespace.hello = l.hello1.goodbye = l.goodbye1..# instead i want..l.assign1().# now hello() and goodbye() are mapped to l.hello1() and l.goodbye1().# ""automatically"" - the assign process was done in l.assign1(),.# not here in the ""current"" namespace....thanks for any help."
