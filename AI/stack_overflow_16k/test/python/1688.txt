"how to guarantee proper closing i have an class i want to ensure closes properly. in particular, i want it to close even if my main process is killed from an external event (eg: sigterm)...context managers and atexit will not be called if killed 'abnormally'. so i've been trying to use signal to capture events and  then run my particular cleanup code. ..but now i'm getting into the weeds of how blank cleans up upon different types of exits. for instance, while i can capture signal.sigterm and add my own handler, i don't know how to call the default handler when done. but not being an expert, i'm uncomfortable having my library take over proper system exit with my own code. ..(specifics: i'm using shelve and if you don't close a shelf it will remain in a locked and un-openable state - essentially unusable.)..am i making this too hard? i would think making sure i can clean up properly should not require deep expertise...alternatively, if i really do need to capture the signal and then take over system exit, can i simply do my cleanup code, and if the only other handler is sig_dfl, then i just do a sys.exit()? that sounds risky, but is that ok? ..my current code:..def reg_sig(signum):.    old_handler = signal.getsignal(signum)..    def sighandler(signum, frame):.        close_open_objects() # &lt;== my custom code.        if callable(old_handler):.            old_handler().        else:.            # what goes here?.            # do_default_handler() # &lt;- this seems ideal.            # or.            # sys.exit()..    try:.        # i'm not sure what signals might be called so i register a bunch..        signal.signal(signum, sighandler) .    except exception as err:.        pass..# register signals.for sig in [signal.sighup, signal.sigint, signal.sigquit, signal.sigabrt, .            signal.sigkill,signal.sigterm]:.    reg_sig(sig)"
