"blank: adding an attribute to a variable of a class and have it survive assignment (descriptor class) our project collects a bunch of information on an object from a bunch of different sources and for auditing and for resolving conflicts between our data sources we need to keep a bunch of meta data about each attribute..age = 21.age_metadata = {.     'source' : 'office gossip',.     'relability' : 0 .    {...the problem is the classes start to look like this. ..class person.    def __init__(self, id, ):.       self.id = id.       self.id_meta = none.       self.age = none.       self.age_meta = none.       self.name = none...which looks ugly and doubles the number of attributes everything has so what i want is to nest the metadata under each attribute. so if i need it i can call  bob.age.meta instead of bob.age_meta and i want to do this while leaving the attributes more or less unchanged. so i want something that always me to use it like:..def main():.    bob = person(1).    bob.age.meta = 'random metadata'.    bob.age = 30.    assert bob.age.meta == 'random metadata'...now i think this should be possible using a combo of a descriptor class to intercept the assignment  + some monkey patching/ metaclassing magic to preserve the metadata.. but i'm new to all these features and am getting very lost. here is my current sketch.long way from working code:..class attributewithmeta(object):.    """"""interceot attribute fucntions""""""..    def __get__(self, instance, owner):.        return self._value..    def __set__(self, instance, value):.        """"""take  attribute and somehow replace it with monkey patched version"""""".        self._value = magic(value,meta)..    @staticmethod.    def magic(value, meta):.        """"""adds meta attribute to objects regardless of type"""""".        return  value_with_meta...class person(object):.    age = attributewithmeta()..    def __init__(self, id):.        self.id = id...am i going in the right direction?  is there some other way to do this that i'm missing? am i trying to do the impossible here?..p.s worst case  age.get_meta() would be acceptable if attributes are problematic."
