"hash function not correct? math.pow does not handle arbitrarily large numbers i am trying to solve this easy problem on lintcode and i have my solution:..import math.class solution:.    """""".    @param key: a string you should hash.    @param hash_size: an integer.    @return an integer.    """""".    def hashcode(self, key, hash_size):.        # write your code here.        ret=0.        for i in range(0,len(key)):.            multiplier=int(math.pow(33,len(key)-i-1)).            ret += (multiplier* ord(key[i])).        return ret%hash_size...but it only works for keys of length &lt;= 11 and does not work otherwise (wrong answer). blank handles arbitrarily large numbers by default, so what is the problem ? this is so simple and getting it wrong is driving me crazy...the description of problem reads:...  in data structure hash, hash function is used to convert a string(or.  any other type) into an integer smaller than hash size and bigger or.  equal to zero. the objective of designing a hash function is to ""hash"".  the key as unreasonable as possible. a good hash function can avoid.  collision as less as possible. a widely used hash function algorithm.  is using a magic number 33, consider any string as a 33 based big.  integer like follow:..hashcode(""abcd"") = (ascii(a) * 333 + ascii(b) * 332 + ascii(c) *33 +.ascii(d)) % hash_size ..                          = (97* 333 + 98 * 332 + 99 * 33 +100) % hash_size..                          = 3595978 % hash_size..  .  here hash_size is the capacity of the hash table (you can assume a.  hash table is like an array with index 0 ~ hash_size-1)..  .  given a string as a key and the size of hash table, return the hash.  value of this key.f...update: rob's answer solves the issue of incorrect answer, but now speed is an issue...update2:.both of the following techniques worked:..        ret=0.        ## technique 1.        for i in range(0,len(key)):.            multiplier= pow(33,(len(key)-i-1),hash_size).            ret += (multiplier * ord(key[i])).        return ret%hash_size.        # technique 2.        ret=0.        multiplier = 1.        for ch in key[::-1]:.            ret = (ret + ord(ch) * multiplier) % hash_size.            multiplier = (multiplier * 33) % hash_size.        return ret % hash_size"
