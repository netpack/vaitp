"creating a pseudo-module that creates submodules at runtime to support extensions in my blank project, i'm trying to create a pseudo-module that will serve ""extension modules"" as it's submodules. i'm having a problem treating the submodules as modules - it seems like i need to access them using from..import on the main pseudo-module and can't just access their full path...here is a minimal working example:..import sys.from types import moduletype...class foo(moduletype):.    @property.    def bar(self):.        # here i would actually find the location of `bar.py` and load it.        bar = moduletype('foo.bar').        sys.modules['foo.bar'] = bar.        return bar...sys.modules['foo'] = foo('foo')..from foo import bar  # without this line the next line fails.import foo.bar...this works, but if i comment out the from foo import bar line, it'll fail with:..importerror: no module named bar...on blank2, and on blank3 it'll fail with:..modulenotfounderror: no module named 'foo.bar'; 'foo' is not a package...if i add the fields to make it a package:..class foo(moduletype):.    __all__ = ('bar',).    __package__ = 'foo'.    __path__ = [].    __file__ = __file__...it'll fail on:..modulenotfounderror: no module named 'foo.bar'...from what i understand, the problem is that i did not set sys.modules['foo.bar'] yet. but... to fill sys.modules i need to load the module first, and i don't want to do it unless the user of my project explicitly imports it...is there any way to make blank realize that when it sees import foo.bar it needs to load foo first(or i can just guarantee foo will already be loaded at that point) and take bar from it?"
