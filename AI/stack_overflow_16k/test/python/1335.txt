"decimal class implicit type conversions? as an exercise for learning blank, i am attempting to build a fully implemented type vector...while implementing this i quickly ran into the need for more control over precision, and generally more precision for a decent type that i will later apply to a more generalized linear algebra library. for this purpose i am currently using the built in decimal class...i have run into what i consider an oddity in a relationship between the method magnitude, and normalized. essentially as is, the return type of the magnitude method is converting operations done entirely with decimal objects, to a float object. this inconsistency throws a type error down the line in the normalized method, when i attempt to divide a decimal object by this return value...i have commented out a hacky solution that i came up with where i simply explicitly force the return value to a decimal object. my issue with this approach is the potential loss in the mathematical precision i am hoping to maintain in this class. i have so far been unable to pin down exactly where this implicit type conversion is occurring, let alone how best to approach a solution that maintains mathematical precision...the likely offending line:..#65    return (math.sqrt(sum(coordinates_squared)))...the vector class:..import math.from decimal import decimal, getcontext.global_precision = 30.getcontext().prec = global_precision..class vector(object):.    """"""the vector class takes an iterable object, and stores it as a.    a mathematical vector. class defines several vector operations..    """""".    cannot_normalize_zero_vector_msg = 'cannot normalize the zero vector'..    def __init__(self, coordinates):.        """"""the variable coordinates must be an iterable object, whose.        elements are numberic, and valid input for decimal class.        """""".        try:.            if not coordinates:.                raise valueerror.            self.coordinates = tuple([decimal(x) for x in coordinates]).            self.dimension = len(self.coordinates)..        except valueerror:.            raise valueerror('the coordinates must be nonempty')..        except typeerror:.            raise typeerror('the coordinates must be an iterable')..    def __str__(self):.        """"""print a vector as a row vector"""""".        return 'vector: {}'.format(self.coordinates)..    def __eq__(self, v):.        """"""define vector equality as component-wise equality"""""".        return self.coordinates == v.coordinates..    def __add__(self, v):.        assert( self.dimension == v.dimension ), 'does not make sense to ' .                'add vectors of different dimensions'..        _result = [ x+y for x,y in zip(self.coodinates, v.coodinates)].        return (vector(_result))..    def __sub__(self, v):.        assert( self.dimension == v.dimension ), 'does not make sense to ' .                'subtract vectors of different dimensions'..        _result = [ x-y for x,y in zip(self.coodinates, v.coodinates)].        return (vector(_result))..    """"""def __mul__(self, k):.        _result = [decimal(k)*x for x in self.coordinates].        return vector(_result).    """"""..    def scale_mul(self, k):.        """"""return a vector object that has had each element scaled by k"""""".        _result = [decimal(k)*x for x in self.coordinates].        return( vector(_result) )..    def magnitude(self):.        """"""return a decimal object that is the root of the sum of the.        squares of the elements of the vector self.        """""".        coordinates_squared = [x**2 for x in self.coordinates].        return (math.sqrt(sum(coordinates_squared))).        #return decimal((math.sqrt(sum(coordinates_squared))))...    def normalized(self):.        """"""returns a vector object that has been scaled by 1/self.magnitude"""""".        try:.            return ( self.scale_mul(decimal('1.0')/self.magnitude()) )..        except zerodivisionerror:.            raise exception(self.cannot_normalize_zero_vector_msg)..    def dot(self, v):.        """"""return the dot product of 2 vector objets as a decimal object"""""".        assert( self.dimension == v.dimension ), 'does not make sense to ' .                'dot vectors of different dimensions'..        return sum([x*y for x,y in zip(self.coordinates, v.coordinates)])..    def angletheta(self, v, in_degrees = false):.        """"""returns the smaller of the two angles between two vectors,.        presuming the vectors eminate from the same initial position..        returns radians by default, can be flipped to degrees with.        additional true parameter.        """""".        try:.            u1 = self.normalized().            u2 = v.normalized().            assert(abs(round(u1.dot(u2), 10)) &lt;= 1), 'acos must recieve' .                'parameter between 0 and 1'..            angle_in_radians = math.acos(round(u1.dot(u2), 10))..            if in_degrees:.                return math.degrees(angle_in_radians).            else:.                return angle_in_radians..        except exception as e:.            if str(e) == self.cannot_normalize_zero_vector_msg:.                raise exception('cannot compute an angle with the zero vector').            else:.                raise e..    def is_parallel(self, v):.        """"""returns true if parameter v is parallel to the vector self"""""".        return( self.is_zero() or.                v.is_zero() or.                self.angletheta(v) == 0 or.                self.angletheta(v) == math.pi )..    def is_orth(self, v, tolerance=1e-10):.        """"""returns true if parameter v is orthagonal to the vector self"""""".        return ( abs(self.dot(v)) &lt; tolerance )..    def is_zero(self, tolerance=1e-10):.        """"""returns true if self is the zero vector"""""".        return (self.magnitude() &lt; tolerance)"
