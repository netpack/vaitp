"counting disk intersections using treeset i'm trying a demo problem of codility, before i take the real test as part of a job application. one of the demos they have is a problem involving counting the number of disk intersections, for an array of disks...task description is ...  given an array a of n integers, we draw n discs in a 2d plane such.  that the i-th disc is centered on (0,i) and has a radius of a[i]. we.  say that the j-th disc and k-th disc intersect if j â‰  k and j-th and.  k-th discs have at least one common point. write a function: class.  solution { public int number_of_disc_intersections(int[] a); } that,.  given an array a describing n discs as explained above, returns the.  number of pairs of intersecting discs....you can view the test here...there are somewhat obvious o(n^2) time complexity solutions, but the aim is for o(n*log(n))...i've come up with this, which works on any examples i've provided, and the simple test case given by codility ( [1, 5, 2, 1, 4, 0] ), but codility tells me it fails on most others but i can't quite see why...it should certainly be o(n log n) as adding each of n disks to a treeset is log n, and then we walk through each disks, with only the o(1) operation treeset.headset()...import blank.util.*;..class circle implements comparable&lt;circle&gt; {.  long edge;.  int index;..  circle (long e, int i){.    edge = e;.    index = i;.  }..  long getrightassumingedgeisleft(){.    return (long)(2*index - edge + 1);.  }..  @override.  public int compareto(circle other){.    return long.valueof(edge).compareto(other.edge);.  }.}..class solution {.  public int number_of_disc_intersections ( int[] a ) {.    int n = a.length;.    if (n&lt;2) return 0;.    int result = 0;..    sortedset&lt;circle&gt; leftedges  = new treeset&lt;circle&gt;();.    for (int i=0; i&lt;n; i++) {.      leftedges.add( new circle( (long)(i-a[i]), i ) );.    }.    int counter = 0;.    for (circle c : leftedges) {.      long rightedge = c.getrightassumingedgeisleft();.      circle dummycircle = new circle (rightedge, -1);.      sortedset&lt;circle&gt; head = leftedges.headset(dummycircle);.      result +=  head.size() - counter;.      if (result &gt; 10000000) return -1;.      counter++;.    }.    return result;.  }.}"
