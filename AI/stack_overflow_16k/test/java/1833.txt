"how can i get this abstract class to send its output to a socket? i'm experimenting with creating a socket application that sends some data from another application to a client. the code to access the data uses an abstract class...subscriptionadapter listener = new subscriptionadapter() {.  @override.  public void onsubscriptiondata(subscriptiondata data) {.    for (anyjson json : data.getmessages()) {.      system.out.println(json.tostring());.    }.  }.};...the mechanics of subscriptionadapter() were a little weird to figure out. onsubscriptiondata gets called over and over and the for loop will return 1 to many records. here is some sample output:..yup.got message: {""type"":""lightning"",""location"":{""coords"":{""lon"":18.509391,""lat"":38.7581},""polarity"":0}}.yup.got message: {""type"":""lightning"",""location"":{""coords"":{""lon"":18.504115,""lat"":38.765076},""polarity"":0}}.got message: {""type"":""lightning"",""location"":{""coords"":{""lon"":18.494549,""lat"":38.778813},""polarity"":0}}...""yup"" is a line of debug code i put in above the for loop to confirm how the class functions...below is the sample socket server i'm working with:..import blank.net.*;.import blank.io.*;...public class server {..    /**.     * @param args the command line arguments.     */.    public static void main(string[] args) //throws exception.    {   .        try.        {.            serversocket serversocket = new serversocket(9090);.            system.out.println(""waiting for clients..."");..            socket socket = serversocket.accept();.            printwriter out = new printwriter(socket.getoutputstream(), true);.            out.println(""hello  client!"");.            out.close();.            socket.close();.            serversocket.close();..        } catch (exception e).        {.            system.out.println(e.tostring());.        }.    }..}...the goal is to get system.out.println(json.tostring()); to output to the socket connection. however, i've been running into scope issues....i can't just put the code for the server inside onsubscriptiondata because it will keep trying to create a new socket on a port that is already open..i can't put the code outside of the abstract class because then printwriter out = new printwriter(socket.getoutputstream(), true); winds up being out of scope....i've been at it for a few hours and at this point, i could use some suggestions...update as requested. below is the full code:..import com.satori.rtm.*;.import com.satori.rtm.model.*;..public class subscribetoweatherchannel {.  static final string endpoint = [end point];.  static final string appkey = [app key];.  static final string channel = ""full-weather"";..  public static void main(string[] args) throws interruptedexception {.    final rtmclient client = new rtmclientbuilder(endpoint, appkey).        .setlistener(new rtmclientadapter() {.          @override.          public void onenterconnected(rtmclient client) {.            system.out.println(""connected to satori rtm!"");.          }.        }).        .build();...    subscriptionadapter listener = new subscriptionadapter() {.      @override.      public void onsubscriptiondata(subscriptiondata data) {.        for (anyjson json : data.getmessages()) {.          system.out.println(json.tostring());.        }.      }.    };..    client.createsubscription(channel, subscriptionmode.simple, listener);..    client.start();.  }.}"
