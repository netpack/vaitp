"competitive programing: factorial time limit exceeded i am working on a very simple spoj problem in which we have to take input n calculate its factorial then find out number of trailing zeros and display it some thing like..sample input:..6..3..60  // fact of 60 has 14 trailing zeros..100..1024..23456..8735373..sample output:..0..14..24..253..5861..2183837..so i have written a code which is working fine on my machine but when i am submitting it is giving me time limit error. i don't know how to make this code fast. so i want suggestions from you guys...public class factorial {..    public static void main(string[] args) throws ioexception {.        try {.            bufferedreader bf = new bufferedreader(new inputstreamreader(system.in));.            int t = integer.parseint(bf.readline());.            for (int i = 0; i &lt; t; i++) {.                long num = long.parselong(bf.readline());.                biginteger bd = biginteger.valueof(num);..                system.out.println(counttrailinzeros(factorial(bd.tostring())));.            }.        } catch (illegalstateexception e) {..            return;.        }.    }..    public static biginteger factorial(string n) {.        biginteger x = biginteger.valueof(1);.        for (long i = 1; i &lt;= integer.parseint(n); i++) {.            x = x.multiply(biginteger.valueof(i));.        }.        return x;.    }..    public static int counttrailinzeros(biginteger bd) {.        string s = bd.tostring();.        int glen = s.length();.        s = s.replaceall(""[0.]*$"", """");.        int llen = s.length();..        return glen - llen;.    }..}...i have googled about some possible solutions and found out that lookup table may work i don't have much idea about this. i'd be very thankful if some can explain me about lookup table...edit: could it be blank is too slow to solve this problem in given time? or in general it is not favorable to use blank for competitive programing?"
