"have comparable object using underlying collection the goal here is to insert elements into a treeset where the ordering is done by a custom objects internal list...public class customobject implements comparable&lt;customobject&gt; {.    list&lt;integer&gt; innerobjectlist = new arraylist&lt;&gt;();..    @override.    public boolean compareto(customobject o) {.        #compare natural ordering of elements in array. .    }.}...this is what i'm currently doing, it works but i was hoping to find a native way to do it. ..@override.public int compareto(@notnull aislemap o) {.    if (o.aisles.size() &gt; aisles.size()).        return 1;.    if (o.aisles.size() &lt; aisles.size()).        return -1;.    for (int i = 0; i&lt;aisles.size(); i++) {.        int compare = o.aisles.get(i).compareto(aisles.get(i));.        if( compare != 0) {.            return compare;.        }.    }..    return 0;.}...i'm trying to figure out how to do something like o.innerobjectlist.compare(toinnerobjectlist); however i'm not entirely sure how to do this so that the treeset orders the objects by the array properly. is there an easy way to compare the ""natural"" order of elements in an array to each other? only way i thought of was to check for size then if equal check contents until one index of one array is larger than the same index of another. ..ex: the ordering would be like so {1,2,5} -&gt; {1,2,4} -&gt; {1,2,3}"
