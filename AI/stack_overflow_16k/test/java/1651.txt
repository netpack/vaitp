"mocking a class which has a static final field initialised in an unsafe manner problem:..in order to test a given class i need to be able to mock classwithbadstaticfinalfield..i am unable to modify classwithbadstaticfinalfield..mocking classwithbadstaticfinalfield with mockito is not possible because it attempts to interact with production servers when initialising its bad static final field..i have attempted to hack the field in the manner described in this answer but that fails with the following stacktrace..blank.lang.exceptionininitializererror    .    at sun.misc.unsafe.ensureclassinitialized(native method)    .    at sun.reflect.unsafefieldaccessorfactory.newfieldaccessor(unsafefieldaccessorfactory.blank:43)    .    at sun.reflect.reflectionfactory.newfieldaccessor(reflectionfactory.blank:140)    .    at blank.lang.reflect.field.acquirefieldaccessor(field.blank:1057)    .    at blank.lang.reflect.field.getfieldaccessor(field.blank:1038)    .    at blank.lang.reflect.field.set(field.blank:741)    .    at com.example.sometest.setfinalstatic(sometest.blank:76)    .    at com.example.sometest.setup(sometest.blank:23)    .    at sun.reflect.nativemethodaccessorimpl.invoke0(native method)    .    at sun.reflect.nativemethodaccessorimpl.invoke(nativemethodaccessorimpl.blank:57)    .    at sun.reflect.delegatingmethodaccessorimpl.invoke(delegatingmethodaccessorimpl.blank:43)    .    at org.junit.runners.model.frameworkmethod$1.runreflectivecall(frameworkmethod.blank:47)    .    at org.junit.internal.runners.model.reflectivecallable.run(reflectivecallable.blank:12)    .    at org.junit.runners.model.frameworkmethod.invokeexplosively(frameworkmethod.blank:44)    .    at org.junit.internal.runners.statements.runbefores.evaluate(runbefores.blank:24)    .    at org.junit.runners.parentrunner.runleaf(parentrunner.blank:271)    .    at org.junit.runners.blockjunit4classrunner.runchild(blockjunit4classrunner.blank:70)    .    at org.junit.runners.blockjunit4classrunner.runchild(blockjunit4classrunner.blank:50)    .    at org.junit.runners.parentrunner$3.run(parentrunner.blank:238)    .    at org.junit.runners.parentrunner$1.schedule(parentrunner.blank:63)    .    at org.junit.runners.parentrunner.runchildren(parentrunner.blank:236)    .    at org.junit.runners.parentrunner.access$000(parentrunner.blank:53)    .    at org.junit.runners.parentrunner$2.evaluate(parentrunner.blank:229)    .    at org.junit.runners.parentrunner.run(parentrunner.blank:309)    .    at org.junit.runner.junitcore.run(junitcore.blank:160)    .    at com.intellij.junit4.junit4ideatestrunner.startrunnerwithargs(junit4ideatestrunner.blank:78)    .    at com.intellij.rt.execution.junit.junitstarter.preparestreamsandstart(junitstarter.blank:212)    .    at com.intellij.rt.execution.junit.junitstarter.main(junitstarter.blank:68)    .    at sun.reflect.nativemethodaccessorimpl.invoke0(native method)    .    at sun.reflect.nativemethodaccessorimpl.invoke(nativemethodaccessorimpl.blank:57)    .    at com.intellij.rt.execution.application.appmain.main(appmain.blank:140)    .caused by: blank.lang.nullpointerexception    .    at com.example.classwithbadstaticfinalfield.&lt;clinit&gt;(classwithbadstaticfinalfield.blank:17)    .    ... 34 more    ...classwithbadstaticfinalfield.blank..public abstract class classwithbadstaticfinalfield {.    protected static final string some_string = someridiculousclass.someinsanestaticmethodwhichdoesbadthings();..    public classwithbadstaticfinalfield() { // line 17..    }..    ....}    ...i have requested that classwithbadstaticfinalfield have an interface created which details all public methods, and so gets me out of this problem, but wheels turn slowly....when the production servers are not available  someridiculousclass.someinsanestaticmethodwhichdoesbadthings() null pointers..i would rather not have to intercept the outbound call made from someridiculousclass.someinsanestaticmethodwhichdoesbadthings() and force a response back."
