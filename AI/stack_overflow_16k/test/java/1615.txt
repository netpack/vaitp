"for double f, float g, how to find largest int i, such that i*g <= f update: thanks kevin, i meant &lt;= in the title, not &lt;...is this correct?  it's the best i've managed after an embarrassing amount of time on the problem:..public int candidate_answer(double f, float g) {.    int test = (int)math.floor(f / g);.    if ((test + 1) * g &lt;= f) {.        test++;.    }.    return test;.}...background:..the application is a simple game that i've taken over ownership for from a previous programmer.  curiously, he has chosen to mix floats and doubles wantonly, both in member and argument variables, so there's a lot of unnecessary implicit and explicit casting going up and down...the player coordinates are at double x, y (the player is assumed to be a point).  there is a float tile_size, and the world is some number of rows and columns worth of tiles, plus some generic out-of-bounds handling.  assuming the (x,y) coordinate is in bounds, i'm trying to figure out which tile the user is in, based on x (to get column) or y (to get row).  this is like, programmer 101...wlog, at first i was just doing col = (int)(x/tile_size).  but as i discovered, e.g., .5/.1f &lt; 5, and thus (int)(.5/.1f) == 4, the wrong answer.  this led to the above if statement and formulation of the problem...then i discovered that, e.g., (int)(-9.999999747378752e-5 / .1f) == 0, which led me to call math.floor first...but now i'm not sure what other bugs lurk in this approach, or what the best approach would be...(it may not seem like such a big deal if the user is right on the cusp of being in one row or another, and we accidentally round to the wrong one; but the real issue is in the code, where we see unexpected sign changes (+, -, 0).  for instance, some of the code assumes that if the user is on the tile at (r,c), then it's point is actually contained by that tile geometry.  when it's not, we get things like negative distances when only non-negative are expected, and etc., and it causes asserts to fire and while loops to break and so on.)"
