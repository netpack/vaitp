"filesystem implementation, listing file path through binary search tree i'm working on a filesystem implementation, and i'm having trouble with my binary search tree locate method. right now the way i have it structured. it will add additional files or something else that i'm unable to figure out...as an example, i have the tree:..      /.     / .    a   b.   /   / .  c   h   q. /.x...if the user inputs locate h, my program will output /acxh..when the user inputs locate h, the output should be /bh..here is my filesystem class:..import blank.io.ioexception;.import blank.util.arraylist;..public class filesystem {.private directory root;.private directory wdir;.private arraylist&lt;file&gt; files = new arraylist&lt;file&gt;();..// constructor.public filesystem() {..}..// constructor with parameters.public filesystem(directory root) {.    this.root = root;.    wdir = root;.    files.add(root);.}..// returns the filesystem's files.public arraylist&lt;file&gt; getfiles() {.    return files;.}..// returns the working directory.public directory getwdir() {.    return wdir;.}..// sets the working directory.public void setwdir(directory d) {.    wdir = d;.}..// returns the root file. this will always be / in our program.public file getroot() {.    return root;.}..public file getfile(file f, string name) {.    if (f.isdirectory()) {.        for (file c : ((directory) f).getchildren()) {.            if (c.getname().equals(name)).                return c;.        }.    }.    return null;.}..// currently only used in cat method, getfile is better.file findfile(file f, string name) {.    if (f.getname().equals(name)).        return f;.    file file = null;.    if (f.isdirectory()) {.        for (file c : ((directory) f).getchildren()) {.            file = findfile(c, name);.            if (file != null).                break;.        }.    }.    return file;.}..// returns true if file is found.boolean isfile(string name) {.    file file = null;.    file = getfile(wdir, name);.    if (file != null) {.        return true;.    }.    return false;.}..// creates directory.public void mkdir(string path) {.    files.add(new directory(path));..    int size = files.size();..    // sets the parent.    files.get(size - 1).setparent(wdir);.    // sets the child.    wdir.addchild(files.get(size - 1));.}..// changes working directory.public void cd(string s) {.    if (s.equals("".."")) {.        if (wdir != root) {.            wdir = wdir.getparent();.        }.    } else if (s.equals(""/"")) {.        wdir = root;.    } else {.        wdir = (directory) getfile(wdir, s);.    }..}..// provides absolute filename.public void pwd() {.    if (wdir == root) {.        system.out.println(""/"");.    } else {.        system.out.println(wdir.getpath());.    }.}..// lists children of current working directory.public void ls() {.    arraylist&lt;file&gt; children = wdir.getchildren();.    if (children != null) {.        for (int i = 0; i &lt; children.size(); i++) {.            string childname = children.get(i).getname();.            system.out.print(childname + "" "");.        }.    }.}..// lists children of file(s) inputted by user.public void ls(file f) {.    if (f instanceof textfile) {.        system.out.println(f.getpath());.    } else {.        arraylist&lt;file&gt; children = ((directory) f).getchildren();.        if (children != null) {.            for (int i = 0; i &lt; children.size(); i++) {.                string childname = children.get(i).getname();.                system.out.print(childname + "" "");.            }.        }.    }..}..public void recls(file f, string location) {.    system.out.println(location + "":"");.    ls(f);.    system.out.println("""");.    if (f.isdirectory()) {.        arraylist&lt;file&gt; children = ((directory) f).getchildren();..        for (file c : children) {.            location += ""/"" + c.getname();.        }.        for (file c : children) {.            recls(c, location);.        }.    }.}..// creates a textfile or edit's textfile's content if already exists in the.// tree.public void edit(string name, string content) {.    files.add(new textfile(name, content));..    // setting textfile parent.    files.get(files.size() - 1).setparent(wdir);.    // setting parent's child.    wdir.addchild(files.get(files.size() - 1));..}..// prints the content of textfile.public void cat(string name) {.    file f = findfile(root, name);.    system.out.println(((textfile) f).getcontent());.}..public void updatedb(indexer i) throws ioexception {.    i.index(files);.}..public string locate(string s, indexer i) {.    return i.locate(s);.}..}...here is my indexer class:..import blank.io.*;.import blank.util.*;..class entry implements comparable&lt;entry&gt; {.string word;.arraylist&lt;integer&gt; page = new arraylist&lt;integer&gt;();..entry(string word) {.    this.word = word;.}..public int compareto(entry e) {.    return word.compareto(e.word);.}.}..class indexer {..private binarysearchtree&lt;entry&gt; bst;..public void index(arraylist&lt;file&gt; files) throws ioexception {.    bst = new binarysearchtree&lt;entry&gt;();.    int filecount = 1;..    for (int i = 0; i &lt; files.size(); i++) {.        string name = files.get(i).getname();.        indexname(name, filecount++);.    }.}..private void indexname(string name, int filecount) {.    entry e = new entry(name);.    entry r = bst.find(e);.    if (r != null) {.        r.page.add(filecount);.    } else {.        e.page.add(filecount);.        bst.add(e);.    }.}..public string locate(string s) {.    entry e = new entry(s);.    arraylist&lt;string&gt; path = new arraylist&lt;string&gt;();.    bst.locatehelper(e, bst.root, path);..    string word = """";..    for (int i = 0; i &lt; path.size(); i++) {.        word += path.get(i);.    }..    return word;.}..}...here is my binarysearchtree class:..import blank.util.arraylist;..public class binarysearchtree&lt;e extends comparable&gt; extends binarytree&lt;e&gt; {..private boolean addreturn;.private e deleteditem;..boolean add(e item) {.    root = add(root, item);.    return addreturn;.}..private node&lt;e&gt; add(node&lt;e&gt; n, e item) {.    if (n == null) {.        addreturn = true;.        return new node&lt;e&gt;(item);.    } else if (item.compareto(n.data) == 0) {.        addreturn = false;.        return n;.    } else if (item.compareto(n.data) &lt; 0) {.        n.leftchild = add(n.leftchild, item);.        return n;.    } else {.        n.rightchild = add(n.rightchild, item);.        return n;.    }.}..public e find(e target) {.    return find(target, root);.}..private e find(e target, node&lt;e&gt; node) {.    if (node == null) {.        return null;.    }.    int result = target.compareto(node.data);.    if (result == 0) {.        return node.data;.    }.    if (result &lt; 0) {.        return find(target, node.leftchild);.    }.    return find(target, node.rightchild);.}..public string locatehelper(entry e, node&lt;entry&gt; node, arraylist&lt;string&gt; path) {.    if (node == null) {.        return null;.    }..    int result = e.compareto(node.data);.    if (result == 0) {.        path.add(node.data.word);.        return node.data.word;.    }.    if (result &lt; 0) {.        path.add(node.data.word);.        return locatehelper(e, node.leftchild, path);.    }.    path.add(node.data.word);.    return locatehelper(e, node.rightchild, path);.}..}...i apologize for having a lot of code in the post, i know i'm supposed to keep it minimal, but i'm sure you will need to look at these 3 classes at least to provide some help. if anything else is needed just let me know and i'll edit this post to provide it."
