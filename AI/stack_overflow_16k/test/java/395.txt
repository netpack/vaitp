"could someone expound why spliterators::trysplit uses an arithmetic progression to calculate the size of the returned spliterator? summary..the motivation for the arithmetic progression does not seem entirely clear from the implementation, and i would like to understand the details of its conception. ..specific questions...are there cases where this is superior to equal partitions of the elements?.are there jit effects to consider that make subsequent partitions more efficient than their predecessors?...my thoughts so far..given: progression p(i) = 1024*1 + 1024*2 + 1024*3 ... 1024*i...it seems that this design is less efficient when p(cores) > number of elements.it seems that this design is substantially less efficient when each element has a very high cost to process, and p(cores) >> number of elements (e.g. 8 very complex items).it seems that if the size of a collection were available before it is processed into a spliterable the size could be used to hint at a more optimal partitioning scheme. is this incorrect? if it is correct, why do we not do this?...thank you."
