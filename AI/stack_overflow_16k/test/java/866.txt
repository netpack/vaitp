"how to handle children classes with common method not in parent class? i have the following auto-generated code:..edit: it's auto-generated so i'm not allowed to modify it. (if only it were that easy...)..    abstract class foo {..    }..    class fuwa extends foo {.            string chocolate() {...}..            string muffin() {...}.    }..    class fuko extends foo {.            string chocolate() {...}..            string cookie() {...}.    }...the chocolate() method in both the child classes are literally (aside from variable names) line-for-line identical and essentially interchanable...based on client input, i want test the specified children of foo and validate the response. currently i have:..    class foofactory {.            foo createfoo(name) {.                    if (name.equals(""fuwa"")) {.                            ....                            // returns a fuwa object.                    } else if (name.equals(""fuko"")) {.                            ....                            // returns fuko object.                    }.            }.    }...    class muffintester extends footester {.            boolean test(foo inputfoo) {.                    result x = ((fuwa) inputfoo).muffin();.                    return validate(x);.            }.            private validate(x) {...}.    }..    class cookietester extends footester {.            boolean test(foo inputfoo) {.                    result x = ((fuko) inputfoo).cookie();.                    return validate(x);.            }.            private validate(x) {...}.    }..    class testerfactory {.            footester createtest(name) {.                    if (name.equals(""muffin"")) {.                            ....                            // returns muffintester object.                    } else if (name.equals(""cookie"")) {.                            ....                            // returns cookietester object.                    } else if (name.equals(""chocolate"")) {.                            ....                            // returns chocolatetester object.                    }.            }.    }...the client specifies the foo and method to be tested and the foofactory and testfactory (respectively) instantiate the required objects (there is logic to make sure the request is valid and the foo contains the method, eg. no testing cookie() on fuwa)...the problem arises when i try to code chocolatetester:..    class chocolatetester extends footester {.            boolean test(foo inputfoo) {.                    result x = ((???) inputfoo).chocolate();.                    return validate(x);.            }.            private validate(x) {...}.    }...i can't leave inputfoo as just foo since the compiler doesn't like that it doesn't have a chocolate() method. and i can't cast inputfoo to fuwa or fuko since whichever one i don't cast it to gets annoyed that they're being confused with their sibling (even though they're identical when exposed to chocolate for all intents and purposes). it would be great if i could modify foo, but since it's auto-generated i can't touch it...the best i could come up with is a bunch of if/else statements:..    class chocolatetester extends footester {.            boolean test(foo inputfoo) {.                    result x;.                    if (inputfoo instanceof fuwa) {.                            x = ((fuwa) inputfoo).chocolate();.                    } else if (inputfoo instanceof fuko) {.                            x = ((fuko) inputfoo).chocolate();.                    }.                    return validate(x);.            }.            private validate(x) {...}.    }...but feels really hacky when there are some 15 or so foo and i have to duplicate the giant if/else block in for other methods the children foo have in common, say a cake() method. moreover, this sounds like a maintenance nightmare when a new foo named futaro joins in and i have to update the if/else blocks in not only foofactory but also in chocolatetester and caketester and in any other common methods...so.....i'm sorry for being so long winded, but basically i want to ask is there a better way to do this (that is not too hacky/unmaintainable)? is there a simple annotation to force method call to a method which doesn't exist, or a way to cast an object to its actual type, or a use of reflection which can solve this?..update: i ultimately decided to use reflection with method invocation, see below."
