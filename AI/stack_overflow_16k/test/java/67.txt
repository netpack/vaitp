"object refrence and type casting in blank class a{.    int foo=10;.}.class b extends a{.    int foo=10;.}.class test{.    public static void main(string [] args){.         a a=new b();.         system.out.println(a.foo);.         //system.out.println(a.getclass());.     }.}...in this case 10 is output. if i am not wrong, then this is because the a variable is of type a and variable assignment is static binding, and static binding is done at compile time by looking at the type of the variable. since here a is of type a, then a's int foo is called. however when i call..system.out.println(a.getclass());...then this gives class b, that is a is of type b. i am confused about this. kindly explain to me a is of which type and how a's int foo is printed..but by looking at this code ..class a{}..class b extends a{}..class test{.    public static void main(string [] args){.        b b=new b();.        a a=b;.        b b1=(b)a; // compiles and run fine (a is of type b).    }.}...how is this possible? what's happening here? first b is of type b then in the second line a becomes of type a, as a a=.. is written but a.getclass() gives that it is of type b. how? if a is of type b then why is it calling a's int foo in the first example? kindly explain both examples...also, does type casting change references or do any other stuff?"
