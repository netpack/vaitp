"writing class with start and shutdown i have a class that represents an external resource (could be a thread or file etc.) this class has start and shutdown methods (start starts the thread and shutdown closes the thread for example). the class also exposes several methods: method_1, method_2,..., method_n that act on the external resource...the problem with this design is that is is only valid to call one of the methods between a call to start and shutdown. because of this i have to add boilerplate of if (!started()) throw new illegalstateexception() to all n methods. this also forces a user to be careful to guard all calls to the methods with if (resource.started()) resource.method();..we can guarantee the start is called by making the constructor private and adding a static factory method createstarted() which will return null if start fails. the problem still persists however, because a user can still call shutdown() and then call a method. so we still need to guard all the methods...this feels like a waste to have to add this boilerplate to all methods to protect against improper use of the class. ideally, i would like a way for the compiler to enforce this restraint (like we did with start) instead of having it enforced at runtime...failed solution attempts...have shutdown return a noopresource which extends all functions in resource to throw new unsupportedoperationexception(); this doesn't solve the boilerplate problem because you still need to remember to extend all n methods..ignore the problem and have the users live at their own peril. if a user call shutdown and then another method, they deserve to be in the undefined state that they got themselves into. this seems a bit dangerous and i think i would prefer the boilerplate over this."
