"postfixing unary operators with parentheses so hello guys, i have a new problem.x = square root, c = cos.how can i make: x ( ( 1 - c ( 30 ) ) / 2 ) to postfix: 1 30 c - 2 / x, it gives me this postfix: 1 30 2 / c - x..how can i convert the said infix to the said postfix? what precedence or associativity should i make it to? the infix of unary operators that i want to use in my program should be operator ( value ), i want it to have a parenthesis in between. im trying to make a scientific sort of calculator that's why..edit: here's what i have, what should i change or make?..private static final int l_assoc = 0;.    private static final int r_assoc = 1;..    private static final map&lt;string, int[]&gt; op = new hashmap&lt;string, int[]&gt;();.    static {.        op.put(""+"", new int[] { 0, l_assoc });.        op.put(""-"", new int[] { 0, l_assoc });.        op.put(""*"", new int[] { 5, l_assoc });   //precedence, associativity.        op.put(""/"", new int[] { 5, l_assoc });.        op.put(""%"", new int[] { 10, l_assoc });.                op.put(""x"", new int[] { 10, r_assoc });.                op.put(""s"", new int[] { 10, r_assoc });.                op.put(""c"", new int[] { 10, r_assoc });.                op.put(""t"", new int[] { 10, r_assoc });.        op.put(""^"", new int[] { 10, r_assoc });.    }..    public static boolean isassoc(string token, int type){.                if (!isop(token)) {.                throw new illegalargumentexception(""invalid token: "" + token);.            }.            if (op.get(token)[1] == type) {.                return true;.            }.            return false;.            }..        private static final int getprecedence(string t1, string t2) { .            if (!isop(t1) || !isop(t2)) {       .                throw new illegalargumentexception();.            }..            return op.get(t1)[0] - op.get(t2)[0];.        }....            public static boolean isop(string token){.                return op.containskey(token);.            }..            public static string[] infix2postfix(string[] infix) {.                arraylist&lt;string&gt; postfix = new arraylist&lt;string&gt;();.                stack&lt;string&gt; operatorstack = new stack&lt;string&gt;();.                for ( string tkn: infix ){.                    if (isop(tkn)){.                        while (!operatorstack.empty() &amp;&amp; isop(operatorstack.peek())) { ..                        if (( isassoc(tkn, l_assoc) &amp;&amp; getprecedence(tkn, operatorstack.peek()) &lt;= 0 ).                                ||.                                               (isassoc(tkn, r_assoc) &amp;&amp; getprecedence(tkn, operatorstack.peek()) &lt; 0)) .                                            {.                            postfix.add(operatorstack.pop());.                            continue;.                        }       .                        break;.                    }..                    operatorstack.push(tkn);.                } else if (tkn.equals(""("")) {.                    operatorstack.push(tkn);.                } else if (tkn.equals("")"")) {..                    while (!operatorstack.empty() &amp;&amp; !operatorstack.peek().equals(""("")) {.                        postfix.add(operatorstack.pop());.                    }.                } else { .                    postfix.add(tkn); // [s12].                }.            }.            while (!operatorstack.empty()) { ..                            if (isop(operatorstack.peek())==false){.                                string s = operatorstack.pop();.                                continue;.                            }.                                postfix.add(operatorstack.pop()); .            }.            string[] output = new string[postfix.size()];.            return postfix.toarray(output);.            }...my solution:.. else if (tkn.equals("")"")) {..                        while (!operatorstack.empty() &amp;&amp; !operatorstack.peek().equals(""("")) {.                            postfix.add(operatorstack.pop());.                        }.operatorstack.pop(); //i simply popped after the while loop to remove the matching open parenthesis.                    }"
