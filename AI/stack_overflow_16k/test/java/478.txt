"datadao class with a hundred static methods, how to refactor i have a datadao class that my servlets use for crud operations on several object types. when i started out i only had a few things to do with this class so it seemed ok. but now the project is getting bigger and bigger and every feature i add i have to add a new method to this class so i now have a ton of static methods. it seems like i should refactor this some how but not sure how. is there a design pattern i could use? or can someone explain why i should or should not worry about it ? i am only doing this for learning purpose so please don't tell me use some easy framework, i want to work with blank as granularly as possible. here is a typical example: ..public static arraylist&lt;card&gt; getcardsforuser(useraccount user) {..    //todo: get the username and password then get all flashcards linked to that user and return them in a list.    arraylist&lt;card&gt; cardsforuser = new arraylist&lt;&gt;();..    try(connection conn = drivermanager.getconnection(dburl, un, pw)) {.        preparedstatement pstm = conn.preparestatement(""select * from flashcard where fk_user_id = ?"");.        pstm.setstring(1,user.getuserid());.        resultset userscards = pstm.executequery();..        while(userscards.next()){.            string cat = userscards.getstring(""category"");.            if(cat == null) {.                cat = ""null"";.            }.            card card_new = new card(userscards.getstring(""card""),userscards.getstring(""answer""),userscards.getint(""cardid""),cat,userscards.getint(""times_right""),userscards.getint(""times_wrong""));.            cardsforuser.add(card_new);.        }.        system.out.println(""card for user size: ""+cardsforuser.size());..        return cardsforuser;...    } catch(sqlexception e) {.        //todo: what happens now ?.        e.printstacktrace();.        return null;.    }..}...my app basically is a way to create 'flashcards' to study with...i have tried to create an interface ""datadao"" then have a subclass for each different object implement that interface. but some of the operations don't perfectly align with the interface and it seems like a lot of unnecessary work. why is this a good or not a good approach ?"
