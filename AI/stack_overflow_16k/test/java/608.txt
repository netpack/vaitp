"scanner does not read text file in run mode i am trying to deal with this problem without much success. hope for some help..from inside my blank program, i am calling an outside executable, which upon completion creates a text (ascii) file. i am using..process p = runtime.getruntime().exec(""....exe"");`...next, i am asking for it to complete before switching ..int exitvalue = p.waitfor();...and make sure that exit value is 0...right after that, i am creating a scanner object to read the newly created file:..file outputfile = new file(outputfilename);.scanner scan = new scanner(outputfile);...the file resides in the same folder as the executable, but i am passing a full path to it anyway. .when i check if i can read the file (outputfile.canread()), the answer is true. .when i check the length of the file, it returns to me some number > 0, i.e., 440827..however, when i try to call scan.hasnextline() or even scan.hasnext(), the answer is negative..an interesting fact is that when i run this in netbeans debug mode, everything works fine. so, my guess is that i am in some sort of a race condition even though i am making precautions to not interrupt the process's thread..i tried to insert thread.sleep() statements before calling nextline(), but no result..any suggestions, please?..this was the simplified version of the code... upon requests, here is more detailed processing (spread between 4 classes) - i apologize for several levels of redirections:..public class a.{.    private void runengine().    {.        try.        {.        // skip irrelevant stuff - model is an object of class b:            .            model.runengineifneeded(keepinputfiles);.            outputfiletextarea.settext(.                model.processoutput(keepinputfiles, keepoutputfiles));.        //....        }.        catch (throwable ex).        {.            logger.log(level.severe, null, ex);.        }.    }..public class b    .{.    public void runengineifneeded(boolean keepinputfiles).        throws ioexception, interruptedexception.    {.        // exit under some condition, otherwise:.        boolean enginok = false;..        while(!enginok)             .             enginok = createenginfile(keepinputfiles);.    }.    public boolean createenginfile(boolean keepfile).    {.        string enginedir = ""c:/data"";     .        final string[] cmdarray = {""cmd"", ""/c"", b.exe_filename};.        // output is a 2-dimensional array of strings.       output = exec.getstderrandstdout(cmdarray, enginedir);..       if (output[1].isempty()).            return true; //no exception occur..      // do some data manipulation and....      return false;.    }..    public string processoutput(boolean keeploopininput, boolean keeploopinoutputs).                throws ioexception, interruptedexception.   {.       string enginoutput = null;..       while (enginoutput == null).       {.            enginoutput = c.processenginoutput();  // c is an obj of class c..        if (enginoutput == null).            createloopinfile(keepengineinput);.    }..    return enginoutput;.   }.}..public class exec.{.    public static string[] getstderrandstdout(string[] cmd, string directory).        throws ioexception, interruptedexception {.        string[] output = new string[2]; // 2 string array for output.        processbuilder processbuilder = new processbuilder(cmd);..        if (directory != null) {.            processbuilder.directory(new file(directory));.        }..        process process = processbuilder.start();.        execstreamredirect stdout = new execstreamredirect(process.getinputstream(), .                                                           outputtype.stdout);..       stdout.start();..       execstreamredirect stderr = new execstreamredirect(process.geterrorstream(),.                                                          outputtype.stderr);..       stderr.start();.       int waitfor = process.waitfor();..       output[0] = stdout.getstdout().tostring();.       output[1] = stderr.getstderr().tostring();.       return output;.    }.}..class c.{.    public string processenginoutput(float actktdls, boolean keepoutputs).                throws filenotfoundexception, interruptedexception,.                       ioexception.    { // read file into output text area:.        file analysisoutputfile    = new file(outputfilenamepath);.        scanner scan               = null;.        string scanline            = """";.        stringbuilder enginoutput = new stringbuilder(.                                        (int) analysisoutputfile.length());.        boolean outputfileok = false;..        // must be careful here, possibility for endless loop:.        stop: for (int i = 2000; i &lt; 4000 &amp;&amp; !outputfileok; i+= 100).        {.            int j = 0; // start counting lines..            try.            {.                if (genericutils.waitiffileisnotready(analysisoutputfile, j)).                 // does not exist &amp; readable.                    continue; // go to next iteration..                scan = new scanner(analysisoutputfile);..                for (; !outputfileok; j++).               {.                    scanline = scan.nextline();.                    enginoutput.append(scanline).append(""nn"");..               // .. more logic here;.               }..               // .. more logic here;..               scan.close();..               return enginoutput.tostring();.            } // end of try.            catch (nosuchelementexception ex).            { //eof reached.                 processenginedelay(.             ""output file is not completly written. last line read: "".                                 + j + "".  "" + scanline +.                                  "". wait "" + i + "" msecs."",.                                   scan,.                                   i);.            }  // continue [stop] with the next loop iteration....        } // repeat up to 20 times if needed       .    }..    private static void processenginedelay(string msg, scanner scan, int i).                throws interruptedexception.   {.        // to perform error processing.        logger.warning(msg);.        scan.close(); // close scan.        scan = null;.        thread.sleep(i);.   }.}...i think this is it... i apologize - the code is complicated and that was the reason why i initially provided simplified version only. hopefully i listed all relevant portions"
