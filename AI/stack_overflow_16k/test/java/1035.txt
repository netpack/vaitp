"how can i handle branching calculations in blank? i am trying to find the longest possible path based on how many connections a variable number has, without repeating connections. the way i thought of doing this was creating a list that holds all points that have already been gone through, but when a path ends, and i need to check a new path, all of those old connections remain in the list. how can i restart my list from the initial point?..putting it in the recursive function itself would just clear the list each time. is there a better option than using a list?..relevant code:..package testapp;..import blank.io.bufferedreader;.import blank.io.inputstreamreader;.import blank.util.arraylist;.import blank.io.ioexception;.import blank.util.list;..class testapp {   .    // store list of objects we have already matched with.    static list&lt;numberobject&gt; holdinglist = new arraylist&lt;numberobject&gt;();..    //test objects.    static int[] array1 = {2,2};.    static int[] array2 = {3,1};.    static int[] array3 = {2,1};.    static int[] array4 = {1,1};..    static numberobject eight = new numberobject(array1, 8);.    static numberobject two = new numberobject(array2, 2);.    static numberobject three = new numberobject(array3, 3);.    static numberobject four = new numberobject(array4, 4);.    // test objects ^^..    public static int longestsequence(int[][] grid) {.        // todo: implement this function.        // code exists here not relevant to the problem..        //setting up a new numberlist array for testing.        numberobject[] newnumberlist = {eight, two, three, four};.        numberobject[] connections1 = {two, four};.        numberobject[] connections2 = {two, three};.        //adding connections.        eight.connections = connections1;.        four.connections = connections2;..        for (numberobject s: newnumberlist){.          recursive(s);.        }.        return 0;.    }..    public static void recursive(numberobject object){.            for (numberobject x: holdinglist){.                system.out.println(x);.            }..            if (!holdinglist.contains(object)){.                holdinglist.add(object);..                if (object.hasconnections()){.                    numberobject[] newobject = object.getconnections();..                    for(numberobject y: newobject){.                        recursive(y);.                    }.                }.                else {.                    system.out.println(holdinglist.size());.                    return;.                }.            }.            else {.                system.out.println(holdinglist.size());.                return;.            }.        }...    public static void main(string[] args) throws ioexception {.        bufferedreader reader = new bufferedreader(new inputstreamreader(system.in));..        int numrows = 0;.        int numcols = 0;.        string[] firstline = reader.readline().split(""\s+"");.        numrows = integer.parseint(firstline[0]);.        numcols = integer.parseint(firstline[1]);..        int[][] grid = new int[numrows][numcols];..        for (int row = 0; row &lt; numrows; row++) {.            string[] inputrow = reader.readline().split(""\s+"");..            for (int col = 0; col &lt; numcols; col++) {.                grid[row][col] = integer.parseint(inputrow[col]);.            }.        }.        int length = longestsequence(grid);.        system.out.println(length);.    }.}..class numberobject {.    int[] id;.    int value;.    numberobject[] connections;.    //constructor.    public numberobject(int[] id, int value){.        this.id = id;.        this.value = value;.    }.    //print statement.    public string tostring(){.        return (""numberoject: id = "" + id + ""nvalue = "" + value);.    }.    //check if it has connections.    public boolean hasconnections(){.        if (connections == null){.            return false;.        }.        else if (connections.length != 0){.            return true;.        }.        else .            return false;.    }.    //return the connections it has.    public numberobject[] getconnections(){.        return connections;.    }.}...ideally, the image displays what i want to happen..instead, all the old branching connections remain on holdinglist. .it should be noted paths can branch off to more than two other objects."
