"inputstream/outputstream read()/write() function relevance and usage for blank.io.inputstream, there are two primary read functions int read() and public int read(byte[] b, int off, int len) ...similarly, for blank.io.outputstream there are two functions write(b) and write((byte[] b, int off, int len))..while i understand the basic difference, but on reading the description of write(b), it says that it says ""the byte to be written is the eight low-order bits of the argument b. the 24 high-order bits of b are ignored."". now if that's the case, then we are actually wasting the remaining 24 bits out of 32-bit instruction set which cpu would load for an integer. instead if i use the other write ((byte[] b, int off, int len)), then i am occupying heap/stack for the size of the byte array. while i am trying to think of which one works better for high scalability, i cant ignore that write(b) wastes 24 bits(3 bytes), while on the other hand if i use the read/write(byte[] b, int off, int len), i risk higher stack sizes. so, what is the best option to choose? ..in a workaround, i tried to extend inputstream and outputstream and override read(b) and write(b) functions by providing a byte[4] to use all the 32 bits. it works just fine, but still have to see if this has any performance enhancements. its very similar to using read/write(4, 0, int 4)..i will appreciate any help/comment on this topic."
