"breadth-first search implementation not working i have a problem with the implementation of the breadth-first search algorithm, i have a method that gives me an array of integers from 0-8, in random order. i also have an integer m that tells me which number is blank. here are the rules:..i get a block of numbers, like:..456           .782        .301...and lets say that 8 is the blank value, i can swap it with 5, 7, 2, and 0. since they are directly next to it. i have to use breadth-first search to solve this puzzle. here is the code i have written so far:..package application;..import blank.util.arraylist;.import blank.util.hashmap;.import blank.util.hashset;.import blank.util.iterator;.import blank.util.linkedhashset;.import blank.util.linkedlist;.import blank.util.list;.import blank.util.priorityqueue;.import blank.util.queue;.import blank.util.vector;..public class solution {..    /******************************************.     * implementation here.     ***************************************/..    /*.     * implementation here: you need to implement the breadth first search.     * method.     */.    /* please refer the instruction document for this function in details */..    public static linkedhashset&lt;int[]&gt; open = new linkedhashset&lt;int[]&gt;();.        public static hashset&lt;int[]&gt; closed = new hashset&lt;int[]&gt;();.    public static boolean state = false;.    public static int empty;..    public static void breadthfirstsearch(int[] num, int m, vector solution1) {.        int statesvisited = 0;.        for(int i : num) {.            if(num[i] == m) {.                empty = i;.            }.        }..        int[] start = num;.        int[] goal = {0,1,2,3,4,5,6,7,8};.        int[] x;.        int[] temp = {};..        open.add(start);..        while (open.isempty() == false &amp;&amp; state == false) {..            x = open.iterator().next();.            open.remove(x);..            int pos = empty; // get position of zero or empty space.            if (comparearray(x,goal)) {.                system.out.println(""success"");..                state = true;.            } else {.                // generate child nodes.                closed.add(x);..                temp = up(x, pos);.                if (temp != null).                    open.add(temp);.                temp = left(x, pos);.                if (temp != null).                    open.add(temp);.                temp = down(x, pos);.                if (temp != null).                    open.add(temp);.                temp = right(x, pos);.                if (temp != null).                    open.add(temp);.                if(open.isempty()) .                    system.out.println(""ending loop"");.            }.        }..    }.    public static boolean comparearray(int[] a, int[] b) {.        for(int i: a) .            if(a[i] != b[i]).                return false;..        return true;..    }..    public static int[] up(int[] s, int p) {.        int[] str = s;.        if (p &gt; 3) {.            int temp = str[p-3];.            str[p-3] = str[p];.            str[p] = temp;...        }.        // eliminates child of x if its on open or closed.        if (!open.contains(str) &amp;&amp; closed.contains(str) == false).            return str;.        else.            return null;.    }...    public static int[] down(int[] s, int p) {.        int[] str = s;.        if (p &lt; 6) {.            int temp = str[p+3];.            str[p+3] = str[p];.            str[p] = temp;..        }..        // eliminates child of x if its on open or closed.        if (!open.contains(str) &amp;&amp; closed.contains(str) == false).            return str;.        else.            return null;.    }...    public static int[] left(int[] s, int p) {.        int[] str = s;.        if (p != 0 &amp;&amp; p != 3 &amp;&amp; p != 6) {.            int temp = str[p-1];.            str[p-1] = str[p];.            str[p] = temp;..        }.        // eliminates child of x if its on open or closed.        if (!open.contains(str) &amp;&amp; closed.contains(str) == false).            return str;.        else.            return null;.    }...    public static int[] right(int[] s, int p) {.        int[] str = s;.        if (p != 2 &amp;&amp; p != 5 &amp;&amp; p != 8) {.            int temp = str[p+1];.            str[p+1] = str[p];.            str[p] = temp;.        }.        // eliminates child of x if its on open or closed.        if (!open.contains(str) &amp;&amp; closed.contains(str) == false).            return str;.        else.            return null;.    }.    public static void print(string s) {.        system.out.println(s.substring(0, 3));.        system.out.println(s.substring(3, 6));.        system.out.println(s.substring(6, 9));.        system.out.println();.    }.}...this code just immediately ends, and never finds an answer. perhaps i have done something wrong? please help...please note: this is my first question on stackoverflow, so if anyone has any criticisms please tell me and i will fix them right away."
