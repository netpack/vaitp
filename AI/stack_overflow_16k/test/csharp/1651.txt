"is cancellationtokensource shutting down correctly here's the entry point:..public class program.{.    private static readonly cancellationtokensource tokensource = new cancellationtokensource();..    public static void main(string[] args).    {.        // start the app.        new bootstrap().            .runasync(tokensource.token).            .wait();..        console.cancelkeypress += (sender, eventargs) =&gt;.        {.            tokensource.cancelafter(500);.        };.    }.}...here's the bootstrap:..public class bootstrap : ibootstrap.{.    private readonly iserver server;..    private readonly ilogger logger;..    public bootstrap(.        iserver server,.        ilogger logger).    {.        this.server = server;.        this.logger = logger;.    }..    public async task runasync(cancellationtoken token).    {.        this.logger.info(""application starting..."");..        await this.server.startasync(token);.    }.}...here's the server:..public abstract class baseserver : iserver.{.    private readonly ipaddress ipaddress;..    private readonly int port;..    private readonly ilogger logger;..    protected baseserver(.        string ipaddress, .        int port,.        ilogger logger).    {.        this.ipaddress = ipaddress.parse(ipaddress);.        this.port = port;.        this.logger = logger;.    }..    public async task startasync(cancellationtoken token).    {.        this.logger.debug(""[{0}] listening for connections using: {1}:{2}"", this.gettype().name, this.ipaddress.tostring(), this.port);.        var tcplistener = new tcplistener(this.ipaddress, this.port);..        tcplistener.start();..        while (!token.iscancellationrequested).        {.            await this.serverprocessorasync(tcplistener, token);.        }..        tcplistener.stop();.        console.writeline(""stopped listener"");.    }..    public abstract task serverprocessorasync(tcplistener listener, cancellationtoken token);.}...here's the server processor:..public class server : baseserver.{.    private readonly ilogger logger;..    public server(.        iappconfiguration configuration,.        ilogger logger) .        : base(configuration.ipaddress, configuration.port, logger).    {.        this.logger = logger;.    }..    public override async task serverprocessorasync(tcplistener listener, cancellationtoken token).    {.        this.logger.debug(""[{0}] waiting for connection..."", this.gettype().name);.        var client = await listener.accepttcpclientasync();..        this.logger.debug(""[{0}] spawning thread for connection..."", this.gettype().name);.        parallel.invoke(new paralleloptions.            {.                cancellationtoken = token,.                maxdegreeofparallelism = 10000,.                taskscheduler = taskscheduler.current.            }, () =&gt; this.listentoclient(client));.    }..    private void listentoclient(tcpclient client).    {.        var threadname = thread.currentthread.name;..        var bytes = new byte[2048];..        var stream = client.getstream();..        int i;.        while ((i = stream.read(bytes, 0, bytes.length)) != 0).        {.            var timestring = datetime.now.tolongtimestring();.            var currentres = encoding.utf8.getstring(bytes);.            var received = $""recieved [{threadname}] [{timestring}]:  {currentres}"";..            this.logger.info(received);.            var responsedata = encoding.utf8.getbytes(received);.            stream.write(responsedata, 0, responsedata.length);..        }..        client.close();.    }.}...will this correctly shut the app down when ctrl+c is pressed?..is there a way to debug this, or to know that the resources have been released properly...i assume that the while (!token.iscancellationrequested) will break when ctrl+c. i also assume that that if there are any threads created by parallel.invoke they will disposed of when the cancel is called...if in the case that:..console.cancelkeypress += (sender, eventargs) =&gt;.{.     tokensource.cancelafter(500);.};...doesn't wait for things to be cleared up, is there a better way than a timeout to make sure that everything is properly cleared up?"
