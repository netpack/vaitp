"what should you do if you have an interface with a collection of objects and you want both a read-only and a read-write version of the interface? i'm currently creating some interfaces for user controls that will contain collections of objects. i want to have an interface for a control that can have objects added from the outside, and another interface for one that cannot have objects added from the outside. so far i basically have the following (simplified for this question; if it would help you to see the actual code i have thus far please let me know): ..public interface ireadablefoo .{.    ireadonlycollection&lt;foo&gt; foos { get; }.}..public interface ireadwritefoo : ireadonlyfoo .{.    new icollection&lt;foo&gt; foos { get; }.}...what is considered the ""best practice"" to do in this situation where you have an interface with a collection of objects, and you want to have both a read-only version and a read-write version? is it considered acceptable to have an icollection&lt;foo&gt; shadowing an ireadonlycollection&lt;foo&gt; like that? ..is there some other pattern i should be using instead? should ireadonlyfoo and ireadwritefoo both inherit from a common base interface ifoo? ..edit: to clarify what i am trying to do, i'm adding the actual code that i'm working with here: ..public interface ioptionselector&lt;t&gt;.{..    ireadonlycollection&lt;t&gt; options { get; }.    t selectedoption { get; }.    event eventhandler selectedoptionchanged;.}..public interface iwriteableoptionselector&lt;t&gt; : ioptionselector&lt;t&gt;.{.    new icollection&lt;t&gt; options { get; }.    new t selectedoption { get; set; }.}"
