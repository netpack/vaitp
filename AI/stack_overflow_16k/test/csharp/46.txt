"parallel recursion in blank     class customdata.    {.       public int tnum;.       public int tresult;.    }..    public static int f_recursion(int n, int w).    {.        if (n == 0 || w == 0).            return 0;.        else if (s[n] &gt; w).            return f_recursion(n - 1, w);.        else.        {.            return math.max(f_recursion(n - 1, w), p[n] + f_recursion(n - 1, w - s[n]));.        }.    }..    public static int f_recursion2(int n, int w).    {.        int numba = 0;.        int countcpu = 8;.        task[] tasks = new task[countcpu];.          for (var j = 0; j &lt; countcpu; j++).            tasks[j] = task.factory.startnew(.               (object p) =&gt;.               {.                 var data = p as customdata; if (data == null) return;.                   data.tresult = f_recursion(n - data.tnum, w);.               },.            new customdata() { tnum = j });.          task.waitall(tasks);.          numba = (tasks[0].asyncstate as customdata).tresult.          + (tasks[1].asyncstate as customdata).tresult.          + (tasks[2].asyncstate as customdata).tresult.          + (tasks[3].asyncstate as customdata).tresult;..        return numba;.    }...how could i make f_recursion2 method to work in parallel? with my code current results are..time in milliseconds for recursion:  1,075.recursion(  150 ) =     7,237.time in milliseconds for parallel recursion:  1,581.recursion(  150 ) =    28,916...as you can see parallel approach prints 4 times bigger number and it takes more time to compute which doesn't make sense. how could i approach this problem that recursion would work in parallel?..edit changed for loop to parallel.for still same results as above...    public static int f_recursion2(int n, int w).    {.        int numba = 0;.        int countcpu = 8;.        task[] tasks = new task[countcpu];.        parallel.for(0, countcpu, j =&gt;.       {.           tasks[j] = task.factory.startnew(.              (object p) =&gt;.              {.                  var data = p as customdata; if (data == null) return;.                  data.tresult = f_recursion(n - data.tnum, w);.              },.           new customdata() { tnum = j });.       });.        task.waitall(tasks);.        numba = (tasks[0].asyncstate as customdata).tresult.        + (tasks[1].asyncstate as customdata).tresult.        + (tasks[2].asyncstate as customdata).tresult.        + (tasks[3].asyncstate as customdata).tresult;..        return numba;.    }"
