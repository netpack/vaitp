"timer just won't die (already!) for some time now i've been having this recurrent nightmare (read - bug in my application). for some reason, a certain timer continues to send ""elapsed"" events after i stopped it, even though in the event itself the timer ""admits"" to having been disabled! check this out:..//timer is created in class' constructor. class is not static..public pdaaccess ().{.  connectiontimeoutchecker = new system.timers.timer(1000);.  connectiontimeoutchecker.elapsed += new system.timers.elapsedeventhandler(connectiontimeoutchecker_elapsed);.}..void connectiontimeoutchecker_elapsed(object sender, system.timers.elapsedeventargs e).{ //_devicecontimeout eventually reaches a lot more than 10..  if (_devicecontimeout &gt; 10).  {.    connectiontimeoutchecker.stop(); //this is invoked but the timer does not stop..    if (ondevicesynctimeout != null) ondevicesynctimeout(this, null); //this gets fired all the time..  }.  _devicecontimeout++; //this keeps increasing and increasing..  //worth mentioning: sender = timer, sender.enabled = false (!) so then why is this executing?.}...as for where i start it: i start it in a single place, i put a breakpoint there and it doesn't execute more than once. and before you ask: no multiple threads are involved. i do work with threads in this application, but: the timer is not created in a thread, neither is the class...yet the .stop(); is executed 100 times and the timer still won't stop...i'm completely at a loss here. this behavior is so strange to me, it gives me that embarrassed feeling that i might have been missing something super-obvious. sometimes writing such a post helps me identify the problem before i hit the submit button (we all know the ""explaining to 3rd party"" effect). but it didn't hit me yet so i'm gonna hit the button and... see what you see ::- d."
