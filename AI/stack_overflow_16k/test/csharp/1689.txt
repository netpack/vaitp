"can't move instatiated object from queue, changes transform of prefab instead i'm trying to make a ""mania"" style game(like guitar hero). but i can't seem to get the movement of the ""notes"" to work, i keep the notes in a queue and i dequeue the last note and change it's position to the top again. but for some reason it doesen't work with my ""goodcubes"". only the normal ones ..the problem seems to be that the instead of moving the ""goodcube"" to the correct position it instead changes the transform of the prefab...all ""notes"" are referred to as ""cubes"" in script..for (int i = 0; i &lt; backlog; i++)//how many rows to spawn.{.    goodcubes.enqueue(instantiate(goodcube));.    for (int j = 0; j &lt; columns - 1; j++).    {.        badcubes.enqueue(instantiate(cube));.    }.}..//i check the player input and if it corresponds with a note in the correct row.//i have tested so both true and false option gets called.if (i == position) .{.    gameobject good = goodcubes.dequeue();.    good.transform.position = spawnpoint;.    spawnpoint += new vector2(1 * rowoffset, 0);.    goodcubes.enqueue(goodcube);.}.else.{.    gameobject badcube = badcubes.dequeue();.    badcube.transform.position = spawnpoint;`enter code here`.    spawnpoint += new vector2(1 * rowoffset, 0);.    badcubes.enqueue(badcube);.}...the full script..    public int columus;.    public gameobject cube;.    public gameobject goodcube;.    public event action movecubes;..    [serializefield] private int score = 0;.    [serializefield] private float rowoffset = 1;.    [serializefield] private float heightdifference = 1;.    [serializefield] private int backlog = 4;..    private float spawnheight;.    queue&lt;int&gt; positions = new queue&lt;int&gt;();.    queue&lt;gameobject&gt; badcubes = new queue&lt;gameobject&gt;();.    queue&lt;gameobject&gt; goodcubes = new queue&lt;gameobject&gt;();..    private void start().    {.        for (int i = 0; i &lt; backlog; i++).        {.            goodcubes.enqueue(instantiate(goodcube));.            for (int j = 0; j &lt; columus - 1; j++).            {.                badcubes.enqueue(instantiate(cube));.            }.        }..        for (int i = 0; i &lt; backlog; i++).        {.            positions.enqueue(spawnrow(i * heightdifference));.        }.    }..    int spawnrow(float y).    {.        int position = unityengine.random.range(0, columus);.        vector2 spawnpoint = new vector2(-columus * rowoffset / 2f, y);.        for (int i = 0; i &lt; columus; i++).        {.            if (i == position).            {.                gameobject goodcube = goodcubes.dequeue();.                goodcube.transform.position = spawnpoint;.                spawnpoint += new vector2(1 * rowoffset, 0);.                goodcubes.enqueue(goodcube);.            }.            else.            {.                gameobject badcube = badcubes.dequeue();.                badcube.transform.position = spawnpoint;.                spawnpoint += new vector2(1 * rowoffset, 0);.                badcubes.enqueue(badcube);.            }.        }.        return position;.    }..    private void update().    {.        if (input.getkeydown(keycode.d)).        {.            updatescore(0);.        }.        else if (input.getkeydown(keycode.f)).        {.            updatescore(1);.        }.        else if (input.getkeydown(keycode.j)).        {.            updatescore(2);.        }.        else if (input.getkeydown(keycode.k)).        {.            updatescore(3);.        }.    } //inputcheck..    private void updatescore(int input).    {.        if (positions.dequeue() == input).        {.            movecubes?.invoke();.            positions.enqueue(spawnrow(backlog * heightdifference + 1 * heightdifference));.            score++;.        }.        else.        {.            movecubes?.invoke();.            positions.enqueue(spawnrow(backlog * heightdifference + 1 * heightdifference));.            score--;.        }.    }"
