"error in my strongly connect components algorithm i'm trying to find the scc in a graph, the code i've written does a decent job but makes small mistakes...i've tried making small adjustments to the algorithm, but it has only ended up making things worse...public class graph..{.    public int _verticescount;.    public list&lt;int&gt;[] _vertexadjancedvertices; // i-th element contains info about all adjanced vertices of vertex #i..    public graph(int[,] edges).    {.        _verticescount = program.nkamers + 1;.        _vertexadjancedvertices = new list&lt;int&gt;[_verticescount];.        for (int i = 0; i &lt; _verticescount; ++i).            _vertexadjancedvertices[i] = new list&lt;int&gt;();.        for (int i = 0; i &lt; edges.getlength(0); ++i).            addedge(edges[i, 0], edges[i, 1]);.    }..    public void addedge(int vertex1, int vertex2).    {.        _vertexadjancedvertices[vertex1].add(vertex2);.    }.    public list&lt;list&lt;int&gt;&gt; getstronglyconnectedcomponents().    {.        //dfs.        var processed = new bool[_verticescount];.        var minconnectedvalue = new int[_verticescount];.        var scccompleted = new bool[_verticescount];.        int currenttime = 0;..        for (int startingvertex = 0; startingvertex &lt; _verticescount; ++startingvertex).            if (!processed[startingvertex]).                getstronglyconnectedcomponents(startingvertex, ref currenttime, processed, minconnectedvalue, scccompleted);..        var res = minconnectedvalue.select((mcv, i) =&gt; new { vertex = i, minconnectedvalue = mcv }).            .groupby(vmcv =&gt; vmcv.minconnectedvalue).            .select(g =&gt; g.select(vmcv =&gt; vmcv.vertex).tolist()).tolist();.        return res;.    }..    private void getstronglyconnectedcomponents(int vertex, ref int currenttime, bool[] processed, int[] minconnectedvalue, bool[] scccompleted).    {.        processed[vertex] = true;.        ++currenttime;.        //var currentdiscoverytime = currenttime;.        minconnectedvalue[vertex] = currenttime; // initialize to current time.        scccompleted[vertex] = false;.        foreach (var neighbour in _vertexadjancedvertices[vertex]).        {.            if (!processed[neighbour]).            {.                getstronglyconnectedcomponents(neighbour, ref currenttime, processed, minconnectedvalue, scccompleted);.                minconnectedvalue[vertex] = math.min(minconnectedvalue[vertex], minconnectedvalue[neighbour]); // if we will ever find cycle.            }.            else if (!scccompleted[minconnectedvalue[neighbour]]) // ignore references to completed sccs.            {.                minconnectedvalue[vertex] = math.min(minconnectedvalue[vertex], minconnectedvalue[neighbour]); // we've reached processed vertex - use it as a minconnectedvalue we could reach to (if smaller).            }.        }.        if (minconnectedvalue[vertex] == vertex) // we are going up to the stack, meaning that we are done with all the descendands.            scccompleted[vertex] = true; // mark as completed in case if we are the root of current scc.    }.};...with an input graph of: ...(1 4).(1 5).(2 3).(2 1).(3 2).(4 3).(5 7).(5 6).(6 8).(8 12).(7 9).(9 7).(9 11).(9 10).(10 8).(10 7).....the scc should be:(1,2,3,4)(5)(6)(7,9,10)(8)(11)(12)..my outcome is: (1,2,3,4)(5)(6,8)(7,9,10)(11)(12)"
