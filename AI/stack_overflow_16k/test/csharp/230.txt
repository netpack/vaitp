"1st, 2nd, 3rd and 4th partial derivatives of real data obtained from fftw are incorrect i calculated the 1st, 2nd and 3rd derivatives of sin(2.0*pi*j/lambda) (j varying from 0 to 255) by using fftw, fourier transforming it, multiplying by the appropriate and taking an inverse fourier transform. plans used were out of place, with dummy input and output arrays. the real part of the resulting array is half of that of the analytical result though. i took care of aliasing while taking the derivatives by choosing the appropriate value of kx/ky. just taking fftw and inverse fftw gave back the original array correctly...the value returned by fftw was half that of the analytical values for all the derivatives...if i do the same thing in the x direction (i instead of j), the values obtained are right only for the 1st derivative with respect to x, y derivatives are non-zero(the should be zero as variation is only in x) and the laplacian and biharmonic (4th derivative wrt x and y) are wrong...in both cases, the imaginary parts of the derivatives are non-zero and large...i tried a different plan using r2c and c2r instead, but that is giving the wrong values too. ..any suggestions will be helpful!..    void psiderivcalc(double *psi, double *dx, double *dy, double *del2, double *dxdel2, double *dydel2, double *del4)...{.    int i, j, ir, ir1, k;..fftw_complex *fdx, *fdy, *fdxdel2, *fdydel2, *fdel2, *fdel4, *out, *bt, *in;.fftw_plan p, q; ..out = (fftw_complex*) fftw_malloc(sizeof(fftw_complex) *n);.in = (fftw_complex*) fftw_malloc(sizeof(fftw_complex) *n);.bt = (fftw_complex*) fftw_malloc(sizeof(fftw_complex) *n);.fdx = (fftw_complex*) fftw_malloc(sizeof(fftw_complex) * n);.fdy = (fftw_complex*) fftw_malloc(sizeof(fftw_complex) * n);.fdxdel2 = (fftw_complex*) fftw_malloc(sizeof(fftw_complex) *n);.fdydel2 = (fftw_complex*) fftw_malloc(sizeof(fftw_complex) *n);.fdel2 = (fftw_complex*) fftw_malloc(sizeof(fftw_complex) *n);.fdel4 = (fftw_complex*) fftw_malloc(sizeof(fftw_complex) * n);..p = fftw_plan_dft_2d(lx, ly, in, bt, fftw_forward,fftw_measure);.q = fftw_plan_dft_2d(lx, ly, bt, out, fftw_backward,fftw_measure);..for(i = 0; i &lt; lx; i++).{ .    for(j = 0; j &lt; ly; j++).    { .        ir = j*lx + i; .        in[ir] = psi[ir] + 0.0*i; .    }.} ..fftw_execute(p); ..double kx, ky, pref; .int y1, x1, y2, x2; .kx = 2.0*pi/lx; .ky = 2.0*pi/ly;.for(i=0;i&lt;lx;i++).{.    for(j = 0; j &lt; ly; j++).    {.        ir = j*lx + i;.        if(i&lt;lx/2) .        {.            x1 = i; .            x2 = i;.        } .        else if(i==lx/2.0).        {.            x1 = 0; .            x2 = i;.        } .        else.        { .            x1 = i - lx; .            x2 = x1;.        }  .        if(j&lt;ly/2) .        {.            y1 = i; .            y2 = i;.        } .        else if(j==ly/2) .        {.            y1 = 0; .            y2 = j;.        } .        else.        { .            y1 = j - ly; .            y2 = y1;.        }.        pref = -1.0*(pow((kx*x2),2.0) + pow((ky*y2),2.0));.        fdx[ir] = -1.0*kx*x1*i*bt[ir]; .        fdy[ir] = -1.0*ky*y1*i*bt[ir]; .        fdel2[ir] = pref*bt[ir]; .        fdxdel2[ir] = -1.0*kx*i*x1*pref*bt[ir]; .        fdydel2[ir] = -1.0*ky*i*y1*pref*bt[ir]; .        fdel4[ir] = pref*pref*bt[ir];.    }.}..for(i = 0;i &lt; lx; i++).{ .    for(j = 0;j &lt; ly; j++).    { .        ir = j*lx + i; .        bt[ir] = fdx[ir]; .    }.}..fftw_execute(q); ..for(i = 0;i &lt; lx; i++).{ .    for(j = 0;j &lt; ly; j++).    { .        ir = j*lx + i; .        dx[ir] = creal(out[ir]) / (double)n; .    }.}...i found the other derivatives the same way as dx[ir](1st derivative wrt x) by changing bt[ir] each time before executing plan q, and out[ir] after execution. del2 is the laplacian, dxdel2 is derivative of the laplacian wrt x and del4 is the biharmonic...psi[ir] was correctly initialised to a sine function in j before passing it on to the function...    for(i = 0; i &lt; lx; i++).    { .        for(j = 0; j &lt; ly; j++).        {.            ir = j*lx + i; .            psi[ir] = sin(2.0*pi*j/lambda); .        }.    }  ...this is an example of the output for del2(fftw), del2a(analytical), dx, dxa and ir(index). lambda = 8, lx = 16 and ly = 16, n = lx*ly, so sin function is periodic in this domain...    0.308425    -0.616850   0.000000    0.000000    175.    -0.218090   -0.436179   0.000000    0.000000    191.    -0.000000   -0.000000   0.000000    0.000000    207.    0.218090    0.436179    0.000000    0.000000    223.    0.308425    0.616850    0.000000    0.000000    239.    0.218090    0.436179    0.000000    0.000000    255"
