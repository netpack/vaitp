"nested switch statements: architectural design issue i'm working on a project and my task is to add an advanced search and filtering option which allows the users to query desired results from a list of windows events by specifying as many conditions as they want. ..the idea is each windows event log has several properties such as logname, source, createddate, message, number, etc. (part of the fielditem enum). in total, there are four possbile data types: string, datetime, integral (int/long), and evententrytype. each of these four data types has its own collection of selector operands (part of the selectoroperator enum). here is a picture to give you a better idea of how the overall structure looks like:....my initial implementation of this idea is this:.. public static class searchprovider.{.    public static list&lt;eventlogitem&gt; searchinlogs(list&lt;eventlogitem&gt; currentlogs, searchquery query).    {.        switch (query.jointype).        {.            case conditionjointype.all:.                return searchall(currentlogs, query);.            case conditionjointype.any:.                return searchany(currentlogs, query);.            default:.                return null;.        }.    }..    private static list&lt;eventlogitem&gt; searchall(list&lt;eventlogitem&gt; currentlogs, searchquery query).    {.        foreach (searchcondition condition in query.conditions).        {.            switch (condition.fieldname).            {.                case fielditem.category:.                    switch (condition.selectoroperator).                    {.                        case selectoroperator.contains:.                            currentlogs = currentlogs.where(item =&gt; item.category.tolower().contains(condition.fieldvalue as string)).tolist();.                            break;.                        case selectoroperator.endswith:.                            currentlogs = currentlogs.where(item =&gt; item.category.tolower().endswith(condition.fieldvalue as string)).tolist();.                            break;.                        case selectoroperator.is:.                            currentlogs = currentlogs.where(item =&gt; string.equals(item.category, condition.fieldvalue as string, stringcomparison.ordinalignorecase)).tolist();.                            break;.                        case selectoroperator.startswith:.                            currentlogs = currentlogs.where(item =&gt; item.category.tolower().startswith(condition.fieldvalue as string)).tolist();.                            break;.                    }.                    break;.                case fielditem.instanceid:.                    switch (condition.selectoroperator).                    {.                        case selectoroperator.equals:.                            currentlogs = currentlogs.where(item =&gt; item.instanceid == long.parse(condition.fieldvalue as string)).tolist();.                            break;.                        case selectoroperator.isgreaterthan:.                            currentlogs = currentlogs.where(item =&gt; item.instanceid &gt; long.parse(condition.fieldvalue as string)).tolist();.                            break;.                        case selectoroperator.islessthan:.                            currentlogs = currentlogs.where(item =&gt; item.instanceid &lt; long.parse(condition.fieldvalue as string)).tolist();.                            break;.                    }.                    break;.                case fielditem.logname:.                    switch (condition.selectoroperator).                    {.                        case selectoroperator.contains:.                            currentlogs = currentlogs.where(item =&gt; item.logname.tolower().contains(condition.fieldvalue as string)).tolist();.                            break;.                        case selectoroperator.endswith:.                            currentlogs = currentlogs.where(item =&gt; item.logname.tolower().endswith(condition.fieldvalue as string)).tolist();.                            break;.                        case selectoroperator.is:.                            currentlogs = currentlogs.where(item =&gt; string.equals(item.logname, condition.fieldvalue as string, stringcomparison.ordinalignorecase)).tolist();.                            break;.                        case selectoroperator.startswith:.                            currentlogs = currentlogs.where(item =&gt; item.logname.tolower().startswith(condition.fieldvalue as string)).tolist();.                            break;.                    }.                    break;.                case fielditem.message:.                    switch (condition.selectoroperator).                    {.                        case selectoroperator.contains:.                            currentlogs = currentlogs.where(item =&gt; item.message.tolower().contains(condition.fieldvalue as string)).tolist();.                            break;.                        case selectoroperator.endswith:.                            currentlogs = currentlogs.where(item =&gt; item.message.tolower().endswith(condition.fieldvalue as string)).tolist();.                            break;.                        case selectoroperator.is:.                            currentlogs = currentlogs.where(item =&gt; string.equals(item.message, condition.fieldvalue as string, stringcomparison.ordinalignorecase)).tolist();.                            break;.                        case selectoroperator.startswith:.                            currentlogs = currentlogs.where(item =&gt; item.message.tolower().startswith(condition.fieldvalue as string)).tolist();.                            break;.                    }.                    break;.                case fielditem.number:.                    switch (condition.selectoroperator).                    {.                        case selectoroperator.equals:.                            currentlogs = currentlogs.where(item =&gt; item.number == int.parse(condition.fieldvalue as string)).tolist();.                            break;.                        case selectoroperator.isgreaterthan:.                            currentlogs = currentlogs.where(item =&gt; item.number &gt; int.parse(condition.fieldvalue as string)).tolist();.                            break;.                        case selectoroperator.islessthan:.                            currentlogs = currentlogs.where(item =&gt; item.number &lt; int.parse(condition.fieldvalue as string)).tolist();.                            break;.                    }.                    break;.                case fielditem.source:.                    switch (condition.selectoroperator).                    {.                        case selectoroperator.contains:.                            currentlogs = currentlogs.where(item =&gt; item.source.tolower().contains(condition.fieldvalue as string)).tolist();.                            break;.                        case selectoroperator.endswith:.                            currentlogs = currentlogs.where(item =&gt; item.source.tolower().endswith(condition.fieldvalue as string)).tolist();.                            break;.                        case selectoroperator.is:.                            currentlogs = currentlogs.where(item =&gt; string.equals(item.source, condition.fieldvalue as string, stringcomparison.ordinalignorecase)).tolist();.                            break;.                        case selectoroperator.startswith:.                            currentlogs = currentlogs.where(item =&gt; item.source.tolower().startswith(condition.fieldvalue as string)).tolist();.                            break;.                    }.                    break;.                case fielditem.type:.                    switch (condition.selectoroperator).                    {.                        case selectoroperator.is:.                            currentlogs = currentlogs.where(item =&gt; item.type == (eventlogentrytype)enum.parse(typeof(eventlogentrytype), condition.fieldvalue as string)).tolist();.                            break;.                        case selectoroperator.isnot:.                            currentlogs = currentlogs.where(item =&gt; item.type != (eventlogentrytype)enum.parse(typeof(eventlogentrytype), condition.fieldvalue as string)).tolist();.                            break;.                    }.                    break;.            }.        }..        return currentlogs;.    }...a sample query might look like this:..condition selector:..all of the conditions are met...conditions:..logname is ""application"".message contains ""error"".type isnot ""information"".instanceid islessthan 1934...as you can see, the searchall() method is quite long and not very maintainable due to the nested switch statements. the code works, however, i feel like this is not the most elegant way to implement this design. is there a better way to approach this problem? maybe by figuring out a way to reduce the complexity of the switch hierarchy or by making the code more generic? any help/suggestion is appreciated."
