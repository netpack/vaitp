"icomparable implementation - comparison operator overloading i'm studying the above mentioned and something interesting happened. to overload the comparison operators &lt; and &gt; i have to implement the compareto method from the icomparable interface. this method takes one parameter of type object, but in the example from the book i'm using, it wrote the method with a custom point type, like so:..public int compareto(point other) {.    if (this.x &gt; other.x &amp;&amp; this.y &gt; other.y).        return 1;.    if (this.x &lt; other.x &amp;&amp; this.y &lt; other.y).        return -1;.    else.        return 0;.}...when i write this in visual studio, the compiler says that the icomparable interface was not implemented..thinking that te problem was that the parameter passed was of point type, i passed the object type and casted it to a point type in the body of the method and it worked, like so:..public int compareto(object obj) {.    point other = (point)obj;.    if (this.x &gt; other.x &amp;&amp; this.y &gt; other.y).        return 1;.    if (this.x &lt; other.x &amp;&amp; this.y &lt; other.y).        return -1;.    else.        return 0;.}...the book doesnÂ´t mention anything about this. my question is: will this casting always be necessary in order for a interface to be considered as implemented by the compiler? or is the a more ""direct"" way of doing this?"
