# VAITP Info Agent (based on Gemini)

import os, requests, time, random, http.client, subprocess, sys, importlib
import google.generativeai as genai

genai.configure(api_key="AIzaSyB4z8OZU8r3uHD2aSEAuBPLnkdy0MoYLn4")
#model = genai.GenerativeModel("gemini-1.5-flash")
model = genai.GenerativeModel("gemini-2.0-flash-exp")

# Define time delay between requests
min = 30
max = 45

thinking_msg = "Thinking..."

def remove_first_and_last_line_if_match(text, first_match_string="```python", last_match_string="```"):
    # Split the text into lines
    lines = text.splitlines()

    # Check if the first line matches the specified first match string
    if lines and lines[0] == first_match_string:
        lines = lines[1:]  # Remove the first line

    # Check if the last line matches the specified last match string
    if lines and lines[-1] == last_match_string:
        lines = lines[:-1]  # Remove the last line

    # Join the remaining lines back into a single string
    return "\n".join(lines)

def load_external_module(module_path, module_name):
    """
    Dynamically load a module from the given path.
    """
    spec = importlib.util.spec_from_file_location(module_name, module_path)
    module = importlib.util.module_from_spec(spec)
    sys.modules[module_name] = module
    spec.loader.exec_module(module)
    return module

def process_vulnerabilities():

    vaitp_db = load_external_module("scrappers/0_vaitp_db.py","vaitp_db")

    rows = vaitp_db.execute_query("SELECT * FROM python_vulnerabilities ORDER BY `python_vulnerabilities`.`ID` DESC")

    # Process each row
    n=int(time.time())
    for row in rows:
        n=n+1
        delay = random.randint(min, max)
        cve = row[17]
        print(f'Reviewing vulnerability {cve}...')
        fullDescription = row[4]
        id = row[0]
        odc = row[1]
        cdc = row[2]
        vulnerabilityShortDescription = row[3]
        Score = row[6]
        cwe = row[8]
        owasp = row[10]
        acessibilityScope = row[11]
        category = row[12]
        subcategory = row[13]
        impact = row[14]
        solution = row[15]
        changeIn = row[16]
        fixedbyupgrading = row[18]
        patchedcodesample = row[19]
        vulnerablecodesample = row[20]
        payloadneeded = row[21]
        payload = row[22]
        isPython = row[25]
        if odc is None:
            print(f'Vulnerability {cve} is missing ODC!')
            queryString = f"Orthogonal Defect Classification categories: 'Function, Interface, Checking, Assignment, Timing/Serialization, Build/Package/Merge, Algorithm' ; Based on the provided Orthogonal Defect Classification categories, propose the Orthogonal Defects Classification category that best fits for the following vulnerability description: '{fullDescription}'. Reson if the category is the best fitting and reconsider if necessary. Only inlcude in the answer the best fitting category itself and nothing else."
            response = model.generate_content(queryString)
            response_value = response._result.candidates[0].content.parts[0].text
            print("Gemini AI Proposed:")
            print(response_value)
            if "I'm sorry" in response_value in response_value:
                print("Gemini could not propose ODC")
            else:
                query = "UPDATE python_vulnerabilities SET OrthogonalDefectClassification = %s WHERE CVE = %s"
                vaitp_db.execute_query(query,(response_value,cve))
                print(f"VAITP dataset updated {cve} with ODC {response_value}")
            print(thinking_msg)
            time.sleep(delay)
            
        if cdc is None: 
            print(f'Vulnerability {cve} is missing CDC!')
            queryString = f"Code Defect Classification categories: 'Missing Functionality,Incorrect Functionality,Extraneous Functionality,Missing Interface,Incorrect Interface,Extraneous Interface,Missing Check,Incorrect Check,Extraneous Check,Missing Assignment,Incorrect Assignment,Extraneous Assignment,Timing Issues,Serialization Issues,Extraneous Serialization,Building Issues,Packaging Issues,Merging Conflicts,Missing Algorithm,Incorrect Algorithm,Extraneous Algorithm' ; Based on the provided Code Defect Classification categories, propose the Coode Defects Classification category that best fits for the following vulnerability description: '{fullDescription}'. Note that we selected '{odc}' as the Orthogonal Defect Classification, so this Code Defect Classification should be coherent. Reson if the category is the best fitting and reconsider if necessary. Only inlcude in the answer the best fitting category itself and nothing else."
            response = model.generate_content(queryString)
            response_value = response._result.candidates[0].content.parts[0].text
            print("Gemini AI Proposed:")
            print(response_value)
            if "I'm sorry" in response_value in response_value:
                print("Gemini could not propose CDC")
            else:
                query = "UPDATE python_vulnerabilities SET CodeDefectClassification = %s WHERE CVE = %s"
                vaitp_db.execute_query(query,(response_value,cve))
                print(f"VAITP dataset updated {cve} with CDC {response_value}")
            print(thinking_msg)
            time.sleep(delay)

        if vulnerabilityShortDescription is None:
            print(f'Vulnerability {cve} is missing Short Description!')
            queryString = f"Provide a short description (aproximatly 75 chars) for the following vulnerability full description: '{fullDescription}'. Only include in your answer the short description of the vulnerability and nothing else."
            response = model.generate_content(queryString)
            response_value = response._result.candidates[0].content.parts[0].text
            print("Gemini AI Proposed:")
            print(response_value)
            if "I'm sorry" in response_value in response_value:
                print("Gemini could not propose Short Description...")
            else:
                query = "UPDATE python_vulnerabilities SET VulnerabilityShortDescription = %s WHERE CVE = %s"
                vaitp_db.execute_query(query,(response_value,cve))
                print(f"VAITP dataset updated {cve} with Short Description {response_value}")
            print(thinking_msg)
            time.sleep(delay)
            
        if Score == "0.0" or Score is None:
            print(f'Vulnerability {cve} is missing Score')
            queryString = f"Provide a good fitting score (between 1-10) for the following vulnerability description: '{fullDescription}'. Include only the score in your answer and nothing else."
            response = model.generate_content(queryString)
            response_value = response._result.candidates[0].content.parts[0].text
            print("Gemini AI Proposed:")
            print(response_value)
            if "I'm sorry" in response_value in response_value:
                print("Gemini could not propose Score")
            else:
                query = "UPDATE python_vulnerabilities SET Score = %s WHERE CVE = %s"
                vaitp_db.execute_query(query,(response_value,cve))
                print(f"VAITP dataset updated {cve} with Score {response_value}")
            print(thinking_msg)
            time.sleep(delay)
            
        if cwe is None:
            print(f'Vulnerability {cve} is missing CWE')
            queryString = f"Provide the best fitting CWE for the following vulnerability description: '{fullDescription}'. Include in your answer only the best fitting CWE number and nothing else."
            response = model.generate_content(queryString)
            response_value = response._result.candidates[0].content.parts[0].text
            print("Gemini AI Proposed:")
            print(response_value)
            if "I'm sorry" in response_value in response_value:
                print("Gemini could not propose CWE")
            else:
                query = "UPDATE python_vulnerabilities SET CWE = %s WHERE CVE = %s"
                vaitp_db.execute_query(query,(response_value,cve))
                print(f"VAITP dataset updated {cve} with CWE {response_value}")
            print(thinking_msg)
            time.sleep(delay)
            
        if owasp is None:
            print(f'Vulnerability {cve} is missing OWASP')
            queryString = f"Provide the best fitting OWASP category for the following vulnerability description: '{fullDescription}'. Only include in your answer the OWASP category in the format Axx Name (e.g.: A08 Software and Data Integrity Failures) and nothing else."
            response = model.generate_content(queryString)
            response_value = response._result.candidates[0].content.parts[0].text
            print("Gemini AI Proposed:")
            print(response_value)
            if "I'm sorry" in response_value in response_value:
                print("Gemini could not propose OWASP")
            else:
                query = "UPDATE python_vulnerabilities SET OWASP = %s WHERE CVE = %s"
                vaitp_db.execute_query(query,(response_value,cve))
                print(f"VAITP dataset updated {cve} with OWASP {response_value}")
            print(thinking_msg)
            time.sleep(delay)
            
        if acessibilityScope is None:
            print(f'Vulnerability {cve} is missing Acessibility Scope')
            queryString = f"Provide the best fitting Acessibility Scope (i.e.: 'Local' [if the vulnerability can only be exploited having local access to the system] or 'Remote' [if the vulnerability can be exploited from the network]) for the following vulnerability description: '{fullDescription}'. Include only the Accessibility Scope 'Local' or 'Remote' in your anwser accordingly, and nothing else."
            response = model.generate_content(queryString)
            response_value = response._result.candidates[0].content.parts[0].text
            print("Gemini AI Proposed:")
            print(response_value)
            if "I'm sorry" in response_value in response_value:
                print("Gemini could not propose Acessibility Scope")
            else:
                query = "UPDATE python_vulnerabilities SET AccessibilityScope = %s WHERE CVE = %s"
                vaitp_db.execute_query(query,(response_value,cve))
                print(f"VAITP dataset updated {cve} with Acessibility Scope {response_value}")
            print(thinking_msg)
            time.sleep(delay)
            
        if category is None:
            print(f'Vulnerability {cve} is missing Category')
            queryString = f"Provide the best fitting VAITP Category from the following list: 'Input Validation and Sanitization,\"Authentication, Authorization, and Session Management\",Cryptographic,Design Defects,Configuration Issues,Memory Corruption,Information Leakage,Race Conditions,Resource Management,Numeric Errors' that could represent the following vulnerability description: '{fullDescription}'. Include in your answer only the VAITP Category that best fits the vulnerability and nothing else."
            response = model.generate_content(queryString)
            response_value = response._result.candidates[0].content.parts[0].text
            print("Gemini AI Proposed:")
            print(response_value)
            if "I'm sorry" in response_value in response_value:
                print("Gemini could not propose Category")
            else:
                query = "UPDATE python_vulnerabilities SET Category = %s WHERE CVE = %s"
                vaitp_db.execute_query(query,(response_value,cve))
                print(f"VAITP dataset updated {cve} with Category {response_value}")
            print(thinking_msg)
            time.sleep(delay)
            
        if subcategory is None:
            print(f'Vulnerability {cve} is missing Subcategory')
            queryString = f"Provide the best fitting VAITP Subcategory from the following list of [VAITP Categories][VAITP Subcategories]: '[Input Validation and Sanitization][Command Injection,SQL Injection,Insecure Direct Object References (IDOR),Path Traversal,Insecure Parsing or Deserialization],[Authentication, Authorization, and Session Management][Weak Password Policies,Insecure Authentication Mechanisms,Session Management Issues,Privilege Escalation],[Cryptographic][Unencrypted communication,Weak encryption algorithm,Inadequate random number generation,Improper SSL/TLS Certificate Validation,Cryptographic Implementation Error],[Design Defects][Inadequate Error Handling,Vulnerable and Outdated Components,Poorly Designed Access Controls,Security Misconfigurations],[Configuration Issues][Cross-Site Scripting (XSS),Cross-Site Request Forgery (CSRF),Remote File Inclusion (RFI),Local File Inclusion (LFI),Open Redirects,Server-Side Request Forgery (SSRF),Dynamic Link Library (DLL) Loading Issues],[Memory Corruption][Buffer Overflows,Out-of-Bound Accesses,Use-After-Free Errors],[Information Leakage][Information Disclosure,Insecure Handling of Sensitive Data],[Race Conditions][Time-of-Check to Time-of-Use,Data Race Conditions in Threads,Race Condition in File Operations],[Resource Management][File Handle Leaks,Socket Handle Leaks,Memory Leaks,Resource Exhaustion],[Numeric Errors][Integer Overflows,Rounding Errors,Floating-Point Precision Issues,Arithmetic Errors]' for the following vulnerability description: '{fullDescription}'. Note that we already selected '{category}' as the main VAITP Category and only want the best fitting Subcategory. Include only the VAITP Subcategory in your answer and nothing else."
            response = model.generate_content(queryString)
            response_value = response._result.candidates[0].content.parts[0].text
            print("Gemini AI Proposed:")
            print(response_value)
            if "I'm sorry" in response_value in response_value:
                print("Gemini could not propose SubCategory")
            else:
                query = "UPDATE python_vulnerabilities SET Subcategory = %s WHERE CVE = %s"
                vaitp_db.execute_query(query,(response_value,cve))
                print(f"VAITP dataset updated {cve} with SubCategory {response_value}")
            print(thinking_msg)
            time.sleep(delay)
            
        if impact is None:
            print(f'Vulnerability {cve} is missing Impact')
            queryString = f"Provide the best fitting VAITP Impact Category from the following list 'Information Disclosure,Unauthorized Access,Data Theft,Arbitrary Code Execution,Privilege Escalation,Denial of Service (DoS)' for the following vulnerability description: '{fullDescription}'. In your answer provide only the best fitting VAITP Impact Category for this vulnerability and nothing else."
            response = model.generate_content(queryString)
            response_value = response._result.candidates[0].content.parts[0].text
            print("Gemini AI Proposed:")
            print(response_value)
            if "I'm sorry" in response_value in response_value:
                print("Gemini could not propose Impact")
            else:
                query = "UPDATE python_vulnerabilities SET Impact = %s WHERE CVE = %s"
                vaitp_db.execute_query(query,(response_value,cve))
                print(f"VAITP dataset updated {cve} with Impact {response_value}")
            print(thinking_msg)
            time.sleep(delay)
            
        if solution is None:
            print(f'Vulnerability {cve} is missing Solution')
            queryString = f"Provide the best possible solution for the following vulnerability description '{fullDescription}'. Provide only a very short solution in your answer that includes the version needed to upgrade if there is a patch for the vulnerability, and nothing else."
            response = model.generate_content(queryString)
            response_value = response._result.candidates[0].content.parts[0].text
            print("Gemini AI Proposed:")
            print(response_value)
            if "I'm sorry" in response_value in response_value:
                print("Gemini could not propose Solution")
            else:
                query = "UPDATE python_vulnerabilities SET Solution = %s WHERE CVE = %s"
                vaitp_db.execute_query(query,(response_value,cve))
                print(f"VAITP dataset updated {cve} with Solution {response_value}")
            print(thinking_msg)
            time.sleep(delay)
            
        if changeIn is None:
            print(f'Vulnerability {cve} is missing ChangeIn')
            queryString = f"Name where the change occoured (e.g.: A library name [answer the name of the library] or python [answer 'Python' and the version]) in the following vulnerability description '{fullDescription}'. Include only the name of where the change occoured in your answer and nothing else."
            response = model.generate_content(queryString)
            response_value = response._result.candidates[0].content.parts[0].text
            print("Gemini AI Proposed:")
            print(response_value)
            if "I'm sorry" in response_value in response_value:
                print("Gemini could not propose ChangeIn")
            else:
                query = "UPDATE python_vulnerabilities SET Changein = %s WHERE CVE = %s"
                vaitp_db.execute_query(query,(response_value,cve))
                print(f"VAITP dataset updated {cve} with ChangeIn {response_value}")
            print(thinking_msg)
            time.sleep(delay)
            
        if fixedbyupgrading is None:
            print(f'Vulnerability {cve} is missing fixedbyupgrading')
            queryString = f"Is the following vulnerability fixed by upgrading to a newer version of Python or a library? '{fullDescription}'. Answer only with the value '0' if the vulnerability can not be fixed by upgrading Python or a library, and the value '1' if the vulnerability can be fixed by upgrading Python or a library to a more recent version. Only answer with '0' or '1', and nothing else."
            response = model.generate_content(queryString)
            response_value = response._result.candidates[0].content.parts[0].text
            print("Gemini AI Proposed:")
            print(response_value)
            if "I'm sorry" in response_value in response_value:
                print("Gemini could not propose FixedByUpgrading")
            else:
                query = "UPDATE python_vulnerabilities SET Fixedbyupgrading = %s WHERE CVE = %s"
                vaitp_db.execute_query(query,(response_value,cve))
                print(f"VAITP dataset updated {cve} with FixedByUpgrading {response_value}")
            print(thinking_msg)
            time.sleep(delay)
            
        if patchedcodesample is None:
            print(f'Vulnerability {cve} is missing patchedcodesample')
            queryString = f"Provide a Python code that demonstrates how the vulnerability {cve} '{fullDescription}' was fixed. If it is not possible to provide the actual code for the vulnerability fix provide a code example that could represent the vulnerabiltiy as much as possible. Only include in your answer the Python code that fixes the vulnerability and nothing else."
            response = model.generate_content(queryString)
            response_value = remove_first_and_last_line_if_match(response._result.candidates[0].content.parts[0].text)
            print("Gemini AI Proposed:")
            print(response_value)
            if "I'm sorry" in response_value in response_value:
                print("Gemini could not propose PatchedCodeSample")
            else:
                query = "UPDATE python_vulnerabilities SET PatchedCodeSample = %s WHERE CVE = %s"
                vaitp_db.execute_query(query,(response_value,cve))
                print(f"VAITP dataset updated {cve} with PatchedCodeSample {response_value}")
                # Check if there is a file named "../../vaitp_dataset/train/injectable/{id}_1.py"
                injectablepy = f"../../vaitp_dataset/train/injectable/{id}_1.py"
                if os.path.exists(injectablepy):
                    print(f"Injectable Python file {injectablepy} exists")
                else:
                    # Save response_value to ../../vaitp_dataset/train/injectable/{id}_1.py
                    with open(f"../../vaitp_dataset/train/injectable/{id}_1.py", "w") as file:
                        file.write(response_value)
                    print(f"Injectable Python file {injectablepy} created")
            print(thinking_msg)
            time.sleep(delay)
            
        if vulnerablecodesample is None:
                print(f'Vulnerability {cve} is missing vulnerablecodesample')
                queryString = f"Provide a Python code that demonstrates how the vulnerability {cve} '{fullDescription}' was before it was fixed. If it is not possible to provide the actual code for the vulnerability provide a code example that could represent the vulnerabiltiy as much as possible. Only include in your answer the Python code before the vulnerability was fixed and nothing else."
                response = model.generate_content(queryString)
                response_value = remove_first_and_last_line_if_match(response._result.candidates[0].content.parts[0].text)
                print("Gemini AI Proposed:")
                print(response_value)
                if "I'm sorry" in response_value in response_value:
                    print("Gemini could not propose VulnerableCodeSample")
                else:
                    query = "UPDATE python_vulnerabilities SET VulnerableCodeSample = %s WHERE CVE = %s"
                    vaitp_db.execute_query(query,(response_value,cve))
                    print(f"VAITP dataset updated {cve} with VulnerableCodeSample {response_value}")
                    # Check if there is a file named "../../vaitp_dataset/train/noninjectable/{id}_1.py"
                    injectablepy = f"../../vaitp_dataset/train/noninjectable/{id}_1.py"
                    if os.path.exists(injectablepy):
                        print(f"Noninjectable Python file {injectablepy} exists")
                    else:
                        # Save response_value to ../../vaitp_dataset/train/noninjectable/{id}_1.py
                        with open(f"../../vaitp_dataset/train/noninjectable/{id}_1.py", "w") as file:
                            file.write(response_value)
                        print(f"Noninjectable Python file {injectablepy} created")
                print(thinking_msg)
                time.sleep(delay)
                
        if payloadneeded is None:
            print(f'Vulnerability {cve} is missing payloadneeded')
            queryString = f"Based on the vulnerability description {cve} '{fullDescription}', would a payload be required to exploit this vulnerability? Answer only with '0' if a payload would not be required and with '1' if a payload would be required to exploit, and nothing else."
            response = model.generate_content(queryString)
            response_value = response._result.candidates[0].content.parts[0].text
            print("Gemini AI Proposed:")
            print(response_value)
            if "I'm sorry" in response_value in response_value:
                print("Gemini could not propose Payloadneeded")
            else:
                query = "UPDATE python_vulnerabilities SET Payloadneeded = %s WHERE CVE = %s"
                vaitp_db.execute_query(query,(response_value,cve))
                print(f"VAITP dataset updated {cve} with Payloadneeded {response_value}")
            print(thinking_msg)
            time.sleep(delay)
            
        if payloadneeded and payload is None:
            print(f'Vulnerability {cve} is probably missing required payload')
            queryString = f"Based on the vulnerability description {cve} '{fullDescription}', what would be an example of an appropriate payload to exploit this vulnerability? Only include the payload code in your answer and nothing else."
            response = model.generate_content(queryString)
            response_value = response._result.candidates[0].content.parts[0].text
            print("Gemini AI Proposed:")
            print(response_value)
            if "I'm sorry" in response_value in response_value:
                print("Gemini could not propose Payload")
            else:
                query = "UPDATE python_vulnerabilities SET Payload = %s WHERE CVE = %s"
                vaitp_db.execute_query(query,(response_value,cve))
                print(f"VAITP dataset updated {cve} with Payload {response_value}")
            print(thinking_msg)
            time.sleep(delay)
            
        if isPython is None:
            print(f'Vulnerability {cve} is missing isPython')
            queryString = f"Based on the vulnerability description {cve} '{fullDescription}', would the vulnerability be coded in Python? Only answer with '0' if the vulnerability would not be coded in Python, and '1' if it would be coded in Python, and nothing else.",
            response = model.generate_content(queryString)
            response_value = response._result.candidates[0].content.parts[0].text
            print("Gemini AI Proposed:")
            print(response_value)
            if "I'm sorry" in response_value in response_value:
                print("Gemini could not propose isPython")
            else:
                query = "UPDATE python_vulnerabilities SET IsPython = %s WHERE CVE = %s"
                vaitp_db.execute_query(query,(response_value,cve))
                print(f"VAITP dataset updated {cve} with IsPython {response_value}")
            print(thinking_msg)
            time.sleep(delay)

    print("VAITP info agent finnished to review and propose missing data.")


if __name__ == "__main__":
    process_vulnerabilities()
    