assert re.match(br".+ HTTP/\\d\\.\\d\\r\\n$", start_line), "Start line does not look like HTTP request: " + repr(
start_line
)
self, host, port=None, key_file=None, cert_file=None, strict=None, timeout=None, proxy_info=None,
self, host, port=None, key_file=None, cert_file=None, strict=None, timeout=None, proxy_info=None,
gresult[0] = Exception("Request count expected={0} actual={1}".format(request_count, gcounter[0]))
if not undefined_body_length and proto != "HTTP/1.0" and "content-length" not in headers:
raise Exception("httplib2.tests.http_response_bytes: client could not figure response body length")
"{proto} {status}\\r\\n{headers}\\r\\n".format(proto=proto, status=status, headers=header_string).encode() + body
try:
auth_parsed = httplib2.auth._parse_www_authenticate(request.headers, "authorization")
print("debug: auth_parsed", auth_parsed)
except httplib2.error.MalformedHeader:
print("debug: auth header error")
scheme = auth_header.split(" ", 1)[0].lower()
print("debug: first auth scheme=\'{}\'".format(scheme))
auth_info = auth_parsed[scheme]
decoded = base64.b64decode(auth_info["token"]).decode()
body="auth-info opaque mismatch expected={} actual={}".format(server_opaque, client_opaque).encode()
ha1 = hasher(":".join((allow_username, realm, allow_password)).encode()).hexdigest()
":".join((ha1, client_nonce, client_nc, client_cnonce, client_qop, ha2)).encode()
":".join((ha1, client_nonce, client_nc, client_cnonce, client_qop, rspauth_ha2,)).encode()
"authentication-info": ", ".join(filter(None,
))
wsse_params = httplib2.auth._parse_www_authenticate(request.headers, "x-wsse").get("usernametoken", {})
print("debug: wsse_params", wsse_params)
client_username = wsse_params.get("username", "")
client_nonce = wsse_params.get("nonce", "")
client_created = wsse_params.get("created", "")
client_digest = wsse_params.get("passworddigest", "")
print("debug: check client={} == real={}".format(client_digest, digest_b64))
