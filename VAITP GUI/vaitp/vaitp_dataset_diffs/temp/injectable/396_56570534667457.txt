import BytesIO
import defer, protocol
import connectionDone
import ResponseDone
import PotentialDataLoss
import UNKNOWN_LENGTH
class BodyExceededMaxSize(Exception):

class _DiscardBodyWithMaxSizeProtocol(protocol.Protocol):

def __init__(self, deferred):
self.deferred = deferred
def _maybe_fail(self):
"""
Report a max size exceed error and disconnect the first time this is called.
"""
if not self.deferred.called:
self.deferred.errback(BodyExceededMaxSize())
self.transport.abortConnection()
def dataReceived(self, data) -> None:
self._maybe_fail()
def connectionLost(self, reason) -> None:
self._maybe_fail()
class _ReadBodyWithMaxSizeProtocol(protocol.Protocol):

def __init__(self, deferred, max_size):
self.stream = BytesIO()
self.deferred = deferred
self.length = 0
self.max_size = max_size
def dataReceived(self, data) -> None:
if self.deferred.called:
return
self.stream.write(data)
self.length += len(data)
if self.max_size is not None and self.length >= self.max_size:
self.deferred.errback(BodyExceededMaxSize())
self.transport.abortConnection()
def connectionLost(self, reason = connectionDone) -> None:
if self.deferred.called:
return
if reason.check(ResponseDone):
self.deferred.callback(self.stream.getvalue())
elif reason.check(PotentialDataLoss):
self.deferred.callback(self.stream.getvalue())
else:
self.deferred.errback(reason)
def read_body_with_max_size(response, max_size):
"""
Read a HTTP response body to a file-object. Optionally enforcing a maximum file size.
If the maximum file size is reached, the returned Deferred will resolve to a
Failure with a BodyExceededMaxSize exception.
Args:
response: The HTTP response to read from.
max_size: The maximum file size to allow.
Returns:
A Deferred which resolves to the read body.
"""
d = defer.Deferred()
if max_size is not None and response.length != UNKNOWN_LENGTH:
if response.length > max_size:
response.deliverBody(_DiscardBodyWithMaxSizeProtocol(d))
return d
response.deliverBody(_ReadBodyWithMaxSizeProtocol(d, max_size))
return d
