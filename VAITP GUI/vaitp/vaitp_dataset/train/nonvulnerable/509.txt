"def check_secure(line, conf, strict=None, ssh=None):
    """This method is used to check the content on the typed command.
    Its purpose is to forbid the user to user to override the lshell
    command restrictions.
    The forbidden characters are placed in the 'forbidden' variable.
    Feel free to update the list. Emptying it would be quite useless..: )

    A warning counter has been added, to kick out of lshell a user if he
    is warned more than X time (X being the 'warning_counter' variable).
    """

    # store original string
    oline = line

    # strip all spaces/tabs
    line = line.strip()

    # init return code
    returncode = 0

    # This logic is kept crudely simple on purpose.
    # At most we might match the same stanza twice
    # (for e.g. "'a'", 'a') but the converse would
    # require detecting single quotation stanzas
    # nested within double quotes and vice versa
    relist = re.findall(r'[^=]\"(.+)\"', line)
    relist2 = re.findall(r'[^=]\'(.+)\'', line)
    relist = relist + relist2
    for item in relist:
        if os.path.exists(item):
            ret_check_path, conf = check_path(item, conf, strict=strict)
            returncode += ret_check_path

    # ignore quoted text
    line = re.sub(r'\"(.+?)\"', '', line)
    line = re.sub(r'\'(.+?)\'', '', line)

    if re.findall('[:cntrl:].*\n', line):
        ret, conf = warn_count('syntax',
                               oline,
                               conf,
                               strict=strict,
                               ssh=ssh)
        return ret, conf

    for item in conf['forbidden']:
        # allow '&&' and '||' even if singles are forbidden
        if item in ['&', '|']:
            if re.findall("[^\%s]\%s[^\%s]" % (item, item, item), line):
                ret, conf = warn_count('syntax',
                                       oline,
                                       conf,
                                       strict=strict,
                                       ssh=ssh)
                return ret, conf
        else:
            if item in line:
                ret, conf = warn_count('syntax',
                                       oline,
                                       conf,
                                       strict=strict,
                                       ssh=ssh)
                return ret, conf

    # check if the line contains $(foo) executions, and check them
    executions = re.findall('\$\([^)]+[)]', line)
    for item in executions:
        # recurse on check_path
        ret_check_path, conf = check_path(item[2:-1].strip(),
                                          conf,
                                          strict=strict)
        returncode += ret_check_path

        # recurse on check_secure
        ret_check_secure, conf = check_secure(item[2:-1].strip(),
                                              conf,
                                              strict=strict)
        returncode += ret_check_secure

    # check for executions using back quotes '`'
    executions = re.findall('\`[^`]+[`]', line)
    for item in executions:
        ret_check_secure, conf = check_secure(item[1:-1].strip(),
                                              conf,
                                              strict=strict)
        returncode += ret_check_secure

    # check if the line contains ${foo=bar}, and check them
    curly = re.findall('\$\{[^}]+[}]', line)
    for item in curly:
        # split to get variable only, and remove last character "}"
        if re.findall(r'=|\+|\?|\-', item):
            variable = re.split('=|\+|\?|\-', item, 1)
        else:
            variable = item
        ret_check_path, conf = check_path(variable[1][:-1],
                                          conf,
                                          strict=strict)
        returncode += ret_check_path

    # if unknown commands where found, return 1 and don't execute the line
    if returncode > 0:
        return 1, conf
    # in case the $(foo) or `foo` command passed the above tests
    elif line.startswith('$(') or line.startswith('`'):
        return 0, conf

    # in case ';', '|' or '&' are not forbidden, check if in line
    lines = []

    # corrected by Alojzij Blatnik #48
    # test first character
    if line[0] in ["&", "|", ";"]:
        start = 1
    else:
        start = 0

    # split remaining command line
    for i in range(1, len(line)):
        # in case \& or \| or \; don't split it
        if line[i] in ["&", "|", ";"] and line[i - 1] != "\\":
            # if there is more && or || skip it
            if start != i:
                lines.append(line[start:i])
            start = i + 1

    # append remaining command line
    if start != len(line):
        lines.append(line[start:len(line)])

    # remove trailing parenthesis
    line = re.sub('\)$', '', line)
    for separate_line in lines:
        separate_line = " ".join(separate_line.split())
        splitcmd = separate_line.strip().split(' ')
        command = splitcmd[0]
        if len(splitcmd) > 1:
            cmdargs = splitcmd
        else:
            cmdargs = None

        # in case of a sudo command, check in sudo_commands list if allowed
        if command == 'sudo':
            if type(cmdargs) == list:
                # allow the -u (user) flag
                if cmdargs[1] == '-u' and cmdargs:
                    sudocmd = cmdargs[3]
                else:
                    sudocmd = cmdargs[1]
                if sudocmd not in conf['sudo_commands'] and cmdargs:
                    ret, conf = warn_count('sudo command',
                                           oline,
                                           conf,
                                           strict=strict,
                                           ssh=ssh)
                    return ret, conf

        # if over SSH, replaced allowed list with the one of overssh
        if ssh:
            conf['allowed'] = conf['overssh']

        # for all other commands check in allowed list
        if command not in conf['allowed'] and command:
            ret, conf = warn_count('command',
                                   command,
                                   conf,
                                   strict=strict,
                                   ssh=ssh)
            return ret, conf
    return 0, conf"