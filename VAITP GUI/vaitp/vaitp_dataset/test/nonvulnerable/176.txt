"    def parse_header(self, header_plus):        """        Parses the header_plus block of text (the headers plus the        first line of the request).        """        index = header_plus.find(b"\r\n")        if index >= 0:            first_line = header_plus[:index].rstrip()            header = header_plus[index + 2 :]        else:            raise ParsingError("HTTP message header invalid")        if b"\r" in first_line or b"\n" in first_line:            raise ParsingError("Bare CR or LF found in HTTP message")        self.first_line = first_line  # for testing        lines = get_header_lines(header)        headers = self.headers        for line in lines:            index = line.find(b":")            if index > 0:                key = line[:index]                if b"_" in key:                    continue                value = line[index + 1 :].strip()                key1 = tostr(key.upper().replace(b"-", b"_"))                # If a header already exists, we append subsequent values                # seperated by a comma. Applications already need to handle                # the comma seperated values, as HTTP front ends might do                # the concatenation for you (behavior specified in RFC2616).                try:                    headers[key1] += tostr(b", " + value)                except KeyError:                    headers[key1] = tostr(value)            # else there's garbage in the headers?        # command, uri, version will be bytes        command, uri, version = crack_first_line(first_line)        version = tostr(version)        command = tostr(command)        self.command = command        self.version = version        (            self.proxy_scheme,            self.proxy_netloc,            self.path,            self.query,            self.fragment,        ) = split_uri(uri)        self.url_scheme = self.adj.url_scheme        connection = headers.get("CONNECTION", "")        if version == "1.0":            if connection.lower() != "keep-alive":                self.connection_close = True        if version == "1.1":            # since the server buffers data from chunked transfers and clients            # never need to deal with chunked requests, downstream clients            # should not see the HTTP_TRANSFER_ENCODING header; we pop it            # here            te = headers.pop("TRANSFER_ENCODING", "")            if te.lower() == "chunked":                self.chunked = True                buf = OverflowableBuffer(self.adj.inbuf_overflow)                self.body_rcv = ChunkedReceiver(buf)            expect = headers.get("EXPECT", "").lower()            self.expect_continue = expect == "100-continue"            if connection.lower() == "close":                self.connection_close = True        if not self.chunked:            try:                cl = int(headers.get("CONTENT_LENGTH", 0))            except ValueError:                cl = 0            self.content_length = cl            if cl > 0:                buf = OverflowableBuffer(self.adj.inbuf_overflow)                self.body_rcv = FixedStreamReceiver(cl, buf)"