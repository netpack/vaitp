"    def _check_signature(self, decoded_xml, item, node_name=NODE_NAME, origdoc=None, id_attr='', must=False, only_valid_cert=False, issuer=None):        try:            _issuer = item.issuer.text.strip()        except AttributeError:            _issuer = None        if _issuer is None:            try:                _issuer = issuer.text.strip()            except AttributeError:                _issuer = None        # More trust in certs from metadata then certs in the XML document        if self.metadata:            try:                _certs = self.metadata.certs(_issuer, 'any', 'signing')            except KeyError:                _certs = []            certs = []            for cert in _certs:                if isinstance(cert, six.string_types):                    content = pem_format(cert)                    tmp = make_temp(content,                                    suffix=".pem",                                    decode=False,                                    delete_tmpfiles=self.delete_tmpfiles)                    certs.append(tmp)                else:                    certs.append(cert)        else:            certs = []        if not certs and not self.only_use_keys_in_metadata:            logger.debug('==== Certs from instance ====')            certs = [                make_temp(content=pem_format(cert),                          suffix=".pem",                          decode=False,                          delete_tmpfiles=self.delete_tmpfiles)                for cert in cert_from_instance(item)            ]        else:            logger.debug('==== Certs from metadata ==== %s: %s ====', _issuer, certs)        if not certs:            raise MissingKey(_issuer)        # saml-core section "5.4 XML Signature Profile" defines constrains on the        # xmldsig-core facilities. It explicitly dictates that enveloped signatures        # are the only signatures allowed. This mean that:        # * Assertion/RequestType/ResponseType elements must have an ID attribute        # * signatures must have a single Reference element        # * the Reference element must have a URI attribute        # * the URI attribute contains an anchor        # * the anchor points to the enclosing element's ID attribute        references = item.signature.signed_info.reference        signatures_must_have_a_single_reference_element = len(references) == 1        the_Reference_element_must_have_a_URI_attribute = (            signatures_must_have_a_single_reference_element            and hasattr(references[0], "uri")        )        the_URI_attribute_contains_an_anchor = (            the_Reference_element_must_have_a_URI_attribute            and references[0].uri.startswith("#")            and len(references[0].uri) > 1        )        the_anchor_points_to_the_enclosing_element_ID_attribute = (            the_URI_attribute_contains_an_anchor            and references[0].uri == "#{id}".format(id=item.id)        )        validators = {            "signatures must have a single reference element": (                signatures_must_have_a_single_reference_element            ),            "the Reference element must have a URI attribute": (                the_Reference_element_must_have_a_URI_attribute            ),            "the URI attribute contains an anchor": (                the_URI_attribute_contains_an_anchor            ),            "the anchor points to the enclosing element ID attribute": (                the_anchor_points_to_the_enclosing_element_ID_attribute            ),        }        if not all(validators.values()):            error_context = {                "message": "Signature failed to meet constraints on xmldsig",                "validators": validators,                "item ID": item.id,                "reference URI": item.signature.signed_info.reference[0].uri,                "issuer": _issuer,                "node name": node_name,                "xml document": decoded_xml,            }            raise SignatureError(error_context)        verified = False        last_pem_file = None        for pem_fd in certs:            try:                last_pem_file = pem_fd.name                if self.verify_signature(                        decoded_xml,                        pem_fd.name,                        node_name=node_name,                        node_id=item.id,                        id_attr=id_attr):                    verified = True                    break            except XmlsecError as exc:                logger.error('check_sig: %s', exc)                pass            except Exception as exc:                logger.error('check_sig: %s', exc)                raise        if verified or only_valid_cert:            if not self.cert_handler.verify_cert(last_pem_file):                raise CertificateError('Invalid certificate!')        else:            raise SignatureError('Failed to verify signature')        return item"