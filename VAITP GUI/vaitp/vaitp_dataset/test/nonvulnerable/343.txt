"    def mint_token(self, preview=False):        decimals = int(self.token_dec.value())        mint_baton_vout = 2 if self.token_baton_to_e.text() != '' and not self.token_fixed_supply_cb.isChecked() else None        init_mint_qty = self.token_qty_e.get_amount()        if init_mint_qty is None:            self.show_message(_("Invalid token quantity entered."))            return        if init_mint_qty > (2 ** 64) - 1:            maxqty = format_satoshis_plain_nofloat((2 ** 64) - 1, decimals)            self.show_message(_("Token output quantity is too large. Maximum %s.")%(maxqty,))            return        outputs = []        try:            token_id_hex = self.token_id_e.text()            token_type = self.wallet.token_types[token_id_hex]['class']            slp_op_return_msg = buildMintOpReturnOutput_V1(token_id_hex, mint_baton_vout, init_mint_qty, token_type)            outputs.append(slp_op_return_msg)        except OPReturnTooLarge:            self.show_message(_("Optional string text causiing OP_RETURN greater than 223 bytes."))            return        except Exception as e:            traceback.print_exc(file=sys.stdout)            self.show_message(str(e))            return        try:            addr = self.parse_address(self.token_pay_to_e.text())            outputs.append((TYPE_ADDRESS, addr, 546))        except:            self.show_message(_("Enter a Mint Receiver Address in SLP address format."))            return        if not self.token_fixed_supply_cb.isChecked():            try:                addr = self.parse_address(self.token_baton_to_e.text())                outputs.append((TYPE_ADDRESS, addr, 546))            except:                self.show_message(_("Enter a Baton Address in SLP address format."))                return        # IMPORTANT: set wallet.sedn_slpTokenId to None to guard tokens during this transaction        self.main_window.token_type_combo.setCurrentIndex(0)        assert self.main_window.slp_token_id == None        coins = self.main_window.get_coins()        fee = None        try:            baton_input = self.main_window.wallet.get_slp_token_baton(self.token_id_e.text())        except SlpNoMintingBatonFound as e:            self.show_message(_("No baton exists for this token."))            return        desired_fee_rate = 1.0  # sats/B, just init this value for paranoia        try:            tx = self.main_window.wallet.make_unsigned_transaction(coins, outputs, self.main_window.config, fee, None, mandatory_coins=[baton_input])            desired_fee_rate = tx.get_fee() / tx.estimated_size()  # remember the fee coin chooser & wallet gave us as a fee rate so we may use it below after adding baton to adjust fee downward to this rate.        except NotEnoughFunds:            self.show_message(_("Insufficient funds"))            return        except ExcessiveFee:            self.show_message(_("Your fee is too high.  Max is 50 sat/byte."))            return        except BaseException as e:            traceback.print_exc(file=sys.stdout)            self.show_message(str(e))            return        def tx_adjust_change_amount_based_on_baton_amount(tx, desired_fee_rate):            ''' adjust change amount (based on amount added from baton) '''            if len(tx._outputs) not in (3,4):                # no change, or a tx shape we don't know about                self.print_error(f"Unkown tx shape, not adjusting fee!")                return            chg = tx._outputs[-1]  # change is always the last output due to BIP_LI01 sorting            assert len(chg) == 3, "Expected tx output to be of length 3"            if not self.main_window.wallet.is_mine(chg[1]):                self.print_error(f"Unkown change address {chg[1]}, not adjusting fee!")                return            chg_amt = chg[2]            if chg_amt <= 546:                # if change is 546, then the BIP_LI01 sorting doesn't guarantee                # change output is at the end.. so we don't know which was                # changed based on the heuristics this code relies on.. so..                # Abort! Abort!                self.print_error("Could not determine change output, not adjusting fee!")                return            curr_fee, curr_size = tx.get_fee(), tx.estimated_size()            fee_rate = curr_fee / curr_size            diff = math.ceil((fee_rate - desired_fee_rate) * curr_size)            if diff > 0:                tx._outputs[-1] = (chg[0], chg[1], chg[2] + diff)  # adjust the output                self.print_error(f"Added {diff} sats to change to maintain fee rate of {desired_fee_rate:0.2f}, new fee: {tx.get_fee()}")        tx_adjust_change_amount_based_on_baton_amount(tx, desired_fee_rate)        if preview:            show_transaction(tx, self.main_window, None, False, self)            return        msg = []        if self.main_window.wallet.has_password():            msg.append("")            msg.append(_("Enter your password to proceed"))            password = self.main_window.password_dialog('\n'.join(msg))            if not password:                return        else:            password = None        tx_desc = None        def sign_done(success):            if success:                if not tx.is_complete():                    show_transaction(tx, self.main_window, None, False, self)                    self.main_window.do_clear()                else:                    self.main_window.broadcast_transaction(tx, tx_desc)        self.main_window.sign_tx_with_password(tx, sign_done, password)        self.mint_button.setDisabled(True)        self.close()"