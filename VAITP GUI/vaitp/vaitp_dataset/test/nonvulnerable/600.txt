"def accounts_register(request: HttpRequest) -> HttpResponse:    key = request.POST['key']    confirmation = Confirmation.objects.get(confirmation_key=key)    prereg_user = confirmation.content_object    email = prereg_user.email    realm_creation = prereg_user.realm_creation    password_required = prereg_user.password_required    is_realm_admin = prereg_user.invited_as == PreregistrationUser.INVITE_AS['REALM_ADMIN'] or realm_creation    is_guest = prereg_user.invited_as == PreregistrationUser.INVITE_AS['GUEST_USER']    try:        validators.validate_email(email)    except ValidationError:        return render(request, "zerver/invalid_email.html", context={"invalid_email": True})    if realm_creation:        # For creating a new realm, there is no existing realm or domain        realm = None    else:        if get_subdomain(request) != prereg_user.realm.string_id:            return render_confirmation_key_error(                request, ConfirmationKeyException(ConfirmationKeyException.DOES_NOT_EXIST))        realm = prereg_user.realm        try:            email_allowed_for_realm(email, realm)        except DomainNotAllowedForRealmError:            return render(request, "zerver/invalid_email.html",                          context={"realm_name": realm.name, "closed_domain": True})        except DisposableEmailError:            return render(request, "zerver/invalid_email.html",                          context={"realm_name": realm.name, "disposable_emails_not_allowed": True})        except EmailContainsPlusError:            return render(request, "zerver/invalid_email.html",                          context={"realm_name": realm.name, "email_contains_plus": True})        if realm.deactivated:            # The user is trying to register for a deactivated realm. Advise them to            # contact support.            return redirect_to_deactivation_notice()        try:            validate_email_for_realm(realm, email)        except ValidationError:            return HttpResponseRedirect(reverse('django.contrib.auth.views.login') + '?email=' +                                        urllib.parse.quote_plus(email))    name_validated = False    full_name = None    require_ldap_password = False    if request.POST.get('from_confirmation'):        try:            del request.session['authenticated_full_name']        except KeyError:            pass        if realm is not None and realm.is_zephyr_mirror_realm:            # For MIT users, we can get an authoritative name from Hesiod.            # Technically we should check that this is actually an MIT            # realm, but we can cross that bridge if we ever get a non-MIT            # zephyr mirroring realm.            hesiod_name = compute_mit_user_fullname(email)            form = RegistrationForm(                initial={'full_name': hesiod_name if "@" not in hesiod_name else ""},                realm_creation=realm_creation)            name_validated = True        elif settings.POPULATE_PROFILE_VIA_LDAP:            for backend in get_backends():                if isinstance(backend, LDAPBackend):                    try:                        ldap_username = backend.django_to_ldap_username(email)                    except ZulipLDAPExceptionNoMatchingLDAPUser:                        logging.warning("New account email %s could not be found in LDAP" % (email,))                        form = RegistrationForm(realm_creation=realm_creation)                        break                    ldap_user = _LDAPUser(backend, ldap_username)                    try:                        ldap_full_name, _ = backend.get_mapped_name(ldap_user)                        request.session['authenticated_full_name'] = ldap_full_name                        name_validated = True                        # We don't use initial= here, because if the form is                        # complete (that is, no additional fields need to be                        # filled out by the user) we want the form to validate,                        # so they can be directly registered without having to                        # go through this interstitial.                        form = RegistrationForm({'full_name': ldap_full_name},                                                realm_creation=realm_creation)                        # Check whether this is ZulipLDAPAuthBackend,                        # which is responsible for authentication and                        # requires that LDAP accounts enter their LDAP                        # password to register, or ZulipLDAPUserPopulator,                        # which just populates UserProfile fields (no auth).                        require_ldap_password = isinstance(backend, ZulipLDAPAuthBackend)                        break                    except TypeError:                        # Let the user fill out a name and/or try another backend                        form = RegistrationForm(realm_creation=realm_creation)        elif prereg_user.full_name:            if prereg_user.full_name_validated:                request.session['authenticated_full_name'] = prereg_user.full_name                name_validated = True                form = RegistrationForm({'full_name': prereg_user.full_name},                                        realm_creation=realm_creation)            else:                form = RegistrationForm(initial={'full_name': prereg_user.full_name},                                        realm_creation=realm_creation)        elif 'full_name' in request.POST:            form = RegistrationForm(                initial={'full_name': request.POST.get('full_name')},                realm_creation=realm_creation            )        else:            form = RegistrationForm(realm_creation=realm_creation)    else:        postdata = request.POST.copy()        if name_changes_disabled(realm):            # If we populate profile information via LDAP and we have a            # verified name from you on file, use that. Otherwise, fall            # back to the full name in the request.            try:                postdata.update({'full_name': request.session['authenticated_full_name']})                name_validated = True            except KeyError:                pass        form = RegistrationForm(postdata, realm_creation=realm_creation)    if not (password_auth_enabled(realm) and password_required):        form['password'].field.required = False    if form.is_valid():        if password_auth_enabled(realm) and form['password'].field.required:            password = form.cleaned_data['password']        else:            # If the user wasn't prompted for a password when            # completing the authentication form (because they're            # signing up with SSO and no password is required), set            # the password field to `None` (Which causes Django to            # create an unusable password).            password = None        if realm_creation:            string_id = form.cleaned_data['realm_subdomain']            realm_name = form.cleaned_data['realm_name']            realm = do_create_realm(string_id, realm_name)            setup_realm_internal_bots(realm)        assert(realm is not None)        full_name = form.cleaned_data['full_name']        short_name = email_to_username(email)        default_stream_group_names = request.POST.getlist('default_stream_group')        default_stream_groups = lookup_default_stream_groups(default_stream_group_names, realm)        timezone = ""        if 'timezone' in request.POST and request.POST['timezone'] in get_all_timezones():            timezone = request.POST['timezone']        if 'source_realm' in request.POST and request.POST["source_realm"] != "on":            source_profile = get_source_profile(email, request.POST["source_realm"])        else:            source_profile = None        if not realm_creation:            try:                existing_user_profile = get_user_by_delivery_email(email, realm)  # type: Optional[UserProfile]            except UserProfile.DoesNotExist:                existing_user_profile = None        else:            existing_user_profile = None        user_profile = None  # type: Optional[UserProfile]        return_data = {}  # type: Dict[str, bool]        if ldap_auth_enabled(realm):            # If the user was authenticated using an external SSO            # mechanism like Google or GitHub auth, then authentication            # will have already been done before creating the            # PreregistrationUser object with password_required=False, and            # so we don't need to worry about passwords.            #            # If instead the realm is using EmailAuthBackend, we will            # set their password above.            #            # But if the realm is using LDAPAuthBackend, we need to verify            # their LDAP password (which will, as a side effect, create            # the user account) here using authenticate.            # pregeg_user.realm_creation carries the information about whether            # we're in realm creation mode, and the ldap flow will handle            # that and create the user with the appropriate parameters.            user_profile = authenticate(request,                                        username=email,                                        password=password,                                        realm=realm,                                        prereg_user=prereg_user,                                        return_data=return_data)            if user_profile is None:                if return_data.get("no_matching_ldap_user") and email_auth_enabled(realm):                    # If both the LDAP and Email auth backends are                    # enabled, and there's no matching user in the LDAP                    # directory then the intent is to create a user in the                    # realm with their email outside the LDAP organization                    # (with e.g. a password stored in the Zulip database,                    # not LDAP).  So we fall through and create the new                    # account.                    #                    # It's likely that we can extend this block to the                    # Google and GitHub auth backends with no code changes                    # other than here.                    pass                else:                    # TODO: This probably isn't going to give a                    # user-friendly error message, but it doesn't                    # particularly matter, because the registration form                    # is hidden for most users.                    return HttpResponseRedirect(reverse('django.contrib.auth.views.login') + '?email=' +                                                urllib.parse.quote_plus(email))            elif not realm_creation:                # Since we'll have created a user, we now just log them in.                return login_and_go_to_home(request, user_profile)            else:                # With realm_creation=True, we're going to return further down,                # after finishing up the creation process.                pass        if existing_user_profile is not None and existing_user_profile.is_mirror_dummy:            user_profile = existing_user_profile            do_activate_user(user_profile)            do_change_password(user_profile, password)            do_change_full_name(user_profile, full_name, user_profile)            do_set_user_display_setting(user_profile, 'timezone', timezone)            # TODO: When we clean up the `do_activate_user` code path,            # make it respect invited_as_admin / is_realm_admin.        if user_profile is None:            user_profile = do_create_user(email, password, realm, full_name, short_name,                                          prereg_user=prereg_user,                                          is_realm_admin=is_realm_admin,                                          is_guest=is_guest,                                          tos_version=settings.TOS_VERSION,                                          timezone=timezone,                                          newsletter_data={"IP": request.META['REMOTE_ADDR']},                                          default_stream_groups=default_stream_groups,                                          source_profile=source_profile,                                          realm_creation=realm_creation)        if realm_creation:            bulk_add_subscriptions([realm.signup_notifications_stream], [user_profile])            send_initial_realm_messages(realm)            # Because for realm creation, registration happens on the            # root domain, we need to log them into the subdomain for            # their new realm.            return redirect_and_log_into_subdomain(realm, full_name, email)        # This dummy_backend check below confirms the user is        # authenticating to the correct subdomain.        auth_result = authenticate(username=user_profile.delivery_email,                                   realm=realm,                                   return_data=return_data,                                   use_dummy_backend=True)        if return_data.get('invalid_subdomain'):            # By construction, this should never happen.            logging.error("Subdomain mismatch in registration %s: %s" % (                realm.subdomain, user_profile.delivery_email,))            return redirect('/')        return login_and_go_to_home(request, auth_result)    return render(        request,        'zerver/register.html',        context={'form': form,                 'email': email,                 'key': key,                 'full_name': request.session.get('authenticated_full_name', None),                 'lock_name': name_validated and name_changes_disabled(realm),                 # password_auth_enabled is normally set via our context processor,                 # but for the registration form, there is no logged in user yet, so                 # we have to set it here.                 'creating_new_team': realm_creation,                 'password_required': password_auth_enabled(realm) and password_required,                 'require_ldap_password': require_ldap_password,                 'password_auth_enabled': password_auth_enabled(realm),                 'root_domain_available': is_root_domain_available(),                 'default_stream_groups': get_default_stream_groups(realm),                 'accounts': get_accounts_for_email(email),                 'MAX_REALM_NAME_LENGTH': str(Realm.MAX_REALM_NAME_LENGTH),                 'MAX_NAME_LENGTH': str(UserProfile.MAX_NAME_LENGTH),                 'MAX_PASSWORD_LENGTH': str(form.MAX_PASSWORD_LENGTH),                 'MAX_REALM_SUBDOMAIN_LENGTH': str(Realm.MAX_REALM_SUBDOMAIN_LENGTH)                 }    )"