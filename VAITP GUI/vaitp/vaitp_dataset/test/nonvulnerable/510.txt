"def main():    module = AnsibleModule(        argument_spec=dict(            state=dict(type='str', default='present', choices=['present', 'absent']),            force=dict(type='bool', default=False),            path=dict(type='path', required=True),            privatekey_path=dict(type='path'),            privatekey_content=dict(type='str', no_log=True),            format=dict(type='str', default='PEM', choices=['OpenSSH', 'PEM']),            privatekey_passphrase=dict(type='str', no_log=True),            backup=dict(type='bool', default=False),            select_crypto_backend=dict(type='str', choices=['auto', 'pyopenssl', 'cryptography'], default='auto'),            return_content=dict(type='bool', default=False),        ),        supports_check_mode=True,        add_file_common_args=True,        required_if=[('state', 'present', ['privatekey_path', 'privatekey_content'], True)],        mutually_exclusive=(            ['privatekey_path', 'privatekey_content'],        ),    )    minimal_cryptography_version = MINIMAL_CRYPTOGRAPHY_VERSION    if module.params['format'] == 'OpenSSH':        minimal_cryptography_version = MINIMAL_CRYPTOGRAPHY_VERSION_OPENSSH    backend = module.params['select_crypto_backend']    if backend == 'auto':        # Detection what is possible        can_use_cryptography = CRYPTOGRAPHY_FOUND and CRYPTOGRAPHY_VERSION >= LooseVersion(minimal_cryptography_version)        can_use_pyopenssl = PYOPENSSL_FOUND and PYOPENSSL_VERSION >= LooseVersion(MINIMAL_PYOPENSSL_VERSION)        # Decision        if can_use_cryptography:            backend = 'cryptography'        elif can_use_pyopenssl:            if module.params['format'] == 'OpenSSH':                module.fail_json(                    msg=missing_required_lib('cryptography >= {0}'.format(MINIMAL_CRYPTOGRAPHY_VERSION_OPENSSH)),                    exception=CRYPTOGRAPHY_IMP_ERR                )            backend = 'pyopenssl'        # Success?        if backend == 'auto':            module.fail_json(msg=("Can't detect any of the required Python libraries "                                  "cryptography (>= {0}) or PyOpenSSL (>= {1})").format(                                      minimal_cryptography_version,                                      MINIMAL_PYOPENSSL_VERSION))    if module.params['format'] == 'OpenSSH' and backend != 'cryptography':        module.fail_json(msg="Format OpenSSH requires the cryptography backend.")    if backend == 'pyopenssl':        if not PYOPENSSL_FOUND:            module.fail_json(msg=missing_required_lib('pyOpenSSL >= {0}'.format(MINIMAL_PYOPENSSL_VERSION)),                             exception=PYOPENSSL_IMP_ERR)        module.deprecate('The module is using the PyOpenSSL backend. This backend has been deprecated',                         version='2.0.0', collection_name='community.crypto')    elif backend == 'cryptography':        if not CRYPTOGRAPHY_FOUND:            module.fail_json(msg=missing_required_lib('cryptography >= {0}'.format(minimal_cryptography_version)),                             exception=CRYPTOGRAPHY_IMP_ERR)    base_dir = os.path.dirname(module.params['path']) or '.'    if not os.path.isdir(base_dir):        module.fail_json(            name=base_dir,            msg="The directory '%s' does not exist or the file is not a directory" % base_dir        )    try:        public_key = PublicKey(module, backend)        if public_key.state == 'present':            if module.check_mode:                result = public_key.dump()                result['changed'] = module.params['force'] or not public_key.check(module)                module.exit_json(**result)            public_key.generate(module)        else:            if module.check_mode:                result = public_key.dump()                result['changed'] = os.path.exists(module.params['path'])                module.exit_json(**result)            public_key.remove(module)        result = public_key.dump()        module.exit_json(**result)    except OpenSSLObjectError as exc:        module.fail_json(msg=to_native(exc))"