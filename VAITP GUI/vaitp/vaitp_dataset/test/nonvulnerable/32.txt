"    def _ensure_authed(self, ptype, message):        """        Checks message type against current auth state.        If server mode, and auth has not succeeded, and the message is of a        post-auth type (channel open or global request) an appropriate error        response Message is crafted and returned to caller for sending.        Otherwise (client mode, authed, or pre-auth message) returns None.        """        if (            not self.server_mode            or ptype <= HIGHEST_USERAUTH_MESSAGE_ID            or self.is_authenticated()        ):            return None        # WELP. We must be dealing with someone trying to do non-auth things        # without being authed. Tell them off, based on message class.        reply = Message()        # Global requests have no details, just failure.        if ptype == MSG_GLOBAL_REQUEST:            reply.add_byte(cMSG_REQUEST_FAILURE)        # Channel opens let us reject w/ a specific type + message.        elif ptype == MSG_CHANNEL_OPEN:            kind = message.get_text()            chanid = message.get_int()            reply.add_byte(cMSG_CHANNEL_OPEN_FAILURE)            reply.add_int(chanid)            reply.add_int(OPEN_FAILED_ADMINISTRATIVELY_PROHIBITED)            reply.add_string('')            reply.add_string('en')        # NOTE: Post-open channel messages do not need checking; the above will        # reject attemps to open channels, meaning that even if a malicious        # user tries to send a MSG_CHANNEL_REQUEST, it will simply fall under        # the logic that handles unknown channel IDs (as the channel list will        # be empty.)        return reply"