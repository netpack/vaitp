"def sendEmail(sydent, templateFile, mailTo, substitutions):    """    Sends an email with the given parameters.    :param sydent: The Sydent instance to use when building the configuration to send the        email with.    :type sydent: sydent.sydent.Sydent    :param templateFile: The filename of the template to use when building the body of the        email.    :type templateFile: str    :param mailTo: The email address to send the email to.    :type mailTo: unicode    :param substitutions: The substitutions to use with the template.    :type substitutions: dict[str, str]    """    mailFrom = sydent.cfg.get('email', 'email.from')    myHostname = sydent.cfg.get('email', 'email.hostname')    if myHostname == '':        myHostname = socket.getfqdn()    midRandom = "".join([random.choice(string.ascii_letters) for _ in range(16)])    messageid = "<%d%s@%s>" % (time_msec(), midRandom, myHostname)    substitutions.update({        'messageid': messageid,        'date': email.utils.formatdate(localtime=False),        'to': mailTo,        'from': mailFrom,    })    allSubstitutions = {}    for k, v in substitutions.items():        allSubstitutions[k] = v        allSubstitutions[k+"_forhtml"] = escape(v)        allSubstitutions[k+"_forurl"] = urllib.parse.quote(v)    # We add randomize the multipart boundary to stop user input from    # conflicting with it.    allSubstitutions["multipart_boundary"] = generateAlphanumericTokenOfLength(32)    mailString = open(templateFile).read() % allSubstitutions    parsedFrom = email.utils.parseaddr(mailFrom)[1]    parsedTo = email.utils.parseaddr(mailTo)[1]    if parsedFrom == '' or parsedTo == '':        logger.info("Couldn't parse from / to address %s / %s", mailFrom, mailTo)        raise EmailAddressException()    if parsedTo != mailTo:        logger.info("Parsed to address changed the address: %s -> %s", mailTo, parsedTo)        raise EmailAddressException()    mailServer = sydent.cfg.get('email', 'email.smtphost')    mailPort = sydent.cfg.get('email', 'email.smtpport')    mailUsername = sydent.cfg.get('email', 'email.smtpusername')    mailPassword = sydent.cfg.get('email', 'email.smtppassword')    mailTLSMode = sydent.cfg.get('email', 'email.tlsmode')    logger.info("Sending mail to %s with mail server: %s" % (mailTo, mailServer,))    try:        if mailTLSMode == 'SSL' or mailTLSMode == 'TLS':            smtp = smtplib.SMTP_SSL(mailServer, mailPort, myHostname)        elif mailTLSMode == 'STARTTLS':            smtp = smtplib.SMTP(mailServer, mailPort, myHostname)            smtp.starttls()        else:            smtp = smtplib.SMTP(mailServer, mailPort, myHostname)        if mailUsername != '':            smtp.login(mailUsername, mailPassword)        # We're using the parsing above to do basic validation, but instead of        # failing it may munge the address it returns. So we should *not* use        # that parsed address, as it may not match any validation done        # elsewhere.        smtp.sendmail(mailFrom, mailTo, mailString.encode('utf-8'))        smtp.quit()    except Exception as origException:        twisted.python.log.err()        ese = EmailSendException()        ese.cause = origException        raise ese"