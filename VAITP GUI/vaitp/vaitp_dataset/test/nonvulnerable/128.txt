"    def render_POST(self, request):        send_cors(request)        args = get_args(request, ("medium", "address", "room_id", "sender",))        medium = args["medium"]        address = args["address"]        roomId = args["room_id"]        sender = args["sender"]        verified_sender = None        if self.require_auth:            account = authV2(self.sydent, request)            verified_sender = sender            if account.userId != sender:                raise MatrixRestError(403, "M_UNAUTHORIZED", "'sender' doesn't match")        globalAssocStore = GlobalAssociationStore(self.sydent)        mxid = globalAssocStore.getMxid(medium, address)        if mxid:            request.setResponseCode(400)            return {                "errcode": "M_THREEPID_IN_USE",                "error": "Binding already known",                "mxid": mxid,            }        if medium != "email":            request.setResponseCode(400)            return {                "errcode": "M_UNRECOGNIZED",                "error": "Didn't understand medium '%s'" % (medium,),            }        token = self._randomString(128)        tokenStore = JoinTokenStore(self.sydent)        ephemeralPrivateKey = nacl.signing.SigningKey.generate()        ephemeralPublicKey = ephemeralPrivateKey.verify_key        ephemeralPrivateKeyBase64 = encode_base64(ephemeralPrivateKey.encode(), True)        ephemeralPublicKeyBase64 = encode_base64(ephemeralPublicKey.encode(), True)        tokenStore.storeEphemeralPublicKey(ephemeralPublicKeyBase64)        tokenStore.storeToken(medium, address, roomId, sender, token)        # Variables to substitute in the template.        substitutions = {}        # Include all arguments sent via the request.        for k, v in args.items():            if isinstance(v, string_types):                substitutions[k] = v        substitutions["token"] = token        # Substitutions that the template requires, but are optional to provide        # to the API.        extra_substitutions = [            'sender_display_name',            'token',            'room_name',            'bracketed_room_name',            'room_avatar_url',            'sender_avatar_url',            'guest_user_id',            'guest_access_token',        ]        for k in extra_substitutions:            substitutions.setdefault(k, '')        substitutions["bracketed_verified_sender"] = ""        if verified_sender:            substitutions["bracketed_verified_sender"] = "(%s) " % (verified_sender,)        substitutions["ephemeral_private_key"] = ephemeralPrivateKeyBase64        if substitutions["room_name"] != '':            substitutions["bracketed_room_name"] = "(%s) " % substitutions["room_name"]        substitutions["web_client_location"] = self.sydent.default_web_client_location        if 'org.matrix.web_client_location' in substitutions:            substitutions["web_client_location"] = substitutions.pop("org.matrix.web_client_location")        subject_header = Header(self.sydent.cfg.get('email', 'email.invite.subject', raw=True) % substitutions, 'utf8')        substitutions["subject_header_value"] = subject_header.encode()        brand = self.sydent.brand_from_request(request)        templateFile = self.sydent.get_branded_template(            brand,            "invite_template.eml",            ('email', 'email.invite_template'),        )        sendEmail(self.sydent, templateFile, address, substitutions)        pubKey = self.sydent.keyring.ed25519.verify_key        pubKeyBase64 = encode_base64(pubKey.encode())        baseUrl = "%s/_matrix/identity/api/v1" % (self.sydent.cfg.get('http', 'client_http_base'),)        keysToReturn = []        keysToReturn.append({            "public_key": pubKeyBase64,            "key_validity_url": baseUrl + "/pubkey/isvalid",        })        keysToReturn.append({            "public_key": ephemeralPublicKeyBase64,            "key_validity_url": baseUrl + "/pubkey/ephemeral/isvalid",        })        resp = {            "token": token,            "public_key": pubKeyBase64,            "public_keys": keysToReturn,            "display_name": self.redact_email_address(address),        }        return resp"