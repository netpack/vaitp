"    def http_reflect_with_auth_handler(request):        auth_header = request.headers.get("authorization", "")        if not auth_header:            return deny()        try:            auth_parsed = httplib2.auth._parse_www_authenticate(request.headers, "authorization")            print("debug: auth_parsed", auth_parsed)        except httplib2.error.MalformedHeader:            print("debug: auth header error")            return http_response_bytes(status=400, body=b"authorization header syntax error")        scheme = auth_header.split(" ", 1)[0].lower()        print("debug: first auth scheme='{}'".format(scheme))        if scheme != allow_scheme:            return deny(body=b"must use different auth scheme")        auth_info = auth_parsed[scheme]        if scheme == "basic":            decoded = base64.b64decode(auth_info["token"]).decode()            username, password = decoded.split(":", 1)            if (username, password) in allow_credentials:                return make_http_reflect()(request)            else:                return deny(body=b"supplied credentials are not allowed")        elif scheme == "digest":            server_nonce_old = gserver_nonce[0]            nextnonce = gnextnonce[0]            if nextnonce:                # server decided to change nonce, in this case, guided by caller test code                gserver_nonce[0] = nextnonce                gnextnonce[0] = None            server_nonce_current = gserver_nonce[0]            client_cnonce = auth_info.get("cnonce", "")            client_nc = auth_info.get("nc", "")            client_nonce = auth_info.get("nonce", "")            client_opaque = auth_info.get("opaque", "")            client_qop = auth_info.get("qop", "auth").strip('"')            # TODO: auth_info.get('algorithm', 'md5')            hasher = hashlib.md5            # TODO: client_qop auth-int            ha2 = hasher(":".join((request.method, request.uri)).encode()).hexdigest()            if client_nonce != server_nonce_current:                if client_nonce == server_nonce_old:                    return deny(nonce_stale=True)                return deny(body=b"invalid nonce")            if not client_nc:                return deny(body=b"auth-info nc missing")            if client_opaque != server_opaque:                return deny(                    body="auth-info opaque mismatch expected={} actual={}".format(server_opaque, client_opaque).encode()                )            for allow_username, allow_password in allow_credentials:                ha1 = hasher(":".join((allow_username, realm, allow_password)).encode()).hexdigest()                allow_response = hasher(                    ":".join((ha1, client_nonce, client_nc, client_cnonce, client_qop, ha2)).encode()                ).hexdigest()                rspauth_ha2 = hasher(":{}".format(request.uri).encode()).hexdigest()                rspauth = hasher(                    ":".join((ha1, client_nonce, client_nc, client_cnonce, client_qop, rspauth_ha2,)).encode()                ).hexdigest()                if auth_info.get("response", "") == allow_response:                    # TODO: fix or remove doubtful comment                    # do we need to save nc only on success?                    glastnc[0] = client_nc                    allow_headers = {                        "authentication-info": ", ".join(filter(None,                            (                                'nextnonce="{}"'.format(nextnonce) if nextnonce else "",                                "qop={}".format(client_qop),                                'rspauth="{}"'.format(rspauth),                                'cnonce="{}"'.format(client_cnonce),                                "nc={}".format(client_nc),                            ))                        ).strip()                    }                    return make_http_reflect(headers=allow_headers)(request)            return deny(body=b"supplied credentials are not allowed")        elif scheme == "wsse":            x_wsse = request.headers.get("x-wsse", "")            if x_wsse.count(",") != 3:                return http_response_bytes(status=400, body=b"x-wsse header syntax error")            wsse_params = httplib2.auth._parse_www_authenticate(request.headers, "x-wsse").get("usernametoken", {})            print("debug: wsse_params", wsse_params)            client_username = wsse_params.get("username", "")            client_nonce = wsse_params.get("nonce", "")            client_created = wsse_params.get("created", "")            client_digest = wsse_params.get("passworddigest", "")            allow_password = None            for allow_username, allow_password in allow_credentials:                if client_username == allow_username:                    break            else:                return deny(body=b"unknown username")            digest = hashlib.sha1("".join((client_nonce, client_created, allow_password)).encode("utf-8")).digest()            digest_b64 = base64.b64encode(digest).decode()            print("debug: check client={} == real={}".format(client_digest, digest_b64))            if client_digest == digest_b64:                return make_http_reflect()(request)            return deny(body=b"supplied credentials are not allowed")        else:            return http_response_bytes(status=400, body="unknown authorization scheme={0}".format(scheme).encode(),)"