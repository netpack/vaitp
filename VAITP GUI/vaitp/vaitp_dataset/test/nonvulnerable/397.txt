"def http_reflect_with_auth(allow_scheme, allow_credentials, out_renew_nonce=None, out_requests=None):    """allow_scheme - 'basic', 'digest', etc allow_credentials - sequence of ('name', 'password') out_renew_nonce - None | [function]        Way to return nonce renew function to caller.        Kind of `out` parameter in some programming languages.        Allows to keep same signature for all handler builder functions.    out_requests - None | []        If set to list, every parsed request will be appended here.    """    glastnc = [None]    gnextnonce = [None]    gserver_nonce = [gen_digest_nonce(salt=b"n")]    realm = "httplib2 test"    server_opaque = gen_digest_nonce(salt=b"o")    def renew_nonce():        if gnextnonce[0]:            assert False, "previous nextnonce was not used, probably bug in test code"        gnextnonce[0] = gen_digest_nonce()        return gserver_nonce[0], gnextnonce[0]    if out_renew_nonce:        out_renew_nonce[0] = renew_nonce    def deny(**kwargs):        nonce_stale = kwargs.pop("nonce_stale", False)        if nonce_stale:            kwargs.setdefault("body", b"nonce stale")        if allow_scheme == "basic":            authenticate = 'basic realm="{realm}"'.format(realm=realm)        elif allow_scheme == "digest":            authenticate = (                'digest realm="{realm}", qop="auth"'                + ', nonce="{nonce}", opaque="{opaque}"'                + (", stale=true" if nonce_stale else "")            ).format(realm=realm, nonce=gserver_nonce[0], opaque=server_opaque)        elif allow_scheme == "wsse":            authenticate = 'wsse realm="{realm}", profile="UsernameToken"'.format(realm=realm)        else:            raise Exception("unknown allow_scheme={0}".format(allow_scheme))        deny_headers = {"www-authenticate": authenticate}        kwargs.setdefault("status", 401)        # supplied headers may overwrite generated ones        deny_headers.update(kwargs.get("headers", {}))        kwargs["headers"] = deny_headers        kwargs.setdefault("body", b"HTTP authorization required")        return http_response_bytes(**kwargs)    @store_request_response(out_requests)    def http_reflect_with_auth_handler(request):        auth_header = request.headers.get("authorization", "")        if not auth_header:            return deny()        try:            auth_parsed = httplib2.auth._parse_www_authenticate(request.headers, "authorization")            print("debug: auth_parsed", auth_parsed)        except httplib2.error.MalformedHeader:            print("debug: auth header error")            return http_response_bytes(status=400, body=b"authorization header syntax error")        scheme = auth_header.split(" ", 1)[0].lower()        print("debug: first auth scheme='{}'".format(scheme))        if scheme != allow_scheme:            return deny(body=b"must use different auth scheme")        auth_info = auth_parsed[scheme]        if scheme == "basic":            decoded = base64.b64decode(auth_info["token"]).decode()            username, password = decoded.split(":", 1)            if (username, password) in allow_credentials:                return make_http_reflect()(request)            else:                return deny(body=b"supplied credentials are not allowed")        elif scheme == "digest":            server_nonce_old = gserver_nonce[0]            nextnonce = gnextnonce[0]            if nextnonce:                # server decided to change nonce, in this case, guided by caller test code                gserver_nonce[0] = nextnonce                gnextnonce[0] = None            server_nonce_current = gserver_nonce[0]            client_cnonce = auth_info.get("cnonce", "")            client_nc = auth_info.get("nc", "")            client_nonce = auth_info.get("nonce", "")            client_opaque = auth_info.get("opaque", "")            client_qop = auth_info.get("qop", "auth").strip('"')            # TODO: auth_info.get('algorithm', 'md5')            hasher = hashlib.md5            # TODO: client_qop auth-int            ha2 = hasher(":".join((request.method, request.uri)).encode()).hexdigest()            if client_nonce != server_nonce_current:                if client_nonce == server_nonce_old:                    return deny(nonce_stale=True)                return deny(body=b"invalid nonce")            if not client_nc:                return deny(body=b"auth-info nc missing")            if client_opaque != server_opaque:                return deny(                    body="auth-info opaque mismatch expected={} actual={}".format(server_opaque, client_opaque).encode()                )            for allow_username, allow_password in allow_credentials:                ha1 = hasher(":".join((allow_username, realm, allow_password)).encode()).hexdigest()                allow_response = hasher(                    ":".join((ha1, client_nonce, client_nc, client_cnonce, client_qop, ha2)).encode()                ).hexdigest()                rspauth_ha2 = hasher(":{}".format(request.uri).encode()).hexdigest()                rspauth = hasher(                    ":".join((ha1, client_nonce, client_nc, client_cnonce, client_qop, rspauth_ha2,)).encode()                ).hexdigest()                if auth_info.get("response", "") == allow_response:                    # TODO: fix or remove doubtful comment                    # do we need to save nc only on success?                    glastnc[0] = client_nc                    allow_headers = {                        "authentication-info": ", ".join(filter(None,                            (                                'nextnonce="{}"'.format(nextnonce) if nextnonce else "",                                "qop={}".format(client_qop),                                'rspauth="{}"'.format(rspauth),                                'cnonce="{}"'.format(client_cnonce),                                "nc={}".format(client_nc),                            ))                        ).strip()                    }                    return make_http_reflect(headers=allow_headers)(request)            return deny(body=b"supplied credentials are not allowed")        elif scheme == "wsse":            x_wsse = request.headers.get("x-wsse", "")            if x_wsse.count(",") != 3:                return http_response_bytes(status=400, body=b"x-wsse header syntax error")            wsse_params = httplib2.auth._parse_www_authenticate(request.headers, "x-wsse").get("usernametoken", {})            print("debug: wsse_params", wsse_params)            client_username = wsse_params.get("username", "")            client_nonce = wsse_params.get("nonce", "")            client_created = wsse_params.get("created", "")            client_digest = wsse_params.get("passworddigest", "")            allow_password = None            for allow_username, allow_password in allow_credentials:                if client_username == allow_username:                    break            else:                return deny(body=b"unknown username")            digest = hashlib.sha1("".join((client_nonce, client_created, allow_password)).encode("utf-8")).digest()            digest_b64 = base64.b64encode(digest).decode()            print("debug: check client={} == real={}".format(client_digest, digest_b64))            if client_digest == digest_b64:                return make_http_reflect()(request)            return deny(body=b"supplied credentials are not allowed")        else:            return http_response_bytes(status=400, body="unknown authorization scheme={0}".format(scheme).encode(),)    return http_reflect_with_auth_handler"