"    def _do_get_well_known(self, server_name):        """Actually fetch and parse a .well-known, without checking the cache        :param server_name: Name of the server, from the requested url        :type server_name: bytes        :returns a tuple of (result, cache period), where result is one of:            - the new server name from the .well-known (as a `bytes`)            - None if there was no .well-known file.            - INVALID_WELL_KNOWN if the .well-known was invalid        :rtype: Deferred[Tuple[bytes|None|object],int]        """        uri = b"https://%s/.well-known/matrix/server" % (server_name, )        uri_str = uri.decode("ascii")        logger.info("Fetching %s", uri_str)        try:            response = yield self._well_known_agent.request(b"GET", uri)            body = yield readBody(response)            if response.code != 200:                raise Exception("Non-200 response %s" % (response.code, ))            parsed_body = json.loads(body.decode('utf-8'))            logger.info("Response from .well-known: %s", parsed_body)            if not isinstance(parsed_body, dict):                raise Exception("not a dict")            if "m.server" not in parsed_body:                raise Exception("Missing key 'm.server'")        except Exception as e:            logger.info("Error fetching %s: %s", uri_str, e)            # add some randomness to the TTL to avoid a stampeding herd every hour            # after startup            cache_period = WELL_KNOWN_INVALID_CACHE_PERIOD            cache_period += random.uniform(0, WELL_KNOWN_DEFAULT_CACHE_PERIOD_JITTER)            defer.returnValue((None, cache_period))        result = parsed_body["m.server"].encode("ascii")        cache_period = _cache_period_from_headers(            response.headers,            time_now=self._reactor.seconds,        )        if cache_period is None:            cache_period = WELL_KNOWN_DEFAULT_CACHE_PERIOD            # add some randomness to the TTL to avoid a stampeding herd every 24 hours            # after startup            cache_period += random.uniform(0, WELL_KNOWN_DEFAULT_CACHE_PERIOD_JITTER)        else:            cache_period = min(cache_period, WELL_KNOWN_MAX_CACHE_PERIOD)        defer.returnValue((result, cache_period))"