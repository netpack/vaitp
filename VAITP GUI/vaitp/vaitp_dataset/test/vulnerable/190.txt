"    def rpn(self, irc, msg, args):        """<rpn math expression>        Returns the value of an RPN expression.        """        stack = []        for arg in args:            try:                x = complex(arg)                if x == abs(x):                    x = abs(x)                stack.append(x)            except ValueError: # Not a float.                if arg in self._mathSafeEnv:                    f = self._mathSafeEnv[arg]                    if callable(f):                        called = False                        arguments = []                        while not called and stack:                            arguments.append(stack.pop())                            try:                                stack.append(f(*arguments))                                called = True                            except TypeError:                                pass                        if not called:                            irc.error(_('Not enough arguments for %s') % arg)                            return                    else:                        stack.append(f)                elif arg in self._rpnEnv:                    self._rpnEnv[arg](stack)                else:                    arg2 = stack.pop()                    arg1 = stack.pop()                    s = '%s%s%s' % (arg1, arg, arg2)                    try:                        stack.append(eval(s, self._mathSafeEnv, self._mathSafeEnv))                    except SyntaxError:                        irc.error(format(_('%q is not a defined function.'),                                         arg))                        return        if len(stack) == 1:            irc.reply(str(self._complexToString(complex(stack[0]))))        else:            s = ', '.join(map(self._complexToString, list(map(complex, stack))))            irc.reply(_('Stack: [%s]') % s)"