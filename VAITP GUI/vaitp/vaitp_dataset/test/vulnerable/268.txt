"    def http_reflect_with_auth_handler(request):        auth_header = request.headers.get("authorization", "")        if not auth_header:            return deny()        if " " not in auth_header:            return http_response_bytes(status=400, body=b"authorization header syntax error")        scheme, data = auth_header.split(" ", 1)        scheme = scheme.lower()        if scheme != allow_scheme:            return deny(body=b"must use different auth scheme")        if scheme == "basic":            decoded = base64.b64decode(data).decode()            username, password = decoded.split(":", 1)            if (username, password) in allow_credentials:                return make_http_reflect()(request)            else:                return deny(body=b"supplied credentials are not allowed")        elif scheme == "digest":            server_nonce_old = gserver_nonce[0]            nextnonce = gnextnonce[0]            if nextnonce:                # server decided to change nonce, in this case, guided by caller test code                gserver_nonce[0] = nextnonce                gnextnonce[0] = None            server_nonce_current = gserver_nonce[0]            auth_info = http_parse_auth(data)            client_cnonce = auth_info.get("cnonce", "")            client_nc = auth_info.get("nc", "")            client_nonce = auth_info.get("nonce", "")            client_opaque = auth_info.get("opaque", "")            client_qop = auth_info.get("qop", "auth").strip('"')            # TODO: auth_info.get('algorithm', 'md5')            hasher = hashlib.md5            # TODO: client_qop auth-int            ha2 = hasher(":".join((request.method, request.uri)).encode()).hexdigest()            if client_nonce != server_nonce_current:                if client_nonce == server_nonce_old:                    return deny(nonce_stale=True)                return deny(body=b"invalid nonce")            if not client_nc:                return deny(body=b"auth-info nc missing")            if client_opaque != server_opaque:                return deny(                    body="auth-info opaque mismatch expected={} actual={}".format(                        server_opaque, client_opaque                    ).encode()                )            for allow_username, allow_password in allow_credentials:                ha1 = hasher(                    ":".join((allow_username, realm, allow_password)).encode()                ).hexdigest()                allow_response = hasher(                    ":".join(                        (ha1, client_nonce, client_nc, client_cnonce, client_qop, ha2)                    ).encode()                ).hexdigest()                rspauth_ha2 = hasher(":{}".format(request.uri).encode()).hexdigest()                rspauth = hasher(                    ":".join(                        (                            ha1,                            client_nonce,                            client_nc,                            client_cnonce,                            client_qop,                            rspauth_ha2,                        )                    ).encode()                ).hexdigest()                if auth_info.get("response", "") == allow_response:                    # TODO: fix or remove doubtful comment                    # do we need to save nc only on success?                    glastnc[0] = client_nc                    allow_headers = {                        "authentication-info": " ".join(                            (                                'nextnonce="{}"'.format(nextnonce) if nextnonce else "",                                "qop={}".format(client_qop),                                'rspauth="{}"'.format(rspauth),                                'cnonce="{}"'.format(client_cnonce),                                "nc={}".format(client_nc),                            )                        ).strip()                    }                    return make_http_reflect(headers=allow_headers)(request)            return deny(body=b"supplied credentials are not allowed")        elif scheme == "wsse":            x_wsse = request.headers.get("x-wsse", "")            if x_wsse.count(",") != 3:                return http_response_bytes(status=400, body=b"x-wsse header syntax error")            auth_info = http_parse_auth(x_wsse)            client_username = auth_info.get("username", "")            client_nonce = auth_info.get("nonce", "")            client_created = auth_info.get("created", "")            client_digest = auth_info.get("passworddigest", "")            allow_password = None            for allow_username, allow_password in allow_credentials:                if client_username == allow_username:                    break            else:                return deny(body=b"unknown username")            digest = hashlib.sha1("".join((client_nonce, client_created, allow_password)).encode("utf-8")).digest()            digest_b64 = base64.b64encode(digest).decode()            print("$$$ check client={} == real={}".format(client_digest, digest_b64))            if client_digest == digest_b64:                return make_http_reflect()(request)            return deny(body=b"supplied credentials are not allowed")        else:            return http_response_bytes(status=400, body="unknown authorization scheme={0}".format(scheme).encode(),)"