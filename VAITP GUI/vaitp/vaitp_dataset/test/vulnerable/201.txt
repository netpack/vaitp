"    def visitModule(self, mod):        self.emit("""typedef struct {    PyObject_HEAD    PyObject *dict;} AST_object;static voidast_dealloc(AST_object *self){    Py_CLEAR(self->dict);    Py_TYPE(self)->tp_free(self);}static intast_traverse(AST_object *self, visitproc visit, void *arg){    Py_VISIT(self->dict);    return 0;}static voidast_clear(AST_object *self){    Py_CLEAR(self->dict);}static intast_type_init(PyObject *self, PyObject *args, PyObject *kw){    _Py_IDENTIFIER(_fields);    Py_ssize_t i, numfields = 0;    int res = -1;    PyObject *key, *value, *fields;    fields = _PyObject_GetAttrId((PyObject*)Py_TYPE(self), &PyId__fields);    if (!fields)        PyErr_Clear();    if (fields) {        numfields = PySequence_Size(fields);        if (numfields == -1)            goto cleanup;    }    res = 0; /* if no error occurs, this stays 0 to the end */    if (PyTuple_GET_SIZE(args) > 0) {        if (numfields != PyTuple_GET_SIZE(args)) {            PyErr_Format(PyExc_TypeError, "%.400s constructor takes %s"                         "%zd positional argument%s",                         Py_TYPE(self)->tp_name,                         numfields == 0 ? "" : "either 0 or ",                         numfields, numfields == 1 ? "" : "s");            res = -1;            goto cleanup;        }        for (i = 0; i < PyTuple_GET_SIZE(args); i++) {            /* cannot be reached when fields is NULL */            PyObject *name = PySequence_GetItem(fields, i);            if (!name) {                res = -1;                goto cleanup;            }            res = PyObject_SetAttr(self, name, PyTuple_GET_ITEM(args, i));            Py_DECREF(name);            if (res < 0)                goto cleanup;        }    }    if (kw) {        i = 0;  /* needed by PyDict_Next */        while (PyDict_Next(kw, &i, &key, &value)) {            res = PyObject_SetAttr(self, key, value);            if (res < 0)                goto cleanup;        }    }  cleanup:    Py_XDECREF(fields);    return res;}/* Pickling support */static PyObject *ast_type_reduce(PyObject *self, PyObject *unused){    PyObject *res;    _Py_IDENTIFIER(__dict__);    PyObject *dict = _PyObject_GetAttrId(self, &PyId___dict__);    if (dict == NULL) {        if (PyErr_ExceptionMatches(PyExc_AttributeError))            PyErr_Clear();        else            return NULL;    }    if (dict) {        res = Py_BuildValue("O()O", Py_TYPE(self), dict);        Py_DECREF(dict);        return res;    }    return Py_BuildValue("O()", Py_TYPE(self));}static PyMethodDef ast_type_methods[] = {    {"__reduce__", ast_type_reduce, METH_NOARGS, NULL},    {NULL}};static PyGetSetDef ast_type_getsets[] = {    {"__dict__", PyObject_GenericGetDict, PyObject_GenericSetDict},    {NULL}};static PyTypeObject AST_type = {    PyVarObject_HEAD_INIT(NULL, 0)    "_ast3.AST",    sizeof(AST_object),    0,    (destructor)ast_dealloc, /* tp_dealloc */    0,                       /* tp_print */    0,                       /* tp_getattr */    0,                       /* tp_setattr */    0,                       /* tp_reserved */    0,                       /* tp_repr */    0,                       /* tp_as_number */    0,                       /* tp_as_sequence */    0,                       /* tp_as_mapping */    0,                       /* tp_hash */    0,                       /* tp_call */    0,                       /* tp_str */    PyObject_GenericGetAttr, /* tp_getattro */    PyObject_GenericSetAttr, /* tp_setattro */    0,                       /* tp_as_buffer */    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC, /* tp_flags */    0,                       /* tp_doc */    (traverseproc)ast_traverse, /* tp_traverse */    (inquiry)ast_clear,      /* tp_clear */    0,                       /* tp_richcompare */    0,                       /* tp_weaklistoffset */    0,                       /* tp_iter */    0,                       /* tp_iternext */    ast_type_methods,        /* tp_methods */    0,                       /* tp_members */    ast_type_getsets,        /* tp_getset */    0,                       /* tp_base */    0,                       /* tp_dict */    0,                       /* tp_descr_get */    0,                       /* tp_descr_set */    offsetof(AST_object, dict),/* tp_dictoffset */    (initproc)ast_type_init, /* tp_init */    PyType_GenericAlloc,     /* tp_alloc */    PyType_GenericNew,       /* tp_new */    PyObject_GC_Del,         /* tp_free */};static PyTypeObject* make_type(char *type, PyTypeObject* base, char**fields, int num_fields){    PyObject *fnames, *result;    int i;    fnames = PyTuple_New(num_fields);    if (!fnames) return NULL;    for (i = 0; i < num_fields; i++) {        PyObject *field = PyUnicode_FromString(fields[i]);        if (!field) {            Py_DECREF(fnames);            return NULL;        }        PyTuple_SET_ITEM(fnames, i, field);    }    result = PyObject_CallFunction((PyObject*)&PyType_Type, "s(O){sOss}",                    type, base, "_fields", fnames, "__module__", "_ast3");    Py_DECREF(fnames);    return (PyTypeObject*)result;}static int add_attributes(PyTypeObject* type, char**attrs, int num_fields){    int i, result;    _Py_IDENTIFIER(_attributes);    PyObject *s, *l = PyTuple_New(num_fields);    if (!l)        return 0;    for (i = 0; i < num_fields; i++) {        s = PyUnicode_FromString(attrs[i]);        if (!s) {            Py_DECREF(l);            return 0;        }        PyTuple_SET_ITEM(l, i, s);    }    result = _PyObject_SetAttrId((PyObject*)type, &PyId__attributes, l) >= 0;    Py_DECREF(l);    return result;}/* Conversion AST -> Python */static PyObject* ast2obj_list(asdl_seq *seq, PyObject* (*func)(void*)){    Py_ssize_t i, n = asdl_seq_LEN(seq);    PyObject *result = PyList_New(n);    PyObject *value;    if (!result)        return NULL;    for (i = 0; i < n; i++) {        value = func(asdl_seq_GET(seq, i));        if (!value) {            Py_DECREF(result);            return NULL;        }        PyList_SET_ITEM(result, i, value);    }    return result;}static PyObject* ast2obj_object(void *o){    if (!o)        o = Py_None;    Py_INCREF((PyObject*)o);    return (PyObject*)o;}#define ast2obj_singleton ast2obj_object#define ast2obj_constant ast2obj_object#define ast2obj_identifier ast2obj_object#define ast2obj_string ast2obj_object#define ast2obj_bytes ast2obj_objectstatic PyObject* ast2obj_int(long b){    return PyLong_FromLong(b);}/* Conversion Python -> AST */static int obj2ast_singleton(PyObject *obj, PyObject** out, PyArena* arena){    if (obj != Py_None && obj != Py_True && obj != Py_False) {        PyErr_SetString(PyExc_ValueError,                        "AST singleton must be True, False, or None");        return 1;    }    *out = obj;    return 0;}static int obj2ast_object(PyObject* obj, PyObject** out, PyArena* arena){    if (obj == Py_None)        obj = NULL;    if (obj) {        if (PyArena_AddPyObject(arena, obj) < 0) {            *out = NULL;            return -1;        }        Py_INCREF(obj);    }    *out = obj;    return 0;}static int obj2ast_constant(PyObject* obj, PyObject** out, PyArena* arena){    if (obj) {        if (PyArena_AddPyObject(arena, obj) < 0) {            *out = NULL;            return -1;        }        Py_INCREF(obj);    }    *out = obj;    return 0;}static int obj2ast_identifier(PyObject* obj, PyObject** out, PyArena* arena){    if (!PyUnicode_CheckExact(obj) && obj != Py_None) {        PyErr_SetString(PyExc_TypeError, "AST identifier must be of type str");        return 1;    }    return obj2ast_object(obj, out, arena);}static int obj2ast_string(PyObject* obj, PyObject** out, PyArena* arena){    if (!PyUnicode_CheckExact(obj) && !PyBytes_CheckExact(obj)) {        PyErr_SetString(PyExc_TypeError, "AST string must be of type str");        return 1;    }    return obj2ast_object(obj, out, arena);}static int obj2ast_bytes(PyObject* obj, PyObject** out, PyArena* arena){    if (!PyBytes_CheckExact(obj)) {        PyErr_SetString(PyExc_TypeError, "AST bytes must be of type bytes");        return 1;    }    return obj2ast_object(obj, out, arena);}static int obj2ast_int(PyObject* obj, int* out, PyArena* arena){    int i;    if (!PyLong_Check(obj)) {        PyErr_Format(PyExc_ValueError, "invalid integer value: %R", obj);        return 1;    }    i = _PyLong_AsInt(obj);    if (i == -1 && PyErr_Occurred())        return 1;    *out = i;    return 0;}static int add_ast_fields(void){    PyObject *empty_tuple, *d;    if (PyType_Ready(&AST_type) < 0)        return -1;    d = AST_type.tp_dict;    empty_tuple = PyTuple_New(0);    if (!empty_tuple ||        PyDict_SetItemString(d, "_fields", empty_tuple) < 0 ||        PyDict_SetItemString(d, "_attributes", empty_tuple) < 0) {        Py_XDECREF(empty_tuple);        return -1;    }    Py_DECREF(empty_tuple);    return 0;}static int exists_not_none(PyObject *obj, _Py_Identifier *id){    int isnone;    PyObject *attr = _PyObject_GetAttrId(obj, id);    if (!attr) {        PyErr_Clear();        return 0;    }    isnone = attr == Py_None;    Py_DECREF(attr);    return !isnone;}""", 0, reflow=False)        self.emit("static int init_types(void)",0)        self.emit("{", 0)        self.emit("static int initialized;", 1)        self.emit("if (initialized) return 1;", 1)        self.emit("if (add_ast_fields() < 0) return 0;", 1)        for dfn in mod.dfns:            self.visit(dfn)        self.emit("initialized = 1;", 1)        self.emit("return 1;", 1);        self.emit("}", 0)"