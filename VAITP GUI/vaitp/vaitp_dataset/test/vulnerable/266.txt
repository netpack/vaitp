"def server_socket(fun, request_count=1, timeout=5, scheme="", tls=None):    """Base socket server for tests.    Likely you want to use server_request or other higher level helpers.    All arguments except fun can be passed to other server_* helpers.    :param fun: fun(client_sock, tick) called after successful accept().    :param request_count: test succeeds after exactly this number of requests, triggered by tick(request)    :param timeout: seconds.    :param scheme: affects yielded value        "" - build normal http/https URI.        string - build normal URI using supplied scheme.        None - yield (addr, port) tuple.    :param tls:        None (default) - plain HTTP.        True - HTTPS with reasonable defaults. Likely you want httplib2.Http(ca_certs=tests.CA_CERTS)        string - path to custom server cert+key PEM file.        callable - function(context, listener, skip_errors) -> ssl_wrapped_listener    """    gresult = [None]    gcounter = [0]    tls_skip_errors = [        "TLSV1_ALERT_UNKNOWN_CA",    ]    def tick(request):        gcounter[0] += 1        keep = True        keep &= gcounter[0] < request_count        if request is not None:            keep &= request.headers.get("connection", "").lower() != "close"        return keep    def server_socket_thread(srv):        try:            while gcounter[0] < request_count:                try:                    client, _ = srv.accept()                except ssl.SSLError as e:                    if e.reason in tls_skip_errors:                        return                    raise                try:                    client.settimeout(timeout)                    fun(client, tick)                finally:                    try:                        client.shutdown(socket.SHUT_RDWR)                    except (IOError, socket.error):                        pass                    # FIXME: client.close() introduces connection reset by peer                    # at least in other/connection_close test                    # should not be a problem since socket would close upon garbage collection            if gcounter[0] > request_count:                gresult[0] = Exception(                    "Request count expected={0} actual={1}".format(                        request_count, gcounter[0]                    )                )        except Exception as e:            # traceback.print_exc caused IOError: concurrent operation on sys.stderr.close() under setup.py test            print(traceback.format_exc(), file=sys.stderr)            gresult[0] = e    bind_hostname = "localhost"    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    server.bind((bind_hostname, 0))    try:        server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)    except socket.error as ex:        print("non critical error on SO_REUSEADDR", ex)    server.listen(10)    server.settimeout(timeout)    server_port = server.getsockname()[1]    if tls is True:        tls = SERVER_CHAIN    if tls:        context = ssl_context()        if callable(tls):            context.load_cert_chain(SERVER_CHAIN)            server = tls(context, server, tls_skip_errors)        else:            context.load_cert_chain(tls)            server = context.wrap_socket(server, server_side=True)    if scheme == "":        scheme = "https" if tls else "http"    t = threading.Thread(target=server_socket_thread, args=(server,))    t.daemon = True    t.start()    if scheme is None:        yield (bind_hostname, server_port)    else:        yield u"{scheme}://{host}:{port}/".format(scheme=scheme, host=bind_hostname, port=server_port)    server.close()    t.join()    if gresult[0] is not None:        raise gresult[0]"