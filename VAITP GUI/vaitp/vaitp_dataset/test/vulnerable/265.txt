"def parse_http_message(kind, buf):    if buf._end:        return None    try:        start_line = buf.readline()    except EOFError:        return None    msg = kind()    msg.raw = start_line    if kind is HttpRequest:        assert re.match(            br".+ HTTP/\d\.\d\r\n$", start_line        ), "Start line does not look like HTTP request: " + repr(start_line)        msg.method, msg.uri, msg.proto = start_line.rstrip().decode().split(" ", 2)        assert msg.proto.startswith("HTTP/"), repr(start_line)    elif kind is HttpResponse:        assert re.match(            br"^HTTP/\d\.\d \d+ .+\r\n$", start_line        ), "Start line does not look like HTTP response: " + repr(start_line)        msg.proto, msg.status, msg.reason = start_line.rstrip().decode().split(" ", 2)        msg.status = int(msg.status)        assert msg.proto.startswith("HTTP/"), repr(start_line)    else:        raise Exception("Use HttpRequest or HttpResponse .from_{bytes,buffered}")    msg.version = msg.proto[5:]    while True:        line = buf.readline()        msg.raw += line        line = line.rstrip()        if not line:            break        t = line.decode().split(":", 1)        msg.headers[t[0].lower()] = t[1].lstrip()    content_length_string = msg.headers.get("content-length", "")    if content_length_string.isdigit():        content_length = int(content_length_string)        msg.body = msg.body_raw = buf.read(content_length)    elif msg.headers.get("transfer-encoding") == "chunked":        raise NotImplemented    elif msg.version == "1.0":        msg.body = msg.body_raw = buf.readall()    else:        msg.body = msg.body_raw = b""    msg.raw += msg.body_raw    return msg"